"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-hook-form";
exports.ids = ["vendor-chunks/react-hook-form"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-hook-form/dist/index.esm.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/react-hook-form/dist/index.esm.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Controller: () => (/* binding */ Controller),\n/* harmony export */   Form: () => (/* binding */ Form),\n/* harmony export */   FormProvider: () => (/* binding */ FormProvider),\n/* harmony export */   appendErrors: () => (/* binding */ appendErrors),\n/* harmony export */   createFormControl: () => (/* binding */ createFormControl),\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   set: () => (/* binding */ set),\n/* harmony export */   useController: () => (/* binding */ useController),\n/* harmony export */   useFieldArray: () => (/* binding */ useFieldArray),\n/* harmony export */   useForm: () => (/* binding */ useForm),\n/* harmony export */   useFormContext: () => (/* binding */ useFormContext),\n/* harmony export */   useFormState: () => (/* binding */ useFormState),\n/* harmony export */   useWatch: () => (/* binding */ useWatch)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nvar isCheckBoxInput = (element)=>element.type === \"checkbox\";\nvar isDateObject = (value1)=>value1 instanceof Date;\nvar isNullOrUndefined = (value1)=>value1 == null;\nconst isObjectType = (value1)=>typeof value1 === \"object\";\nvar isObject = (value1)=>!isNullOrUndefined(value1) && !Array.isArray(value1) && isObjectType(value1) && !isDateObject(value1);\nvar getEventValue = (event)=>isObject(event) && event.target ? isCheckBoxInput(event.target) ? event.target.checked : event.target.value : event;\nvar getNodeParentName = (name)=>name.substring(0, name.search(/\\.\\d+(\\.|$)/)) || name;\nvar isNameInFieldArray = (names, name)=>names.has(getNodeParentName(name));\nvar isPlainObject = (tempObject)=>{\n    const prototypeCopy = tempObject.constructor && tempObject.constructor.prototype;\n    return isObject(prototypeCopy) && prototypeCopy.hasOwnProperty(\"isPrototypeOf\");\n};\nvar isWeb =  false && 0;\nfunction cloneObject(data) {\n    let copy;\n    const isArray = Array.isArray(data);\n    const isFileListInstance = typeof FileList !== \"undefined\" ? data instanceof FileList : false;\n    if (data instanceof Date) {\n        copy = new Date(data);\n    } else if (!(isWeb && (data instanceof Blob || isFileListInstance)) && (isArray || isObject(data))) {\n        copy = isArray ? [] : Object.create(Object.getPrototypeOf(data));\n        if (!isArray && !isPlainObject(data)) {\n            copy = data;\n        } else {\n            for(const key in data){\n                if (data.hasOwnProperty(key)) {\n                    copy[key] = cloneObject(data[key]);\n                }\n            }\n        }\n    } else {\n        return data;\n    }\n    return copy;\n}\nvar isKey = (value1)=>/^\\w*$/.test(value1);\nvar isUndefined = (val)=>val === undefined;\nvar compact = (value1)=>Array.isArray(value1) ? value1.filter(Boolean) : [];\nvar stringToPath = (input)=>compact(input.replace(/[\"|']|\\]/g, \"\").split(/\\.|\\[/));\nvar get = (object, path, defaultValue)=>{\n    if (!path || !isObject(object)) {\n        return defaultValue;\n    }\n    const result = (isKey(path) ? [\n        path\n    ] : stringToPath(path)).reduce((result, key)=>isNullOrUndefined(result) ? result : result[key], object);\n    return isUndefined(result) || result === object ? isUndefined(object[path]) ? defaultValue : object[path] : result;\n};\nvar isBoolean = (value1)=>typeof value1 === \"boolean\";\nvar set = (object, path, value1)=>{\n    let index = -1;\n    const tempPath = isKey(path) ? [\n        path\n    ] : stringToPath(path);\n    const length = tempPath.length;\n    const lastIndex = length - 1;\n    while(++index < length){\n        const key = tempPath[index];\n        let newValue = value1;\n        if (index !== lastIndex) {\n            const objValue = object[key];\n            newValue = isObject(objValue) || Array.isArray(objValue) ? objValue : !isNaN(+tempPath[index + 1]) ? [] : {};\n        }\n        if (key === \"__proto__\" || key === \"constructor\" || key === \"prototype\") {\n            return;\n        }\n        object[key] = newValue;\n        object = object[key];\n    }\n};\nconst EVENTS = {\n    BLUR: \"blur\",\n    FOCUS_OUT: \"focusout\",\n    CHANGE: \"change\"\n};\nconst VALIDATION_MODE = {\n    onBlur: \"onBlur\",\n    onChange: \"onChange\",\n    onSubmit: \"onSubmit\",\n    onTouched: \"onTouched\",\n    all: \"all\"\n};\nconst INPUT_VALIDATION_RULES = {\n    max: \"max\",\n    min: \"min\",\n    maxLength: \"maxLength\",\n    minLength: \"minLength\",\n    pattern: \"pattern\",\n    required: \"required\",\n    validate: \"validate\"\n};\nconst HookFormContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nHookFormContext.displayName = \"HookFormContext\";\n/**\n * This custom hook allows you to access the form context. useFormContext is intended to be used in deeply nested structures, where it would become inconvenient to pass the context as a prop. To be used with {@link FormProvider}.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/useformcontext) • [Demo](https://codesandbox.io/s/react-hook-form-v7-form-context-ytudi)\n *\n * @returns return all useForm methods\n *\n * @example\n * ```tsx\n * function App() {\n *   const methods = useForm();\n *   const onSubmit = data => console.log(data);\n *\n *   return (\n *     <FormProvider {...methods} >\n *       <form onSubmit={methods.handleSubmit(onSubmit)}>\n *         <NestedInput />\n *         <input type=\"submit\" />\n *       </form>\n *     </FormProvider>\n *   );\n * }\n *\n *  function NestedInput() {\n *   const { register } = useFormContext(); // retrieve all hook methods\n *   return <input {...register(\"test\")} />;\n * }\n * ```\n */ const useFormContext = ()=>react__WEBPACK_IMPORTED_MODULE_0__.useContext(HookFormContext);\n/**\n * A provider component that propagates the `useForm` methods to all children components via [React Context](https://reactjs.org/docs/context.html) API. To be used with {@link useFormContext}.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/useformcontext) • [Demo](https://codesandbox.io/s/react-hook-form-v7-form-context-ytudi)\n *\n * @param props - all useForm methods\n *\n * @example\n * ```tsx\n * function App() {\n *   const methods = useForm();\n *   const onSubmit = data => console.log(data);\n *\n *   return (\n *     <FormProvider {...methods} >\n *       <form onSubmit={methods.handleSubmit(onSubmit)}>\n *         <NestedInput />\n *         <input type=\"submit\" />\n *       </form>\n *     </FormProvider>\n *   );\n * }\n *\n *  function NestedInput() {\n *   const { register } = useFormContext(); // retrieve all hook methods\n *   return <input {...register(\"test\")} />;\n * }\n * ```\n */ const FormProvider = (props)=>{\n    const { children, ...data } = props;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(HookFormContext.Provider, {\n        value: data\n    }, children);\n};\nvar getProxyFormState = (formState, control, localProxyFormState, isRoot = true)=>{\n    const result = {\n        defaultValues: control._defaultValues\n    };\n    for(const key in formState){\n        Object.defineProperty(result, key, {\n            get: ()=>{\n                const _key = key;\n                if (control._proxyFormState[_key] !== VALIDATION_MODE.all) {\n                    control._proxyFormState[_key] = !isRoot || VALIDATION_MODE.all;\n                }\n                localProxyFormState && (localProxyFormState[_key] = true);\n                return formState[_key];\n            }\n        });\n    }\n    return result;\n};\nconst useIsomorphicLayoutEffect =  false ? 0 : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\n/**\n * This custom hook allows you to subscribe to each form state, and isolate the re-render at the custom hook level. It has its scope in terms of form state subscription, so it would not affect other useFormState and useForm. Using this hook can reduce the re-render impact on large and complex form application.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/useformstate) • [Demo](https://codesandbox.io/s/useformstate-75xly)\n *\n * @param props - include options on specify fields to subscribe. {@link UseFormStateReturn}\n *\n * @example\n * ```tsx\n * function App() {\n *   const { register, handleSubmit, control } = useForm({\n *     defaultValues: {\n *     firstName: \"firstName\"\n *   }});\n *   const { dirtyFields } = useFormState({\n *     control\n *   });\n *   const onSubmit = (data) => console.log(data);\n *\n *   return (\n *     <form onSubmit={handleSubmit(onSubmit)}>\n *       <input {...register(\"firstName\")} placeholder=\"First Name\" />\n *       {dirtyFields.firstName && <p>Field is dirty.</p>}\n *       <input type=\"submit\" />\n *     </form>\n *   );\n * }\n * ```\n */ function useFormState(props) {\n    const methods = useFormContext();\n    const { control = methods.control, disabled, name, exact } = props || {};\n    const [formState, updateFormState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(control._formState);\n    const _localProxyFormState = react__WEBPACK_IMPORTED_MODULE_0__.useRef({\n        isDirty: false,\n        isLoading: false,\n        dirtyFields: false,\n        touchedFields: false,\n        validatingFields: false,\n        isValidating: false,\n        isValid: false,\n        errors: false\n    });\n    useIsomorphicLayoutEffect(()=>control._subscribe({\n            name,\n            formState: _localProxyFormState.current,\n            exact,\n            callback: (formState)=>{\n                !disabled && updateFormState({\n                    ...control._formState,\n                    ...formState\n                });\n            }\n        }), [\n        name,\n        disabled,\n        exact\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        _localProxyFormState.current.isValid && control._setValid(true);\n    }, [\n        control\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>getProxyFormState(formState, control, _localProxyFormState.current, false), [\n        formState,\n        control\n    ]);\n}\nvar isString = (value1)=>typeof value1 === \"string\";\nvar generateWatchOutput = (names, _names, formValues, isGlobal, defaultValue)=>{\n    if (isString(names)) {\n        isGlobal && _names.watch.add(names);\n        return get(formValues, names, defaultValue);\n    }\n    if (Array.isArray(names)) {\n        return names.map((fieldName)=>(isGlobal && _names.watch.add(fieldName), get(formValues, fieldName)));\n    }\n    isGlobal && (_names.watchAll = true);\n    return formValues;\n};\nvar isPrimitive = (value1)=>isNullOrUndefined(value1) || !isObjectType(value1);\nfunction deepEqual(object1, object2, _internal_visited = new WeakSet()) {\n    if (isPrimitive(object1) || isPrimitive(object2)) {\n        return object1 === object2;\n    }\n    if (isDateObject(object1) && isDateObject(object2)) {\n        return object1.getTime() === object2.getTime();\n    }\n    const keys1 = Object.keys(object1);\n    const keys2 = Object.keys(object2);\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n    if (_internal_visited.has(object1) || _internal_visited.has(object2)) {\n        return true;\n    }\n    _internal_visited.add(object1);\n    _internal_visited.add(object2);\n    for (const key of keys1){\n        const val1 = object1[key];\n        if (!keys2.includes(key)) {\n            return false;\n        }\n        if (key !== \"ref\") {\n            const val2 = object2[key];\n            if (isDateObject(val1) && isDateObject(val2) || isObject(val1) && isObject(val2) || Array.isArray(val1) && Array.isArray(val2) ? !deepEqual(val1, val2, _internal_visited) : val1 !== val2) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n/**\n * Custom hook to subscribe to field change and isolate re-rendering at the component level.\n *\n * @remarks\n *\n * [API](https://react-hook-form.com/docs/usewatch) • [Demo](https://codesandbox.io/s/react-hook-form-v7-ts-usewatch-h9i5e)\n *\n * @example\n * ```tsx\n * const { control } = useForm();\n * const values = useWatch({\n *   name: \"fieldName\"\n *   control,\n * })\n * ```\n */ function useWatch(props) {\n    const methods = useFormContext();\n    const { control = methods.control, name, defaultValue, disabled, exact, compute } = props || {};\n    const _defaultValue = react__WEBPACK_IMPORTED_MODULE_0__.useRef(defaultValue);\n    const _compute = react__WEBPACK_IMPORTED_MODULE_0__.useRef(compute);\n    const _computeFormValues = react__WEBPACK_IMPORTED_MODULE_0__.useRef(undefined);\n    _compute.current = compute;\n    const defaultValueMemo = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>control._getWatch(name, _defaultValue.current), [\n        control,\n        name\n    ]);\n    const [value1, updateValue] = react__WEBPACK_IMPORTED_MODULE_0__.useState(_compute.current ? _compute.current(defaultValueMemo) : defaultValueMemo);\n    useIsomorphicLayoutEffect(()=>control._subscribe({\n            name,\n            formState: {\n                values: true\n            },\n            exact,\n            callback: (formState)=>{\n                if (!disabled) {\n                    const formValues = generateWatchOutput(name, control._names, formState.values || control._formValues, false, _defaultValue.current);\n                    if (_compute.current) {\n                        const computedFormValues = _compute.current(formValues);\n                        if (!deepEqual(computedFormValues, _computeFormValues.current)) {\n                            updateValue(computedFormValues);\n                            _computeFormValues.current = computedFormValues;\n                        }\n                    } else {\n                        updateValue(formValues);\n                    }\n                }\n            }\n        }), [\n        control,\n        disabled,\n        name,\n        exact\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>control._removeUnmounted());\n    return value1;\n}\n/**\n * Custom hook to work with controlled component, this function provide you with both form and field level state. Re-render is isolated at the hook level.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/usecontroller) • [Demo](https://codesandbox.io/s/usecontroller-0o8px)\n *\n * @param props - the path name to the form field value, and validation rules.\n *\n * @returns field properties, field and form state. {@link UseControllerReturn}\n *\n * @example\n * ```tsx\n * function Input(props) {\n *   const { field, fieldState, formState } = useController(props);\n *   return (\n *     <div>\n *       <input {...field} placeholder={props.name} />\n *       <p>{fieldState.isTouched && \"Touched\"}</p>\n *       <p>{formState.isSubmitted ? \"submitted\" : \"\"}</p>\n *     </div>\n *   );\n * }\n * ```\n */ function useController(props) {\n    const methods = useFormContext();\n    const { name, disabled, control = methods.control, shouldUnregister, defaultValue } = props;\n    const isArrayField = isNameInFieldArray(control._names.array, name);\n    const defaultValueMemo = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>get(control._formValues, name, get(control._defaultValues, name, defaultValue)), [\n        control,\n        name,\n        defaultValue\n    ]);\n    const value1 = useWatch({\n        control,\n        name,\n        defaultValue: defaultValueMemo,\n        exact: true\n    });\n    const formState = useFormState({\n        control,\n        name,\n        exact: true\n    });\n    const _props = react__WEBPACK_IMPORTED_MODULE_0__.useRef(props);\n    const _previousNameRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(undefined);\n    const _registerProps = react__WEBPACK_IMPORTED_MODULE_0__.useRef(control.register(name, {\n        ...props.rules,\n        value: value1,\n        ...isBoolean(props.disabled) ? {\n            disabled: props.disabled\n        } : {}\n    }));\n    _props.current = props;\n    const fieldState = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>Object.defineProperties({}, {\n            invalid: {\n                enumerable: true,\n                get: ()=>!!get(formState.errors, name)\n            },\n            isDirty: {\n                enumerable: true,\n                get: ()=>!!get(formState.dirtyFields, name)\n            },\n            isTouched: {\n                enumerable: true,\n                get: ()=>!!get(formState.touchedFields, name)\n            },\n            isValidating: {\n                enumerable: true,\n                get: ()=>!!get(formState.validatingFields, name)\n            },\n            error: {\n                enumerable: true,\n                get: ()=>get(formState.errors, name)\n            }\n        }), [\n        formState,\n        name\n    ]);\n    const onChange = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((event)=>_registerProps.current.onChange({\n            target: {\n                value: getEventValue(event),\n                name: name\n            },\n            type: EVENTS.CHANGE\n        }), [\n        name\n    ]);\n    const onBlur = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>_registerProps.current.onBlur({\n            target: {\n                value: get(control._formValues, name),\n                name: name\n            },\n            type: EVENTS.BLUR\n        }), [\n        name,\n        control._formValues\n    ]);\n    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((elm)=>{\n        const field = get(control._fields, name);\n        if (field && elm) {\n            field._f.ref = {\n                focus: ()=>elm.focus && elm.focus(),\n                select: ()=>elm.select && elm.select(),\n                setCustomValidity: (message)=>elm.setCustomValidity(message),\n                reportValidity: ()=>elm.reportValidity()\n            };\n        }\n    }, [\n        control._fields,\n        name\n    ]);\n    const field = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            name,\n            value: value1,\n            ...isBoolean(disabled) || formState.disabled ? {\n                disabled: formState.disabled || disabled\n            } : {},\n            onChange,\n            onBlur,\n            ref\n        }), [\n        name,\n        disabled,\n        formState.disabled,\n        onChange,\n        onBlur,\n        ref,\n        value1\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        const _shouldUnregisterField = control._options.shouldUnregister || shouldUnregister;\n        const previousName = _previousNameRef.current;\n        if (previousName && previousName !== name && !isArrayField) {\n            control.unregister(previousName);\n        }\n        control.register(name, {\n            ..._props.current.rules,\n            ...isBoolean(_props.current.disabled) ? {\n                disabled: _props.current.disabled\n            } : {}\n        });\n        const updateMounted = (name, value1)=>{\n            const field = get(control._fields, name);\n            if (field && field._f) {\n                field._f.mount = value1;\n            }\n        };\n        updateMounted(name, true);\n        if (_shouldUnregisterField) {\n            const value1 = cloneObject(get(control._options.defaultValues, name));\n            set(control._defaultValues, name, value1);\n            if (isUndefined(get(control._formValues, name))) {\n                set(control._formValues, name, value1);\n            }\n        }\n        !isArrayField && control.register(name);\n        _previousNameRef.current = name;\n        return ()=>{\n            (isArrayField ? _shouldUnregisterField && !control._state.action : _shouldUnregisterField) ? control.unregister(name) : updateMounted(name, false);\n        };\n    }, [\n        name,\n        control,\n        isArrayField,\n        shouldUnregister\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        control._setDisabledField({\n            disabled,\n            name\n        });\n    }, [\n        disabled,\n        name,\n        control\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            field,\n            formState,\n            fieldState\n        }), [\n        field,\n        formState,\n        fieldState\n    ]);\n}\n/**\n * Component based on `useController` hook to work with controlled component.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/usecontroller/controller) • [Demo](https://codesandbox.io/s/react-hook-form-v6-controller-ts-jwyzw) • [Video](https://www.youtube.com/watch?v=N2UNk_UCVyA)\n *\n * @param props - the path name to the form field value, and validation rules.\n *\n * @returns provide field handler functions, field and form state.\n *\n * @example\n * ```tsx\n * function App() {\n *   const { control } = useForm<FormValues>({\n *     defaultValues: {\n *       test: \"\"\n *     }\n *   });\n *\n *   return (\n *     <form>\n *       <Controller\n *         control={control}\n *         name=\"test\"\n *         render={({ field: { onChange, onBlur, value, ref }, formState, fieldState }) => (\n *           <>\n *             <input\n *               onChange={onChange} // send value to hook form\n *               onBlur={onBlur} // notify when input is touched\n *               value={value} // return updated value\n *               ref={ref} // set ref for focus management\n *             />\n *             <p>{formState.isSubmitted ? \"submitted\" : \"\"}</p>\n *             <p>{fieldState.isTouched ? \"touched\" : \"\"}</p>\n *           </>\n *         )}\n *       />\n *     </form>\n *   );\n * }\n * ```\n */ const Controller = (props)=>props.render(useController(props));\nconst flatten = (obj)=>{\n    const output = {};\n    for (const key of Object.keys(obj)){\n        if (isObjectType(obj[key]) && obj[key] !== null) {\n            const nested = flatten(obj[key]);\n            for (const nestedKey of Object.keys(nested)){\n                output[`${key}.${nestedKey}`] = nested[nestedKey];\n            }\n        } else {\n            output[key] = obj[key];\n        }\n    }\n    return output;\n};\nconst POST_REQUEST = \"post\";\n/**\n * Form component to manage submission.\n *\n * @param props - to setup submission detail. {@link FormProps}\n *\n * @returns form component or headless render prop.\n *\n * @example\n * ```tsx\n * function App() {\n *   const { control, formState: { errors } } = useForm();\n *\n *   return (\n *     <Form action=\"/api\" control={control}>\n *       <input {...register(\"name\")} />\n *       <p>{errors?.root?.server && 'Server error'}</p>\n *       <button>Submit</button>\n *     </Form>\n *   );\n * }\n * ```\n */ function Form(props) {\n    const methods = useFormContext();\n    const [mounted, setMounted] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    const { control = methods.control, onSubmit, children, action, method = POST_REQUEST, headers, encType, onError, render, onSuccess, validateStatus, ...rest } = props;\n    const submit = async (event)=>{\n        let hasError = false;\n        let type = \"\";\n        await control.handleSubmit(async (data)=>{\n            const formData = new FormData();\n            let formDataJson = \"\";\n            try {\n                formDataJson = JSON.stringify(data);\n            } catch (_a) {}\n            const flattenFormValues = flatten(control._formValues);\n            for(const key in flattenFormValues){\n                formData.append(key, flattenFormValues[key]);\n            }\n            if (onSubmit) {\n                await onSubmit({\n                    data,\n                    event,\n                    method,\n                    formData,\n                    formDataJson\n                });\n            }\n            if (action) {\n                try {\n                    const shouldStringifySubmissionData = [\n                        headers && headers[\"Content-Type\"],\n                        encType\n                    ].some((value1)=>value1 && value1.includes(\"json\"));\n                    const response = await fetch(String(action), {\n                        method,\n                        headers: {\n                            ...headers,\n                            ...encType && encType !== \"multipart/form-data\" ? {\n                                \"Content-Type\": encType\n                            } : {}\n                        },\n                        body: shouldStringifySubmissionData ? formDataJson : formData\n                    });\n                    if (response && (validateStatus ? !validateStatus(response.status) : response.status < 200 || response.status >= 300)) {\n                        hasError = true;\n                        onError && onError({\n                            response\n                        });\n                        type = String(response.status);\n                    } else {\n                        onSuccess && onSuccess({\n                            response\n                        });\n                    }\n                } catch (error) {\n                    hasError = true;\n                    onError && onError({\n                        error\n                    });\n                }\n            }\n        })(event);\n        if (hasError && props.control) {\n            props.control._subjects.state.next({\n                isSubmitSuccessful: false\n            });\n            props.control.setError(\"root.server\", {\n                type\n            });\n        }\n    };\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        setMounted(true);\n    }, []);\n    return render ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, render({\n        submit\n    })) : /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"form\", {\n        noValidate: mounted,\n        action: action,\n        method: method,\n        encType: encType,\n        onSubmit: submit,\n        ...rest\n    }, children);\n}\nvar appendErrors = (name, validateAllFieldCriteria, errors, type, message)=>validateAllFieldCriteria ? {\n        ...errors[name],\n        types: {\n            ...errors[name] && errors[name].types ? errors[name].types : {},\n            [type]: message || true\n        }\n    } : {};\nvar convertToArrayPayload = (value1)=>Array.isArray(value1) ? value1 : [\n        value1\n    ];\nvar createSubject = ()=>{\n    let _observers = [];\n    const next = (value1)=>{\n        for (const observer of _observers){\n            observer.next && observer.next(value1);\n        }\n    };\n    const subscribe = (observer)=>{\n        _observers.push(observer);\n        return {\n            unsubscribe: ()=>{\n                _observers = _observers.filter((o)=>o !== observer);\n            }\n        };\n    };\n    const unsubscribe = ()=>{\n        _observers = [];\n    };\n    return {\n        get observers () {\n            return _observers;\n        },\n        next,\n        subscribe,\n        unsubscribe\n    };\n};\nfunction extractFormValues(fieldsState, formValues) {\n    const values = {};\n    for(const key in fieldsState){\n        if (fieldsState.hasOwnProperty(key)) {\n            const fieldState = fieldsState[key];\n            const fieldValue = formValues[key];\n            if (fieldState && isObject(fieldState) && fieldValue) {\n                const nestedFieldsState = extractFormValues(fieldState, fieldValue);\n                if (isObject(nestedFieldsState)) {\n                    values[key] = nestedFieldsState;\n                }\n            } else if (fieldsState[key]) {\n                values[key] = fieldValue;\n            }\n        }\n    }\n    return values;\n}\nvar isEmptyObject = (value1)=>isObject(value1) && !Object.keys(value1).length;\nvar isFileInput = (element)=>element.type === \"file\";\nvar isFunction = (value1)=>typeof value1 === \"function\";\nvar isHTMLElement = (value1)=>{\n    if (!isWeb) {\n        return false;\n    }\n    const owner = value1 ? value1.ownerDocument : 0;\n    return value1 instanceof (owner && owner.defaultView ? owner.defaultView.HTMLElement : HTMLElement);\n};\nvar isMultipleSelect = (element)=>element.type === `select-multiple`;\nvar isRadioInput = (element)=>element.type === \"radio\";\nvar isRadioOrCheckbox = (ref)=>isRadioInput(ref) || isCheckBoxInput(ref);\nvar live = (ref)=>isHTMLElement(ref) && ref.isConnected;\nfunction baseGet(object, updatePath) {\n    const length = updatePath.slice(0, -1).length;\n    let index = 0;\n    while(index < length){\n        object = isUndefined(object) ? index++ : object[updatePath[index++]];\n    }\n    return object;\n}\nfunction isEmptyArray(obj) {\n    for(const key in obj){\n        if (obj.hasOwnProperty(key) && !isUndefined(obj[key])) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction unset(object, path) {\n    const paths = Array.isArray(path) ? path : isKey(path) ? [\n        path\n    ] : stringToPath(path);\n    const childObject = paths.length === 1 ? object : baseGet(object, paths);\n    const index = paths.length - 1;\n    const key = paths[index];\n    if (childObject) {\n        delete childObject[key];\n    }\n    if (index !== 0 && (isObject(childObject) && isEmptyObject(childObject) || Array.isArray(childObject) && isEmptyArray(childObject))) {\n        unset(object, paths.slice(0, -1));\n    }\n    return object;\n}\nvar objectHasFunction = (data)=>{\n    for(const key in data){\n        if (isFunction(data[key])) {\n            return true;\n        }\n    }\n    return false;\n};\nfunction isTraversable(value1) {\n    return Array.isArray(value1) || isObject(value1) && !objectHasFunction(value1);\n}\nfunction markFieldsDirty(data, fields = {}) {\n    for(const key in data){\n        if (isTraversable(data[key])) {\n            fields[key] = Array.isArray(data[key]) ? [] : {};\n            markFieldsDirty(data[key], fields[key]);\n        } else if (!isNullOrUndefined(data[key])) {\n            fields[key] = true;\n        }\n    }\n    return fields;\n}\nfunction getDirtyFields(data, formValues, dirtyFieldsFromValues) {\n    if (!dirtyFieldsFromValues) {\n        dirtyFieldsFromValues = markFieldsDirty(formValues);\n    }\n    for(const key in data){\n        if (isTraversable(data[key])) {\n            if (isUndefined(formValues) || isPrimitive(dirtyFieldsFromValues[key])) {\n                dirtyFieldsFromValues[key] = markFieldsDirty(data[key], Array.isArray(data[key]) ? [] : {});\n            } else {\n                getDirtyFields(data[key], isNullOrUndefined(formValues) ? {} : formValues[key], dirtyFieldsFromValues[key]);\n            }\n        } else {\n            dirtyFieldsFromValues[key] = !deepEqual(data[key], formValues[key]);\n        }\n    }\n    return dirtyFieldsFromValues;\n}\nconst defaultResult = {\n    value: false,\n    isValid: false\n};\nconst validResult = {\n    value: true,\n    isValid: true\n};\nvar getCheckboxValue = (options)=>{\n    if (Array.isArray(options)) {\n        if (options.length > 1) {\n            const values = options.filter((option)=>option && option.checked && !option.disabled).map((option)=>option.value);\n            return {\n                value: values,\n                isValid: !!values.length\n            };\n        }\n        return options[0].checked && !options[0].disabled ? options[0].attributes && !isUndefined(options[0].attributes.value) ? isUndefined(options[0].value) || options[0].value === \"\" ? validResult : {\n            value: options[0].value,\n            isValid: true\n        } : validResult : defaultResult;\n    }\n    return defaultResult;\n};\nvar getFieldValueAs = (value1, { valueAsNumber, valueAsDate, setValueAs })=>isUndefined(value1) ? value1 : valueAsNumber ? value1 === \"\" ? NaN : value1 ? +value1 : value1 : valueAsDate && isString(value1) ? new Date(value1) : setValueAs ? setValueAs(value1) : value1;\nconst defaultReturn = {\n    isValid: false,\n    value: null\n};\nvar getRadioValue = (options)=>Array.isArray(options) ? options.reduce((previous, option)=>option && option.checked && !option.disabled ? {\n            isValid: true,\n            value: option.value\n        } : previous, defaultReturn) : defaultReturn;\nfunction getFieldValue(_f) {\n    const ref = _f.ref;\n    if (isFileInput(ref)) {\n        return ref.files;\n    }\n    if (isRadioInput(ref)) {\n        return getRadioValue(_f.refs).value;\n    }\n    if (isMultipleSelect(ref)) {\n        return [\n            ...ref.selectedOptions\n        ].map(({ value: value1 })=>value1);\n    }\n    if (isCheckBoxInput(ref)) {\n        return getCheckboxValue(_f.refs).value;\n    }\n    return getFieldValueAs(isUndefined(ref.value) ? _f.ref.value : ref.value, _f);\n}\nvar getResolverOptions = (fieldsNames, _fields, criteriaMode, shouldUseNativeValidation)=>{\n    const fields = {};\n    for (const name of fieldsNames){\n        const field = get(_fields, name);\n        field && set(fields, name, field._f);\n    }\n    return {\n        criteriaMode,\n        names: [\n            ...fieldsNames\n        ],\n        fields,\n        shouldUseNativeValidation\n    };\n};\nvar isRegex = (value1)=>value1 instanceof RegExp;\nvar getRuleValue = (rule)=>isUndefined(rule) ? rule : isRegex(rule) ? rule.source : isObject(rule) ? isRegex(rule.value) ? rule.value.source : rule.value : rule;\nvar getValidationModes = (mode)=>({\n        isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\n        isOnBlur: mode === VALIDATION_MODE.onBlur,\n        isOnChange: mode === VALIDATION_MODE.onChange,\n        isOnAll: mode === VALIDATION_MODE.all,\n        isOnTouch: mode === VALIDATION_MODE.onTouched\n    });\nconst ASYNC_FUNCTION = \"AsyncFunction\";\nvar hasPromiseValidation = (fieldReference)=>!!fieldReference && !!fieldReference.validate && !!(isFunction(fieldReference.validate) && fieldReference.validate.constructor.name === ASYNC_FUNCTION || isObject(fieldReference.validate) && Object.values(fieldReference.validate).find((validateFunction)=>validateFunction.constructor.name === ASYNC_FUNCTION));\nvar hasValidation = (options)=>options.mount && (options.required || options.min || options.max || options.maxLength || options.minLength || options.pattern || options.validate);\nvar isWatched = (name, _names, isBlurEvent)=>!isBlurEvent && (_names.watchAll || _names.watch.has(name) || [\n        ..._names.watch\n    ].some((watchName)=>name.startsWith(watchName) && /^\\.\\w+/.test(name.slice(watchName.length))));\nconst iterateFieldsByAction = (fields, action, fieldsNames, abortEarly)=>{\n    for (const key of fieldsNames || Object.keys(fields)){\n        const field = get(fields, key);\n        if (field) {\n            const { _f, ...currentField } = field;\n            if (_f) {\n                if (_f.refs && _f.refs[0] && action(_f.refs[0], key) && !abortEarly) {\n                    return true;\n                } else if (_f.ref && action(_f.ref, _f.name) && !abortEarly) {\n                    return true;\n                } else {\n                    if (iterateFieldsByAction(currentField, action)) {\n                        break;\n                    }\n                }\n            } else if (isObject(currentField)) {\n                if (iterateFieldsByAction(currentField, action)) {\n                    break;\n                }\n            }\n        }\n    }\n    return;\n};\nfunction schemaErrorLookup(errors, _fields, name) {\n    const error = get(errors, name);\n    if (error || isKey(name)) {\n        return {\n            error,\n            name\n        };\n    }\n    const names = name.split(\".\");\n    while(names.length){\n        const fieldName = names.join(\".\");\n        const field = get(_fields, fieldName);\n        const foundError = get(errors, fieldName);\n        if (field && !Array.isArray(field) && name !== fieldName) {\n            return {\n                name\n            };\n        }\n        if (foundError && foundError.type) {\n            return {\n                name: fieldName,\n                error: foundError\n            };\n        }\n        if (foundError && foundError.root && foundError.root.type) {\n            return {\n                name: `${fieldName}.root`,\n                error: foundError.root\n            };\n        }\n        names.pop();\n    }\n    return {\n        name\n    };\n}\nvar shouldRenderFormState = (formStateData, _proxyFormState, updateFormState, isRoot)=>{\n    updateFormState(formStateData);\n    const { name, ...formState } = formStateData;\n    return isEmptyObject(formState) || Object.keys(formState).length >= Object.keys(_proxyFormState).length || Object.keys(formState).find((key)=>_proxyFormState[key] === (!isRoot || VALIDATION_MODE.all));\n};\nvar shouldSubscribeByName = (name, signalName, exact)=>!name || !signalName || name === signalName || convertToArrayPayload(name).some((currentName)=>currentName && (exact ? currentName === signalName : currentName.startsWith(signalName) || signalName.startsWith(currentName)));\nvar skipValidation = (isBlurEvent, isTouched, isSubmitted, reValidateMode, mode)=>{\n    if (mode.isOnAll) {\n        return false;\n    } else if (!isSubmitted && mode.isOnTouch) {\n        return !(isTouched || isBlurEvent);\n    } else if (isSubmitted ? reValidateMode.isOnBlur : mode.isOnBlur) {\n        return !isBlurEvent;\n    } else if (isSubmitted ? reValidateMode.isOnChange : mode.isOnChange) {\n        return isBlurEvent;\n    }\n    return true;\n};\nvar unsetEmptyArray = (ref, name)=>!compact(get(ref, name)).length && unset(ref, name);\nvar updateFieldArrayRootError = (errors, error, name)=>{\n    const fieldArrayErrors = convertToArrayPayload(get(errors, name));\n    set(fieldArrayErrors, \"root\", error[name]);\n    set(errors, name, fieldArrayErrors);\n    return errors;\n};\nfunction getValidateError(result, ref, type = \"validate\") {\n    if (isString(result) || Array.isArray(result) && result.every(isString) || isBoolean(result) && !result) {\n        return {\n            type,\n            message: isString(result) ? result : \"\",\n            ref\n        };\n    }\n}\nvar getValueAndMessage = (validationData)=>isObject(validationData) && !isRegex(validationData) ? validationData : {\n        value: validationData,\n        message: \"\"\n    };\nvar validateField = async (field, disabledFieldNames, formValues, validateAllFieldCriteria, shouldUseNativeValidation, isFieldArray)=>{\n    const { ref, refs, required, maxLength, minLength, min, max, pattern, validate, name, valueAsNumber, mount } = field._f;\n    const inputValue = get(formValues, name);\n    if (!mount || disabledFieldNames.has(name)) {\n        return {};\n    }\n    const inputRef = refs ? refs[0] : ref;\n    const setCustomValidity = (message)=>{\n        if (shouldUseNativeValidation && inputRef.reportValidity) {\n            inputRef.setCustomValidity(isBoolean(message) ? \"\" : message || \"\");\n            inputRef.reportValidity();\n        }\n    };\n    const error = {};\n    const isRadio = isRadioInput(ref);\n    const isCheckBox = isCheckBoxInput(ref);\n    const isRadioOrCheckbox = isRadio || isCheckBox;\n    const isEmpty = (valueAsNumber || isFileInput(ref)) && isUndefined(ref.value) && isUndefined(inputValue) || isHTMLElement(ref) && ref.value === \"\" || inputValue === \"\" || Array.isArray(inputValue) && !inputValue.length;\n    const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\n    const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength)=>{\n        const message = exceedMax ? maxLengthMessage : minLengthMessage;\n        error[name] = {\n            type: exceedMax ? maxType : minType,\n            message,\n            ref,\n            ...appendErrorsCurry(exceedMax ? maxType : minType, message)\n        };\n    };\n    if (isFieldArray ? !Array.isArray(inputValue) || !inputValue.length : required && (!isRadioOrCheckbox && (isEmpty || isNullOrUndefined(inputValue)) || isBoolean(inputValue) && !inputValue || isCheckBox && !getCheckboxValue(refs).isValid || isRadio && !getRadioValue(refs).isValid)) {\n        const { value: value1, message } = isString(required) ? {\n            value: !!required,\n            message: required\n        } : getValueAndMessage(required);\n        if (value1) {\n            error[name] = {\n                type: INPUT_VALIDATION_RULES.required,\n                message,\n                ref: inputRef,\n                ...appendErrorsCurry(INPUT_VALIDATION_RULES.required, message)\n            };\n            if (!validateAllFieldCriteria) {\n                setCustomValidity(message);\n                return error;\n            }\n        }\n    }\n    if (!isEmpty && (!isNullOrUndefined(min) || !isNullOrUndefined(max))) {\n        let exceedMax;\n        let exceedMin;\n        const maxOutput = getValueAndMessage(max);\n        const minOutput = getValueAndMessage(min);\n        if (!isNullOrUndefined(inputValue) && !isNaN(inputValue)) {\n            const valueNumber = ref.valueAsNumber || (inputValue ? +inputValue : inputValue);\n            if (!isNullOrUndefined(maxOutput.value)) {\n                exceedMax = valueNumber > maxOutput.value;\n            }\n            if (!isNullOrUndefined(minOutput.value)) {\n                exceedMin = valueNumber < minOutput.value;\n            }\n        } else {\n            const valueDate = ref.valueAsDate || new Date(inputValue);\n            const convertTimeToDate = (time)=>new Date(new Date().toDateString() + \" \" + time);\n            const isTime = ref.type == \"time\";\n            const isWeek = ref.type == \"week\";\n            if (isString(maxOutput.value) && inputValue) {\n                exceedMax = isTime ? convertTimeToDate(inputValue) > convertTimeToDate(maxOutput.value) : isWeek ? inputValue > maxOutput.value : valueDate > new Date(maxOutput.value);\n            }\n            if (isString(minOutput.value) && inputValue) {\n                exceedMin = isTime ? convertTimeToDate(inputValue) < convertTimeToDate(minOutput.value) : isWeek ? inputValue < minOutput.value : valueDate < new Date(minOutput.value);\n            }\n        }\n        if (exceedMax || exceedMin) {\n            getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\n            if (!validateAllFieldCriteria) {\n                setCustomValidity(error[name].message);\n                return error;\n            }\n        }\n    }\n    if ((maxLength || minLength) && !isEmpty && (isString(inputValue) || isFieldArray && Array.isArray(inputValue))) {\n        const maxLengthOutput = getValueAndMessage(maxLength);\n        const minLengthOutput = getValueAndMessage(minLength);\n        const exceedMax = !isNullOrUndefined(maxLengthOutput.value) && inputValue.length > +maxLengthOutput.value;\n        const exceedMin = !isNullOrUndefined(minLengthOutput.value) && inputValue.length < +minLengthOutput.value;\n        if (exceedMax || exceedMin) {\n            getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);\n            if (!validateAllFieldCriteria) {\n                setCustomValidity(error[name].message);\n                return error;\n            }\n        }\n    }\n    if (pattern && !isEmpty && isString(inputValue)) {\n        const { value: patternValue, message } = getValueAndMessage(pattern);\n        if (isRegex(patternValue) && !inputValue.match(patternValue)) {\n            error[name] = {\n                type: INPUT_VALIDATION_RULES.pattern,\n                message,\n                ref,\n                ...appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message)\n            };\n            if (!validateAllFieldCriteria) {\n                setCustomValidity(message);\n                return error;\n            }\n        }\n    }\n    if (validate) {\n        if (isFunction(validate)) {\n            const result = await validate(inputValue, formValues);\n            const validateError = getValidateError(result, inputRef);\n            if (validateError) {\n                error[name] = {\n                    ...validateError,\n                    ...appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message)\n                };\n                if (!validateAllFieldCriteria) {\n                    setCustomValidity(validateError.message);\n                    return error;\n                }\n            }\n        } else if (isObject(validate)) {\n            let validationResult = {};\n            for(const key in validate){\n                if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\n                    break;\n                }\n                const validateError = getValidateError(await validate[key](inputValue, formValues), inputRef, key);\n                if (validateError) {\n                    validationResult = {\n                        ...validateError,\n                        ...appendErrorsCurry(key, validateError.message)\n                    };\n                    setCustomValidity(validateError.message);\n                    if (validateAllFieldCriteria) {\n                        error[name] = validationResult;\n                    }\n                }\n            }\n            if (!isEmptyObject(validationResult)) {\n                error[name] = {\n                    ref: inputRef,\n                    ...validationResult\n                };\n                if (!validateAllFieldCriteria) {\n                    return error;\n                }\n            }\n        }\n    }\n    setCustomValidity(true);\n    return error;\n};\nconst defaultOptions = {\n    mode: VALIDATION_MODE.onSubmit,\n    reValidateMode: VALIDATION_MODE.onChange,\n    shouldFocusError: true\n};\nfunction createFormControl(props = {}) {\n    let _options = {\n        ...defaultOptions,\n        ...props\n    };\n    let _formState = {\n        submitCount: 0,\n        isDirty: false,\n        isReady: false,\n        isLoading: isFunction(_options.defaultValues),\n        isValidating: false,\n        isSubmitted: false,\n        isSubmitting: false,\n        isSubmitSuccessful: false,\n        isValid: false,\n        touchedFields: {},\n        dirtyFields: {},\n        validatingFields: {},\n        errors: _options.errors || {},\n        disabled: _options.disabled || false\n    };\n    let _fields = {};\n    let _defaultValues = isObject(_options.defaultValues) || isObject(_options.values) ? cloneObject(_options.defaultValues || _options.values) || {} : {};\n    let _formValues = _options.shouldUnregister ? {} : cloneObject(_defaultValues);\n    let _state = {\n        action: false,\n        mount: false,\n        watch: false\n    };\n    let _names = {\n        mount: new Set(),\n        disabled: new Set(),\n        unMount: new Set(),\n        array: new Set(),\n        watch: new Set()\n    };\n    let delayErrorCallback;\n    let timer = 0;\n    const _proxyFormState = {\n        isDirty: false,\n        dirtyFields: false,\n        validatingFields: false,\n        touchedFields: false,\n        isValidating: false,\n        isValid: false,\n        errors: false\n    };\n    let _proxySubscribeFormState = {\n        ..._proxyFormState\n    };\n    const _subjects = {\n        array: createSubject(),\n        state: createSubject()\n    };\n    const shouldDisplayAllAssociatedErrors = _options.criteriaMode === VALIDATION_MODE.all;\n    const debounce = (callback)=>(wait)=>{\n            clearTimeout(timer);\n            timer = setTimeout(callback, wait);\n        };\n    const _setValid = async (shouldUpdateValid)=>{\n        if (!_options.disabled && (_proxyFormState.isValid || _proxySubscribeFormState.isValid || shouldUpdateValid)) {\n            const isValid = _options.resolver ? isEmptyObject((await _runSchema()).errors) : await executeBuiltInValidation(_fields, true);\n            if (isValid !== _formState.isValid) {\n                _subjects.state.next({\n                    isValid\n                });\n            }\n        }\n    };\n    const _updateIsValidating = (names, isValidating)=>{\n        if (!_options.disabled && (_proxyFormState.isValidating || _proxyFormState.validatingFields || _proxySubscribeFormState.isValidating || _proxySubscribeFormState.validatingFields)) {\n            (names || Array.from(_names.mount)).forEach((name)=>{\n                if (name) {\n                    isValidating ? set(_formState.validatingFields, name, isValidating) : unset(_formState.validatingFields, name);\n                }\n            });\n            _subjects.state.next({\n                validatingFields: _formState.validatingFields,\n                isValidating: !isEmptyObject(_formState.validatingFields)\n            });\n        }\n    };\n    const _setFieldArray = (name, values = [], method, args, shouldSetValues = true, shouldUpdateFieldsAndState = true)=>{\n        if (args && method && !_options.disabled) {\n            _state.action = true;\n            if (shouldUpdateFieldsAndState && Array.isArray(get(_fields, name))) {\n                const fieldValues = method(get(_fields, name), args.argA, args.argB);\n                shouldSetValues && set(_fields, name, fieldValues);\n            }\n            if (shouldUpdateFieldsAndState && Array.isArray(get(_formState.errors, name))) {\n                const errors = method(get(_formState.errors, name), args.argA, args.argB);\n                shouldSetValues && set(_formState.errors, name, errors);\n                unsetEmptyArray(_formState.errors, name);\n            }\n            if ((_proxyFormState.touchedFields || _proxySubscribeFormState.touchedFields) && shouldUpdateFieldsAndState && Array.isArray(get(_formState.touchedFields, name))) {\n                const touchedFields = method(get(_formState.touchedFields, name), args.argA, args.argB);\n                shouldSetValues && set(_formState.touchedFields, name, touchedFields);\n            }\n            if (_proxyFormState.dirtyFields || _proxySubscribeFormState.dirtyFields) {\n                _formState.dirtyFields = getDirtyFields(_defaultValues, _formValues);\n            }\n            _subjects.state.next({\n                name,\n                isDirty: _getDirty(name, values),\n                dirtyFields: _formState.dirtyFields,\n                errors: _formState.errors,\n                isValid: _formState.isValid\n            });\n        } else {\n            set(_formValues, name, values);\n        }\n    };\n    const updateErrors = (name, error)=>{\n        set(_formState.errors, name, error);\n        _subjects.state.next({\n            errors: _formState.errors\n        });\n    };\n    const _setErrors = (errors)=>{\n        _formState.errors = errors;\n        _subjects.state.next({\n            errors: _formState.errors,\n            isValid: false\n        });\n    };\n    const updateValidAndValue = (name, shouldSkipSetValueAs, value1, ref)=>{\n        const field = get(_fields, name);\n        if (field) {\n            const defaultValue = get(_formValues, name, isUndefined(value1) ? get(_defaultValues, name) : value1);\n            isUndefined(defaultValue) || ref && ref.defaultChecked || shouldSkipSetValueAs ? set(_formValues, name, shouldSkipSetValueAs ? defaultValue : getFieldValue(field._f)) : setFieldValue(name, defaultValue);\n            _state.mount && _setValid();\n        }\n    };\n    const updateTouchAndDirty = (name, fieldValue, isBlurEvent, shouldDirty, shouldRender)=>{\n        let shouldUpdateField = false;\n        let isPreviousDirty = false;\n        const output = {\n            name\n        };\n        if (!_options.disabled) {\n            if (!isBlurEvent || shouldDirty) {\n                if (_proxyFormState.isDirty || _proxySubscribeFormState.isDirty) {\n                    isPreviousDirty = _formState.isDirty;\n                    _formState.isDirty = output.isDirty = _getDirty();\n                    shouldUpdateField = isPreviousDirty !== output.isDirty;\n                }\n                const isCurrentFieldPristine = deepEqual(get(_defaultValues, name), fieldValue);\n                isPreviousDirty = !!get(_formState.dirtyFields, name);\n                isCurrentFieldPristine ? unset(_formState.dirtyFields, name) : set(_formState.dirtyFields, name, true);\n                output.dirtyFields = _formState.dirtyFields;\n                shouldUpdateField = shouldUpdateField || (_proxyFormState.dirtyFields || _proxySubscribeFormState.dirtyFields) && isPreviousDirty !== !isCurrentFieldPristine;\n            }\n            if (isBlurEvent) {\n                const isPreviousFieldTouched = get(_formState.touchedFields, name);\n                if (!isPreviousFieldTouched) {\n                    set(_formState.touchedFields, name, isBlurEvent);\n                    output.touchedFields = _formState.touchedFields;\n                    shouldUpdateField = shouldUpdateField || (_proxyFormState.touchedFields || _proxySubscribeFormState.touchedFields) && isPreviousFieldTouched !== isBlurEvent;\n                }\n            }\n            shouldUpdateField && shouldRender && _subjects.state.next(output);\n        }\n        return shouldUpdateField ? output : {};\n    };\n    const shouldRenderByError = (name, isValid, error, fieldState)=>{\n        const previousFieldError = get(_formState.errors, name);\n        const shouldUpdateValid = (_proxyFormState.isValid || _proxySubscribeFormState.isValid) && isBoolean(isValid) && _formState.isValid !== isValid;\n        if (_options.delayError && error) {\n            delayErrorCallback = debounce(()=>updateErrors(name, error));\n            delayErrorCallback(_options.delayError);\n        } else {\n            clearTimeout(timer);\n            delayErrorCallback = null;\n            error ? set(_formState.errors, name, error) : unset(_formState.errors, name);\n        }\n        if ((error ? !deepEqual(previousFieldError, error) : previousFieldError) || !isEmptyObject(fieldState) || shouldUpdateValid) {\n            const updatedFormState = {\n                ...fieldState,\n                ...shouldUpdateValid && isBoolean(isValid) ? {\n                    isValid\n                } : {},\n                errors: _formState.errors,\n                name\n            };\n            _formState = {\n                ..._formState,\n                ...updatedFormState\n            };\n            _subjects.state.next(updatedFormState);\n        }\n    };\n    const _runSchema = async (name)=>{\n        _updateIsValidating(name, true);\n        const result = await _options.resolver(_formValues, _options.context, getResolverOptions(name || _names.mount, _fields, _options.criteriaMode, _options.shouldUseNativeValidation));\n        _updateIsValidating(name);\n        return result;\n    };\n    const executeSchemaAndUpdateState = async (names)=>{\n        const { errors } = await _runSchema(names);\n        if (names) {\n            for (const name of names){\n                const error = get(errors, name);\n                error ? set(_formState.errors, name, error) : unset(_formState.errors, name);\n            }\n        } else {\n            _formState.errors = errors;\n        }\n        return errors;\n    };\n    const executeBuiltInValidation = async (fields, shouldOnlyCheckValid, context = {\n        valid: true\n    })=>{\n        for(const name in fields){\n            const field = fields[name];\n            if (field) {\n                const { _f, ...fieldValue } = field;\n                if (_f) {\n                    const isFieldArrayRoot = _names.array.has(_f.name);\n                    const isPromiseFunction = field._f && hasPromiseValidation(field._f);\n                    if (isPromiseFunction && _proxyFormState.validatingFields) {\n                        _updateIsValidating([\n                            _f.name\n                        ], true);\n                    }\n                    const fieldError = await validateField(field, _names.disabled, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation && !shouldOnlyCheckValid, isFieldArrayRoot);\n                    if (isPromiseFunction && _proxyFormState.validatingFields) {\n                        _updateIsValidating([\n                            _f.name\n                        ]);\n                    }\n                    if (fieldError[_f.name]) {\n                        context.valid = false;\n                        if (shouldOnlyCheckValid) {\n                            break;\n                        }\n                    }\n                    !shouldOnlyCheckValid && (get(fieldError, _f.name) ? isFieldArrayRoot ? updateFieldArrayRootError(_formState.errors, fieldError, _f.name) : set(_formState.errors, _f.name, fieldError[_f.name]) : unset(_formState.errors, _f.name));\n                }\n                !isEmptyObject(fieldValue) && await executeBuiltInValidation(fieldValue, shouldOnlyCheckValid, context);\n            }\n        }\n        return context.valid;\n    };\n    const _removeUnmounted = ()=>{\n        for (const name of _names.unMount){\n            const field = get(_fields, name);\n            field && (field._f.refs ? field._f.refs.every((ref)=>!live(ref)) : !live(field._f.ref)) && unregister(name);\n        }\n        _names.unMount = new Set();\n    };\n    const _getDirty = (name, data)=>!_options.disabled && (name && data && set(_formValues, name, data), !deepEqual(getValues(), _defaultValues));\n    const _getWatch = (names, defaultValue, isGlobal)=>generateWatchOutput(names, _names, {\n            ..._state.mount ? _formValues : isUndefined(defaultValue) ? _defaultValues : isString(names) ? {\n                [names]: defaultValue\n            } : defaultValue\n        }, isGlobal, defaultValue);\n    const _getFieldArray = (name)=>compact(get(_state.mount ? _formValues : _defaultValues, name, _options.shouldUnregister ? get(_defaultValues, name, []) : []));\n    const setFieldValue = (name, value1, options = {})=>{\n        const field = get(_fields, name);\n        let fieldValue = value1;\n        if (field) {\n            const fieldReference = field._f;\n            if (fieldReference) {\n                !fieldReference.disabled && set(_formValues, name, getFieldValueAs(value1, fieldReference));\n                fieldValue = isHTMLElement(fieldReference.ref) && isNullOrUndefined(value1) ? \"\" : value1;\n                if (isMultipleSelect(fieldReference.ref)) {\n                    [\n                        ...fieldReference.ref.options\n                    ].forEach((optionRef)=>optionRef.selected = fieldValue.includes(optionRef.value));\n                } else if (fieldReference.refs) {\n                    if (isCheckBoxInput(fieldReference.ref)) {\n                        fieldReference.refs.forEach((checkboxRef)=>{\n                            if (!checkboxRef.defaultChecked || !checkboxRef.disabled) {\n                                if (Array.isArray(fieldValue)) {\n                                    checkboxRef.checked = !!fieldValue.find((data)=>data === checkboxRef.value);\n                                } else {\n                                    checkboxRef.checked = fieldValue === checkboxRef.value || !!fieldValue;\n                                }\n                            }\n                        });\n                    } else {\n                        fieldReference.refs.forEach((radioRef)=>radioRef.checked = radioRef.value === fieldValue);\n                    }\n                } else if (isFileInput(fieldReference.ref)) {\n                    fieldReference.ref.value = \"\";\n                } else {\n                    fieldReference.ref.value = fieldValue;\n                    if (!fieldReference.ref.type) {\n                        _subjects.state.next({\n                            name,\n                            values: cloneObject(_formValues)\n                        });\n                    }\n                }\n            }\n        }\n        (options.shouldDirty || options.shouldTouch) && updateTouchAndDirty(name, fieldValue, options.shouldTouch, options.shouldDirty, true);\n        options.shouldValidate && trigger(name);\n    };\n    const setValues = (name, value1, options)=>{\n        for(const fieldKey in value1){\n            if (!value1.hasOwnProperty(fieldKey)) {\n                return;\n            }\n            const fieldValue = value1[fieldKey];\n            const fieldName = name + \".\" + fieldKey;\n            const field = get(_fields, fieldName);\n            (_names.array.has(name) || isObject(fieldValue) || field && !field._f) && !isDateObject(fieldValue) ? setValues(fieldName, fieldValue, options) : setFieldValue(fieldName, fieldValue, options);\n        }\n    };\n    const setValue = (name, value1, options = {})=>{\n        const field = get(_fields, name);\n        const isFieldArray = _names.array.has(name);\n        const cloneValue = cloneObject(value1);\n        set(_formValues, name, cloneValue);\n        if (isFieldArray) {\n            _subjects.array.next({\n                name,\n                values: cloneObject(_formValues)\n            });\n            if ((_proxyFormState.isDirty || _proxyFormState.dirtyFields || _proxySubscribeFormState.isDirty || _proxySubscribeFormState.dirtyFields) && options.shouldDirty) {\n                _subjects.state.next({\n                    name,\n                    dirtyFields: getDirtyFields(_defaultValues, _formValues),\n                    isDirty: _getDirty(name, cloneValue)\n                });\n            }\n        } else {\n            field && !field._f && !isNullOrUndefined(cloneValue) ? setValues(name, cloneValue, options) : setFieldValue(name, cloneValue, options);\n        }\n        isWatched(name, _names) && _subjects.state.next({\n            ..._formState,\n            name\n        });\n        _subjects.state.next({\n            name: _state.mount ? name : undefined,\n            values: cloneObject(_formValues)\n        });\n    };\n    const onChange = async (event)=>{\n        _state.mount = true;\n        const target = event.target;\n        let name = target.name;\n        let isFieldValueUpdated = true;\n        const field = get(_fields, name);\n        const _updateIsFieldValueUpdated = (fieldValue)=>{\n            isFieldValueUpdated = Number.isNaN(fieldValue) || isDateObject(fieldValue) && isNaN(fieldValue.getTime()) || deepEqual(fieldValue, get(_formValues, name, fieldValue));\n        };\n        const validationModeBeforeSubmit = getValidationModes(_options.mode);\n        const validationModeAfterSubmit = getValidationModes(_options.reValidateMode);\n        if (field) {\n            let error;\n            let isValid;\n            const fieldValue = target.type ? getFieldValue(field._f) : getEventValue(event);\n            const isBlurEvent = event.type === EVENTS.BLUR || event.type === EVENTS.FOCUS_OUT;\n            const shouldSkipValidation = !hasValidation(field._f) && !_options.resolver && !get(_formState.errors, name) && !field._f.deps || skipValidation(isBlurEvent, get(_formState.touchedFields, name), _formState.isSubmitted, validationModeAfterSubmit, validationModeBeforeSubmit);\n            const watched = isWatched(name, _names, isBlurEvent);\n            set(_formValues, name, fieldValue);\n            if (isBlurEvent) {\n                if (!target || !target.readOnly) {\n                    field._f.onBlur && field._f.onBlur(event);\n                    delayErrorCallback && delayErrorCallback(0);\n                }\n            } else if (field._f.onChange) {\n                field._f.onChange(event);\n            }\n            const fieldState = updateTouchAndDirty(name, fieldValue, isBlurEvent);\n            const shouldRender = !isEmptyObject(fieldState) || watched;\n            !isBlurEvent && _subjects.state.next({\n                name,\n                type: event.type,\n                values: cloneObject(_formValues)\n            });\n            if (shouldSkipValidation) {\n                if (_proxyFormState.isValid || _proxySubscribeFormState.isValid) {\n                    if (_options.mode === \"onBlur\") {\n                        if (isBlurEvent) {\n                            _setValid();\n                        }\n                    } else if (!isBlurEvent) {\n                        _setValid();\n                    }\n                }\n                return shouldRender && _subjects.state.next({\n                    name,\n                    ...watched ? {} : fieldState\n                });\n            }\n            !isBlurEvent && watched && _subjects.state.next({\n                ..._formState\n            });\n            if (_options.resolver) {\n                const { errors } = await _runSchema([\n                    name\n                ]);\n                _updateIsFieldValueUpdated(fieldValue);\n                if (isFieldValueUpdated) {\n                    const previousErrorLookupResult = schemaErrorLookup(_formState.errors, _fields, name);\n                    const errorLookupResult = schemaErrorLookup(errors, _fields, previousErrorLookupResult.name || name);\n                    error = errorLookupResult.error;\n                    name = errorLookupResult.name;\n                    isValid = isEmptyObject(errors);\n                }\n            } else {\n                _updateIsValidating([\n                    name\n                ], true);\n                error = (await validateField(field, _names.disabled, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation))[name];\n                _updateIsValidating([\n                    name\n                ]);\n                _updateIsFieldValueUpdated(fieldValue);\n                if (isFieldValueUpdated) {\n                    if (error) {\n                        isValid = false;\n                    } else if (_proxyFormState.isValid || _proxySubscribeFormState.isValid) {\n                        isValid = await executeBuiltInValidation(_fields, true);\n                    }\n                }\n            }\n            if (isFieldValueUpdated) {\n                field._f.deps && (!Array.isArray(field._f.deps) || field._f.deps.length > 0) && trigger(field._f.deps);\n                shouldRenderByError(name, isValid, error, fieldState);\n            }\n        }\n    };\n    const _focusInput = (ref, key)=>{\n        if (get(_formState.errors, key) && ref.focus) {\n            ref.focus();\n            return 1;\n        }\n        return;\n    };\n    const trigger = async (name, options = {})=>{\n        let isValid;\n        let validationResult;\n        const fieldNames = convertToArrayPayload(name);\n        if (_options.resolver) {\n            const errors = await executeSchemaAndUpdateState(isUndefined(name) ? name : fieldNames);\n            isValid = isEmptyObject(errors);\n            validationResult = name ? !fieldNames.some((name)=>get(errors, name)) : isValid;\n        } else if (name) {\n            validationResult = (await Promise.all(fieldNames.map(async (fieldName)=>{\n                const field = get(_fields, fieldName);\n                return await executeBuiltInValidation(field && field._f ? {\n                    [fieldName]: field\n                } : field);\n            }))).every(Boolean);\n            !(!validationResult && !_formState.isValid) && _setValid();\n        } else {\n            validationResult = isValid = await executeBuiltInValidation(_fields);\n        }\n        _subjects.state.next({\n            ...!isString(name) || (_proxyFormState.isValid || _proxySubscribeFormState.isValid) && isValid !== _formState.isValid ? {} : {\n                name\n            },\n            ..._options.resolver || !name ? {\n                isValid\n            } : {},\n            errors: _formState.errors\n        });\n        options.shouldFocus && !validationResult && iterateFieldsByAction(_fields, _focusInput, name ? fieldNames : _names.mount);\n        return validationResult;\n    };\n    const getValues = (fieldNames, config)=>{\n        let values = {\n            ..._state.mount ? _formValues : _defaultValues\n        };\n        if (config) {\n            values = extractFormValues(config.dirtyFields ? _formState.dirtyFields : _formState.touchedFields, values);\n        }\n        return isUndefined(fieldNames) ? values : isString(fieldNames) ? get(values, fieldNames) : fieldNames.map((name)=>get(values, name));\n    };\n    const getFieldState = (name, formState)=>({\n            invalid: !!get((formState || _formState).errors, name),\n            isDirty: !!get((formState || _formState).dirtyFields, name),\n            error: get((formState || _formState).errors, name),\n            isValidating: !!get(_formState.validatingFields, name),\n            isTouched: !!get((formState || _formState).touchedFields, name)\n        });\n    const clearErrors = (name)=>{\n        name && convertToArrayPayload(name).forEach((inputName)=>unset(_formState.errors, inputName));\n        _subjects.state.next({\n            errors: name ? _formState.errors : {}\n        });\n    };\n    const setError = (name, error, options)=>{\n        const ref = (get(_fields, name, {\n            _f: {}\n        })._f || {}).ref;\n        const currentError = get(_formState.errors, name) || {};\n        // Don't override existing error messages elsewhere in the object tree.\n        const { ref: currentRef, message, type, ...restOfErrorTree } = currentError;\n        set(_formState.errors, name, {\n            ...restOfErrorTree,\n            ...error,\n            ref\n        });\n        _subjects.state.next({\n            name,\n            errors: _formState.errors,\n            isValid: false\n        });\n        options && options.shouldFocus && ref && ref.focus && ref.focus();\n    };\n    const watch = (name, defaultValue)=>isFunction(name) ? _subjects.state.subscribe({\n            next: (payload)=>\"values\" in payload && name(_getWatch(undefined, defaultValue), payload)\n        }) : _getWatch(name, defaultValue, true);\n    const _subscribe = (props)=>_subjects.state.subscribe({\n            next: (formState)=>{\n                if (shouldSubscribeByName(props.name, formState.name, props.exact) && shouldRenderFormState(formState, props.formState || _proxyFormState, _setFormState, props.reRenderRoot)) {\n                    props.callback({\n                        values: {\n                            ..._formValues\n                        },\n                        ..._formState,\n                        ...formState,\n                        defaultValues: _defaultValues\n                    });\n                }\n            }\n        }).unsubscribe;\n    const subscribe = (props)=>{\n        _state.mount = true;\n        _proxySubscribeFormState = {\n            ..._proxySubscribeFormState,\n            ...props.formState\n        };\n        return _subscribe({\n            ...props,\n            formState: _proxySubscribeFormState\n        });\n    };\n    const unregister = (name, options = {})=>{\n        for (const fieldName of name ? convertToArrayPayload(name) : _names.mount){\n            _names.mount.delete(fieldName);\n            _names.array.delete(fieldName);\n            if (!options.keepValue) {\n                unset(_fields, fieldName);\n                unset(_formValues, fieldName);\n            }\n            !options.keepError && unset(_formState.errors, fieldName);\n            !options.keepDirty && unset(_formState.dirtyFields, fieldName);\n            !options.keepTouched && unset(_formState.touchedFields, fieldName);\n            !options.keepIsValidating && unset(_formState.validatingFields, fieldName);\n            !_options.shouldUnregister && !options.keepDefaultValue && unset(_defaultValues, fieldName);\n        }\n        _subjects.state.next({\n            values: cloneObject(_formValues)\n        });\n        _subjects.state.next({\n            ..._formState,\n            ...!options.keepDirty ? {} : {\n                isDirty: _getDirty()\n            }\n        });\n        !options.keepIsValid && _setValid();\n    };\n    const _setDisabledField = ({ disabled, name })=>{\n        if (isBoolean(disabled) && _state.mount || !!disabled || _names.disabled.has(name)) {\n            disabled ? _names.disabled.add(name) : _names.disabled.delete(name);\n        }\n    };\n    const register = (name, options = {})=>{\n        let field = get(_fields, name);\n        const disabledIsDefined = isBoolean(options.disabled) || isBoolean(_options.disabled);\n        set(_fields, name, {\n            ...field || {},\n            _f: {\n                ...field && field._f ? field._f : {\n                    ref: {\n                        name\n                    }\n                },\n                name,\n                mount: true,\n                ...options\n            }\n        });\n        _names.mount.add(name);\n        if (field) {\n            _setDisabledField({\n                disabled: isBoolean(options.disabled) ? options.disabled : _options.disabled,\n                name\n            });\n        } else {\n            updateValidAndValue(name, true, options.value);\n        }\n        return {\n            ...disabledIsDefined ? {\n                disabled: options.disabled || _options.disabled\n            } : {},\n            ..._options.progressive ? {\n                required: !!options.required,\n                min: getRuleValue(options.min),\n                max: getRuleValue(options.max),\n                minLength: getRuleValue(options.minLength),\n                maxLength: getRuleValue(options.maxLength),\n                pattern: getRuleValue(options.pattern)\n            } : {},\n            name,\n            onChange,\n            onBlur: onChange,\n            ref: (ref)=>{\n                if (ref) {\n                    register(name, options);\n                    field = get(_fields, name);\n                    const fieldRef = isUndefined(ref.value) ? ref.querySelectorAll ? ref.querySelectorAll(\"input,select,textarea\")[0] || ref : ref : ref;\n                    const radioOrCheckbox = isRadioOrCheckbox(fieldRef);\n                    const refs = field._f.refs || [];\n                    if (radioOrCheckbox ? refs.find((option)=>option === fieldRef) : fieldRef === field._f.ref) {\n                        return;\n                    }\n                    set(_fields, name, {\n                        _f: {\n                            ...field._f,\n                            ...radioOrCheckbox ? {\n                                refs: [\n                                    ...refs.filter(live),\n                                    fieldRef,\n                                    ...Array.isArray(get(_defaultValues, name)) ? [\n                                        {}\n                                    ] : []\n                                ],\n                                ref: {\n                                    type: fieldRef.type,\n                                    name\n                                }\n                            } : {\n                                ref: fieldRef\n                            }\n                        }\n                    });\n                    updateValidAndValue(name, false, undefined, fieldRef);\n                } else {\n                    field = get(_fields, name, {});\n                    if (field._f) {\n                        field._f.mount = false;\n                    }\n                    (_options.shouldUnregister || options.shouldUnregister) && !(isNameInFieldArray(_names.array, name) && _state.action) && _names.unMount.add(name);\n                }\n            }\n        };\n    };\n    const _focusError = ()=>_options.shouldFocusError && iterateFieldsByAction(_fields, _focusInput, _names.mount);\n    const _disableForm = (disabled)=>{\n        if (isBoolean(disabled)) {\n            _subjects.state.next({\n                disabled\n            });\n            iterateFieldsByAction(_fields, (ref, name)=>{\n                const currentField = get(_fields, name);\n                if (currentField) {\n                    ref.disabled = currentField._f.disabled || disabled;\n                    if (Array.isArray(currentField._f.refs)) {\n                        currentField._f.refs.forEach((inputRef)=>{\n                            inputRef.disabled = currentField._f.disabled || disabled;\n                        });\n                    }\n                }\n            }, 0, false);\n        }\n    };\n    const handleSubmit = (onValid, onInvalid)=>async (e)=>{\n            let onValidError = undefined;\n            if (e) {\n                e.preventDefault && e.preventDefault();\n                e.persist && e.persist();\n            }\n            let fieldValues = cloneObject(_formValues);\n            _subjects.state.next({\n                isSubmitting: true\n            });\n            if (_options.resolver) {\n                const { errors, values } = await _runSchema();\n                _formState.errors = errors;\n                fieldValues = cloneObject(values);\n            } else {\n                await executeBuiltInValidation(_fields);\n            }\n            if (_names.disabled.size) {\n                for (const name of _names.disabled){\n                    unset(fieldValues, name);\n                }\n            }\n            unset(_formState.errors, \"root\");\n            if (isEmptyObject(_formState.errors)) {\n                _subjects.state.next({\n                    errors: {}\n                });\n                try {\n                    await onValid(fieldValues, e);\n                } catch (error) {\n                    onValidError = error;\n                }\n            } else {\n                if (onInvalid) {\n                    await onInvalid({\n                        ..._formState.errors\n                    }, e);\n                }\n                _focusError();\n                setTimeout(_focusError);\n            }\n            _subjects.state.next({\n                isSubmitted: true,\n                isSubmitting: false,\n                isSubmitSuccessful: isEmptyObject(_formState.errors) && !onValidError,\n                submitCount: _formState.submitCount + 1,\n                errors: _formState.errors\n            });\n            if (onValidError) {\n                throw onValidError;\n            }\n        };\n    const resetField = (name, options = {})=>{\n        if (get(_fields, name)) {\n            if (isUndefined(options.defaultValue)) {\n                setValue(name, cloneObject(get(_defaultValues, name)));\n            } else {\n                setValue(name, options.defaultValue);\n                set(_defaultValues, name, cloneObject(options.defaultValue));\n            }\n            if (!options.keepTouched) {\n                unset(_formState.touchedFields, name);\n            }\n            if (!options.keepDirty) {\n                unset(_formState.dirtyFields, name);\n                _formState.isDirty = options.defaultValue ? _getDirty(name, cloneObject(get(_defaultValues, name))) : _getDirty();\n            }\n            if (!options.keepError) {\n                unset(_formState.errors, name);\n                _proxyFormState.isValid && _setValid();\n            }\n            _subjects.state.next({\n                ..._formState\n            });\n        }\n    };\n    const _reset = (formValues, keepStateOptions = {})=>{\n        const updatedValues = formValues ? cloneObject(formValues) : _defaultValues;\n        const cloneUpdatedValues = cloneObject(updatedValues);\n        const isEmptyResetValues = isEmptyObject(formValues);\n        const values = isEmptyResetValues ? _defaultValues : cloneUpdatedValues;\n        if (!keepStateOptions.keepDefaultValues) {\n            _defaultValues = updatedValues;\n        }\n        if (!keepStateOptions.keepValues) {\n            if (keepStateOptions.keepDirtyValues) {\n                const fieldsToCheck = new Set([\n                    ..._names.mount,\n                    ...Object.keys(getDirtyFields(_defaultValues, _formValues))\n                ]);\n                for (const fieldName of Array.from(fieldsToCheck)){\n                    get(_formState.dirtyFields, fieldName) ? set(values, fieldName, get(_formValues, fieldName)) : setValue(fieldName, get(values, fieldName));\n                }\n            } else {\n                if (isWeb && isUndefined(formValues)) {\n                    for (const name of _names.mount){\n                        const field = get(_fields, name);\n                        if (field && field._f) {\n                            const fieldReference = Array.isArray(field._f.refs) ? field._f.refs[0] : field._f.ref;\n                            if (isHTMLElement(fieldReference)) {\n                                const form = fieldReference.closest(\"form\");\n                                if (form) {\n                                    form.reset();\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n                if (keepStateOptions.keepFieldsRef) {\n                    for (const fieldName of _names.mount){\n                        setValue(fieldName, get(values, fieldName));\n                    }\n                } else {\n                    _fields = {};\n                }\n            }\n            _formValues = _options.shouldUnregister ? keepStateOptions.keepDefaultValues ? cloneObject(_defaultValues) : {} : cloneObject(values);\n            _subjects.array.next({\n                values: {\n                    ...values\n                }\n            });\n            _subjects.state.next({\n                values: {\n                    ...values\n                }\n            });\n        }\n        _names = {\n            mount: keepStateOptions.keepDirtyValues ? _names.mount : new Set(),\n            unMount: new Set(),\n            array: new Set(),\n            disabled: new Set(),\n            watch: new Set(),\n            watchAll: false,\n            focus: \"\"\n        };\n        _state.mount = !_proxyFormState.isValid || !!keepStateOptions.keepIsValid || !!keepStateOptions.keepDirtyValues;\n        _state.watch = !!_options.shouldUnregister;\n        _subjects.state.next({\n            submitCount: keepStateOptions.keepSubmitCount ? _formState.submitCount : 0,\n            isDirty: isEmptyResetValues ? false : keepStateOptions.keepDirty ? _formState.isDirty : !!(keepStateOptions.keepDefaultValues && !deepEqual(formValues, _defaultValues)),\n            isSubmitted: keepStateOptions.keepIsSubmitted ? _formState.isSubmitted : false,\n            dirtyFields: isEmptyResetValues ? {} : keepStateOptions.keepDirtyValues ? keepStateOptions.keepDefaultValues && _formValues ? getDirtyFields(_defaultValues, _formValues) : _formState.dirtyFields : keepStateOptions.keepDefaultValues && formValues ? getDirtyFields(_defaultValues, formValues) : keepStateOptions.keepDirty ? _formState.dirtyFields : {},\n            touchedFields: keepStateOptions.keepTouched ? _formState.touchedFields : {},\n            errors: keepStateOptions.keepErrors ? _formState.errors : {},\n            isSubmitSuccessful: keepStateOptions.keepIsSubmitSuccessful ? _formState.isSubmitSuccessful : false,\n            isSubmitting: false,\n            defaultValues: _defaultValues\n        });\n    };\n    const reset = (formValues, keepStateOptions)=>_reset(isFunction(formValues) ? formValues(_formValues) : formValues, keepStateOptions);\n    const setFocus = (name, options = {})=>{\n        const field = get(_fields, name);\n        const fieldReference = field && field._f;\n        if (fieldReference) {\n            const fieldRef = fieldReference.refs ? fieldReference.refs[0] : fieldReference.ref;\n            if (fieldRef.focus) {\n                fieldRef.focus();\n                options.shouldSelect && isFunction(fieldRef.select) && fieldRef.select();\n            }\n        }\n    };\n    const _setFormState = (updatedFormState)=>{\n        _formState = {\n            ..._formState,\n            ...updatedFormState\n        };\n    };\n    const _resetDefaultValues = ()=>isFunction(_options.defaultValues) && _options.defaultValues().then((values)=>{\n            reset(values, _options.resetOptions);\n            _subjects.state.next({\n                isLoading: false\n            });\n        });\n    const methods = {\n        control: {\n            register,\n            unregister,\n            getFieldState,\n            handleSubmit,\n            setError,\n            _subscribe,\n            _runSchema,\n            _focusError,\n            _getWatch,\n            _getDirty,\n            _setValid,\n            _setFieldArray,\n            _setDisabledField,\n            _setErrors,\n            _getFieldArray,\n            _reset,\n            _resetDefaultValues,\n            _removeUnmounted,\n            _disableForm,\n            _subjects,\n            _proxyFormState,\n            get _fields () {\n                return _fields;\n            },\n            get _formValues () {\n                return _formValues;\n            },\n            get _state () {\n                return _state;\n            },\n            set _state (value){\n                _state = value;\n            },\n            get _defaultValues () {\n                return _defaultValues;\n            },\n            get _names () {\n                return _names;\n            },\n            set _names (value){\n                _names = value;\n            },\n            get _formState () {\n                return _formState;\n            },\n            get _options () {\n                return _options;\n            },\n            set _options (value){\n                _options = {\n                    ..._options,\n                    ...value\n                };\n            }\n        },\n        subscribe,\n        trigger,\n        register,\n        handleSubmit,\n        watch,\n        setValue,\n        getValues,\n        reset,\n        resetField,\n        clearErrors,\n        unregister,\n        setError,\n        setFocus,\n        getFieldState\n    };\n    return {\n        ...methods,\n        formControl: methods\n    };\n}\nvar generateId = ()=>{\n    if (typeof crypto !== \"undefined\" && crypto.randomUUID) {\n        return crypto.randomUUID();\n    }\n    const d = typeof performance === \"undefined\" ? Date.now() : performance.now() * 1000;\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c)=>{\n        const r = (Math.random() * 16 + d) % 16 | 0;\n        return (c == \"x\" ? r : r & 0x3 | 0x8).toString(16);\n    });\n};\nvar getFocusFieldName = (name, index, options = {})=>options.shouldFocus || isUndefined(options.shouldFocus) ? options.focusName || `${name}.${isUndefined(options.focusIndex) ? index : options.focusIndex}.` : \"\";\nvar appendAt = (data, value1)=>[\n        ...data,\n        ...convertToArrayPayload(value1)\n    ];\nvar fillEmptyArray = (value1)=>Array.isArray(value1) ? value1.map(()=>undefined) : undefined;\nfunction insert(data, index, value1) {\n    return [\n        ...data.slice(0, index),\n        ...convertToArrayPayload(value1),\n        ...data.slice(index)\n    ];\n}\nvar moveArrayAt = (data, from, to)=>{\n    if (!Array.isArray(data)) {\n        return [];\n    }\n    if (isUndefined(data[to])) {\n        data[to] = undefined;\n    }\n    data.splice(to, 0, data.splice(from, 1)[0]);\n    return data;\n};\nvar prependAt = (data, value1)=>[\n        ...convertToArrayPayload(value1),\n        ...convertToArrayPayload(data)\n    ];\nfunction removeAtIndexes(data, indexes) {\n    let i = 0;\n    const temp = [\n        ...data\n    ];\n    for (const index of indexes){\n        temp.splice(index - i, 1);\n        i++;\n    }\n    return compact(temp).length ? temp : [];\n}\nvar removeArrayAt = (data, index)=>isUndefined(index) ? [] : removeAtIndexes(data, convertToArrayPayload(index).sort((a, b)=>a - b));\nvar swapArrayAt = (data, indexA, indexB)=>{\n    [data[indexA], data[indexB]] = [\n        data[indexB],\n        data[indexA]\n    ];\n};\nvar updateAt = (fieldValues, index, value1)=>{\n    fieldValues[index] = value1;\n    return fieldValues;\n};\n/**\n * A custom hook that exposes convenient methods to perform operations with a list of dynamic inputs that need to be appended, updated, removed etc. • [Demo](https://codesandbox.io/s/react-hook-form-usefieldarray-ssugn) • [Video](https://youtu.be/4MrbfGSFY2A)\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/usefieldarray) • [Demo](https://codesandbox.io/s/react-hook-form-usefieldarray-ssugn)\n *\n * @param props - useFieldArray props\n *\n * @returns methods - functions to manipulate with the Field Arrays (dynamic inputs) {@link UseFieldArrayReturn}\n *\n * @example\n * ```tsx\n * function App() {\n *   const { register, control, handleSubmit, reset, trigger, setError } = useForm({\n *     defaultValues: {\n *       test: []\n *     }\n *   });\n *   const { fields, append } = useFieldArray({\n *     control,\n *     name: \"test\"\n *   });\n *\n *   return (\n *     <form onSubmit={handleSubmit(data => console.log(data))}>\n *       {fields.map((item, index) => (\n *          <input key={item.id} {...register(`test.${index}.firstName`)}  />\n *       ))}\n *       <button type=\"button\" onClick={() => append({ firstName: \"bill\" })}>\n *         append\n *       </button>\n *       <input type=\"submit\" />\n *     </form>\n *   );\n * }\n * ```\n */ function useFieldArray(props) {\n    const methods = useFormContext();\n    const { control = methods.control, name, keyName = \"id\", shouldUnregister, rules } = props;\n    const [fields, setFields] = react__WEBPACK_IMPORTED_MODULE_0__.useState(control._getFieldArray(name));\n    const ids = react__WEBPACK_IMPORTED_MODULE_0__.useRef(control._getFieldArray(name).map(generateId));\n    const _fieldIds = react__WEBPACK_IMPORTED_MODULE_0__.useRef(fields);\n    const _actioned = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    _fieldIds.current = fields;\n    control._names.array.add(name);\n    react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>rules && control.register(name, rules), [\n        control,\n        rules,\n        name\n    ]);\n    useIsomorphicLayoutEffect(()=>control._subjects.array.subscribe({\n            next: ({ values, name: fieldArrayName })=>{\n                if (fieldArrayName === name || !fieldArrayName) {\n                    const fieldValues = get(values, name);\n                    if (Array.isArray(fieldValues)) {\n                        setFields(fieldValues);\n                        ids.current = fieldValues.map(generateId);\n                    }\n                }\n            }\n        }).unsubscribe, [\n        control,\n        name\n    ]);\n    const updateValues = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((updatedFieldArrayValues)=>{\n        _actioned.current = true;\n        control._setFieldArray(name, updatedFieldArrayValues);\n    }, [\n        control,\n        name\n    ]);\n    const append = (value1, options)=>{\n        const appendValue = convertToArrayPayload(cloneObject(value1));\n        const updatedFieldArrayValues = appendAt(control._getFieldArray(name), appendValue);\n        control._names.focus = getFocusFieldName(name, updatedFieldArrayValues.length - 1, options);\n        ids.current = appendAt(ids.current, appendValue.map(generateId));\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        control._setFieldArray(name, updatedFieldArrayValues, appendAt, {\n            argA: fillEmptyArray(value1)\n        });\n    };\n    const prepend = (value1, options)=>{\n        const prependValue = convertToArrayPayload(cloneObject(value1));\n        const updatedFieldArrayValues = prependAt(control._getFieldArray(name), prependValue);\n        control._names.focus = getFocusFieldName(name, 0, options);\n        ids.current = prependAt(ids.current, prependValue.map(generateId));\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        control._setFieldArray(name, updatedFieldArrayValues, prependAt, {\n            argA: fillEmptyArray(value1)\n        });\n    };\n    const remove = (index)=>{\n        const updatedFieldArrayValues = removeArrayAt(control._getFieldArray(name), index);\n        ids.current = removeArrayAt(ids.current, index);\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        !Array.isArray(get(control._fields, name)) && set(control._fields, name, undefined);\n        control._setFieldArray(name, updatedFieldArrayValues, removeArrayAt, {\n            argA: index\n        });\n    };\n    const insert$1 = (index, value1, options)=>{\n        const insertValue = convertToArrayPayload(cloneObject(value1));\n        const updatedFieldArrayValues = insert(control._getFieldArray(name), index, insertValue);\n        control._names.focus = getFocusFieldName(name, index, options);\n        ids.current = insert(ids.current, index, insertValue.map(generateId));\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        control._setFieldArray(name, updatedFieldArrayValues, insert, {\n            argA: index,\n            argB: fillEmptyArray(value1)\n        });\n    };\n    const swap = (indexA, indexB)=>{\n        const updatedFieldArrayValues = control._getFieldArray(name);\n        swapArrayAt(updatedFieldArrayValues, indexA, indexB);\n        swapArrayAt(ids.current, indexA, indexB);\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        control._setFieldArray(name, updatedFieldArrayValues, swapArrayAt, {\n            argA: indexA,\n            argB: indexB\n        }, false);\n    };\n    const move = (from, to)=>{\n        const updatedFieldArrayValues = control._getFieldArray(name);\n        moveArrayAt(updatedFieldArrayValues, from, to);\n        moveArrayAt(ids.current, from, to);\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        control._setFieldArray(name, updatedFieldArrayValues, moveArrayAt, {\n            argA: from,\n            argB: to\n        }, false);\n    };\n    const update = (index, value1)=>{\n        const updateValue = cloneObject(value1);\n        const updatedFieldArrayValues = updateAt(control._getFieldArray(name), index, updateValue);\n        ids.current = [\n            ...updatedFieldArrayValues\n        ].map((item, i)=>!item || i === index ? generateId() : ids.current[i]);\n        updateValues(updatedFieldArrayValues);\n        setFields([\n            ...updatedFieldArrayValues\n        ]);\n        control._setFieldArray(name, updatedFieldArrayValues, updateAt, {\n            argA: index,\n            argB: updateValue\n        }, true, false);\n    };\n    const replace = (value1)=>{\n        const updatedFieldArrayValues = convertToArrayPayload(cloneObject(value1));\n        ids.current = updatedFieldArrayValues.map(generateId);\n        updateValues([\n            ...updatedFieldArrayValues\n        ]);\n        setFields([\n            ...updatedFieldArrayValues\n        ]);\n        control._setFieldArray(name, [\n            ...updatedFieldArrayValues\n        ], (data)=>data, {}, true, false);\n    };\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        control._state.action = false;\n        isWatched(name, control._names) && control._subjects.state.next({\n            ...control._formState\n        });\n        if (_actioned.current && (!getValidationModes(control._options.mode).isOnSubmit || control._formState.isSubmitted) && !getValidationModes(control._options.reValidateMode).isOnSubmit) {\n            if (control._options.resolver) {\n                control._runSchema([\n                    name\n                ]).then((result)=>{\n                    const error = get(result.errors, name);\n                    const existingError = get(control._formState.errors, name);\n                    if (existingError ? !error && existingError.type || error && (existingError.type !== error.type || existingError.message !== error.message) : error && error.type) {\n                        error ? set(control._formState.errors, name, error) : unset(control._formState.errors, name);\n                        control._subjects.state.next({\n                            errors: control._formState.errors\n                        });\n                    }\n                });\n            } else {\n                const field = get(control._fields, name);\n                if (field && field._f && !(getValidationModes(control._options.reValidateMode).isOnSubmit && getValidationModes(control._options.mode).isOnSubmit)) {\n                    validateField(field, control._names.disabled, control._formValues, control._options.criteriaMode === VALIDATION_MODE.all, control._options.shouldUseNativeValidation, true).then((error)=>!isEmptyObject(error) && control._subjects.state.next({\n                            errors: updateFieldArrayRootError(control._formState.errors, error, name)\n                        }));\n                }\n            }\n        }\n        control._subjects.state.next({\n            name,\n            values: cloneObject(control._formValues)\n        });\n        control._names.focus && iterateFieldsByAction(control._fields, (ref, key)=>{\n            if (control._names.focus && key.startsWith(control._names.focus) && ref.focus) {\n                ref.focus();\n                return 1;\n            }\n            return;\n        });\n        control._names.focus = \"\";\n        control._setValid();\n        _actioned.current = false;\n    }, [\n        fields,\n        name,\n        control\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        !get(control._formValues, name) && control._setFieldArray(name);\n        return ()=>{\n            const updateMounted = (name, value1)=>{\n                const field = get(control._fields, name);\n                if (field && field._f) {\n                    field._f.mount = value1;\n                }\n            };\n            control._options.shouldUnregister || shouldUnregister ? control.unregister(name) : updateMounted(name, false);\n        };\n    }, [\n        name,\n        control,\n        keyName,\n        shouldUnregister\n    ]);\n    return {\n        swap: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(swap, [\n            updateValues,\n            name,\n            control\n        ]),\n        move: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(move, [\n            updateValues,\n            name,\n            control\n        ]),\n        prepend: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(prepend, [\n            updateValues,\n            name,\n            control\n        ]),\n        append: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(append, [\n            updateValues,\n            name,\n            control\n        ]),\n        remove: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(remove, [\n            updateValues,\n            name,\n            control\n        ]),\n        insert: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(insert$1, [\n            updateValues,\n            name,\n            control\n        ]),\n        update: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(update, [\n            updateValues,\n            name,\n            control\n        ]),\n        replace: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(replace, [\n            updateValues,\n            name,\n            control\n        ]),\n        fields: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>fields.map((field, index)=>({\n                    ...field,\n                    [keyName]: ids.current[index] || generateId()\n                })), [\n            fields,\n            keyName\n        ])\n    };\n}\n/**\n * Custom hook to manage the entire form.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/useform) • [Demo](https://codesandbox.io/s/react-hook-form-get-started-ts-5ksmm) • [Video](https://www.youtube.com/watch?v=RkXv4AXXC_4)\n *\n * @param props - form configuration and validation parameters.\n *\n * @returns methods - individual functions to manage the form state. {@link UseFormReturn}\n *\n * @example\n * ```tsx\n * function App() {\n *   const { register, handleSubmit, watch, formState: { errors } } = useForm();\n *   const onSubmit = data => console.log(data);\n *\n *   console.log(watch(\"example\"));\n *\n *   return (\n *     <form onSubmit={handleSubmit(onSubmit)}>\n *       <input defaultValue=\"test\" {...register(\"example\")} />\n *       <input {...register(\"exampleRequired\", { required: true })} />\n *       {errors.exampleRequired && <span>This field is required</span>}\n *       <button>Submit</button>\n *     </form>\n *   );\n * }\n * ```\n */ function useForm(props = {}) {\n    const _formControl = react__WEBPACK_IMPORTED_MODULE_0__.useRef(undefined);\n    const _values = react__WEBPACK_IMPORTED_MODULE_0__.useRef(undefined);\n    const [formState, updateFormState] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        isDirty: false,\n        isValidating: false,\n        isLoading: isFunction(props.defaultValues),\n        isSubmitted: false,\n        isSubmitting: false,\n        isSubmitSuccessful: false,\n        isValid: false,\n        submitCount: 0,\n        dirtyFields: {},\n        touchedFields: {},\n        validatingFields: {},\n        errors: props.errors || {},\n        disabled: props.disabled || false,\n        isReady: false,\n        defaultValues: isFunction(props.defaultValues) ? undefined : props.defaultValues\n    });\n    if (!_formControl.current) {\n        if (props.formControl) {\n            _formControl.current = {\n                ...props.formControl,\n                formState\n            };\n            if (props.defaultValues && !isFunction(props.defaultValues)) {\n                props.formControl.reset(props.defaultValues, props.resetOptions);\n            }\n        } else {\n            const { formControl, ...rest } = createFormControl(props);\n            _formControl.current = {\n                ...rest,\n                formState\n            };\n        }\n    }\n    const control = _formControl.current.control;\n    control._options = props;\n    useIsomorphicLayoutEffect(()=>{\n        const sub = control._subscribe({\n            formState: control._proxyFormState,\n            callback: ()=>updateFormState({\n                    ...control._formState\n                }),\n            reRenderRoot: true\n        });\n        updateFormState((data)=>({\n                ...data,\n                isReady: true\n            }));\n        control._formState.isReady = true;\n        return sub;\n    }, [\n        control\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>control._disableForm(props.disabled), [\n        control,\n        props.disabled\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (props.mode) {\n            control._options.mode = props.mode;\n        }\n        if (props.reValidateMode) {\n            control._options.reValidateMode = props.reValidateMode;\n        }\n    }, [\n        control,\n        props.mode,\n        props.reValidateMode\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (props.errors) {\n            control._setErrors(props.errors);\n            control._focusError();\n        }\n    }, [\n        control,\n        props.errors\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        props.shouldUnregister && control._subjects.state.next({\n            values: control._getWatch()\n        });\n    }, [\n        control,\n        props.shouldUnregister\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (control._proxyFormState.isDirty) {\n            const isDirty = control._getDirty();\n            if (isDirty !== formState.isDirty) {\n                control._subjects.state.next({\n                    isDirty\n                });\n            }\n        }\n    }, [\n        control,\n        formState.isDirty\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (props.values && !deepEqual(props.values, _values.current)) {\n            control._reset(props.values, {\n                keepFieldsRef: true,\n                ...control._options.resetOptions\n            });\n            _values.current = props.values;\n            updateFormState((state)=>({\n                    ...state\n                }));\n        } else {\n            control._resetDefaultValues();\n        }\n    }, [\n        control,\n        props.values\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!control._state.mount) {\n            control._setValid();\n            control._state.mount = true;\n        }\n        if (control._state.watch) {\n            control._state.watch = false;\n            control._subjects.state.next({\n                ...control._formState\n            });\n        }\n        control._removeUnmounted();\n    });\n    _formControl.current.formState = getProxyFormState(formState, control);\n    return _formControl.current;\n}\n //# sourceMappingURL=index.esm.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtaG9vay1mb3JtL2Rpc3QvaW5kZXguZXNtLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUEwQjtBQUUxQixJQUFJQyxrQkFBa0IsQ0FBQ0MsVUFBWUEsUUFBUUMsSUFBSSxLQUFLO0FBRXBELElBQUlDLGVBQWUsQ0FBQ0MsU0FBVUEsa0JBQWlCQztBQUUvQyxJQUFJQyxvQkFBb0IsQ0FBQ0YsU0FBVUEsVUFBUztBQUU1QyxNQUFNRyxlQUFlLENBQUNILFNBQVUsT0FBT0EsV0FBVTtBQUNqRCxJQUFJSSxXQUFXLENBQUNKLFNBQVUsQ0FBQ0Usa0JBQWtCRixXQUN6QyxDQUFDSyxNQUFNQyxPQUFPLENBQUNOLFdBQ2ZHLGFBQWFILFdBQ2IsQ0FBQ0QsYUFBYUM7QUFFbEIsSUFBSU8sZ0JBQWdCLENBQUNDLFFBQVVKLFNBQVNJLFVBQVVBLE1BQU1DLE1BQU0sR0FDeERiLGdCQUFnQlksTUFBTUMsTUFBTSxJQUN4QkQsTUFBTUMsTUFBTSxDQUFDQyxPQUFPLEdBQ3BCRixNQUFNQyxNQUFNLENBQUNULEtBQUssR0FDdEJRO0FBRU4sSUFBSUcsb0JBQW9CLENBQUNDLE9BQVNBLEtBQUtDLFNBQVMsQ0FBQyxHQUFHRCxLQUFLRSxNQUFNLENBQUMsbUJBQW1CRjtBQUVuRixJQUFJRyxxQkFBcUIsQ0FBQ0MsT0FBT0osT0FBU0ksTUFBTUMsR0FBRyxDQUFDTixrQkFBa0JDO0FBRXRFLElBQUlNLGdCQUFnQixDQUFDQztJQUNqQixNQUFNQyxnQkFBZ0JELFdBQVdFLFdBQVcsSUFBSUYsV0FBV0UsV0FBVyxDQUFDQyxTQUFTO0lBQ2hGLE9BQVFsQixTQUFTZ0Isa0JBQWtCQSxjQUFjRyxjQUFjLENBQUM7QUFDcEU7QUFFQSxJQUFJQyxRQUFRLE1BQ3NCLElBQzlCLENBQW9CO0FBRXhCLFNBQVNJLFlBQVlDLElBQUk7SUFDckIsSUFBSUM7SUFDSixNQUFNeEIsVUFBVUQsTUFBTUMsT0FBTyxDQUFDdUI7SUFDOUIs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UUFDQSxJQUFJbkcsUUFBUW9HLE1BQU0sQ0FBQzlELEtBQUssRUFBRTtZQUN0QnRDLFFBQVFvRyxNQUFNLENBQUM5RCxLQUFLLEdBQUc7WUFDdkJ0QyxRQUFRMkksU0FBUyxDQUFDQyxLQUFLLENBQUNDLElBQUksQ0FBQztnQkFBRSxHQUFHN0ksUUFBUWlCLFVBQVU7WUFBQztRQUN6RDtRQUNBakIsUUFBUW1FLGdCQUFnQjtJQUM1QjtJQUNBNFosYUFBYWxjLE9BQU8sQ0FBQzlCLFNBQVMsR0FBR0Qsa0JBQWtCQyxXQUFXQztJQUM5RCxPQUFPK2QsYUFBYWxjLE9BQU87QUFDL0I7QUFFb0ssQ0FDcEssc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmwyc3FsLXVpLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWhvb2stZm9ybS9kaXN0L2luZGV4LmVzbS5tanM/OWRjMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG52YXIgaXNDaGVja0JveElucHV0ID0gKGVsZW1lbnQpID0+IGVsZW1lbnQudHlwZSA9PT0gJ2NoZWNrYm94JztcblxudmFyIGlzRGF0ZU9iamVjdCA9ICh2YWx1ZSkgPT4gdmFsdWUgaW5zdGFuY2VvZiBEYXRlO1xuXG52YXIgaXNOdWxsT3JVbmRlZmluZWQgPSAodmFsdWUpID0+IHZhbHVlID09IG51bGw7XG5cbmNvbnN0IGlzT2JqZWN0VHlwZSA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JztcbnZhciBpc09iamVjdCA9ICh2YWx1ZSkgPT4gIWlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKSAmJlxuICAgICFBcnJheS5pc0FycmF5KHZhbHVlKSAmJlxuICAgIGlzT2JqZWN0VHlwZSh2YWx1ZSkgJiZcbiAgICAhaXNEYXRlT2JqZWN0KHZhbHVlKTtcblxudmFyIGdldEV2ZW50VmFsdWUgPSAoZXZlbnQpID0+IGlzT2JqZWN0KGV2ZW50KSAmJiBldmVudC50YXJnZXRcbiAgICA/IGlzQ2hlY2tCb3hJbnB1dChldmVudC50YXJnZXQpXG4gICAgICAgID8gZXZlbnQudGFyZ2V0LmNoZWNrZWRcbiAgICAgICAgOiBldmVudC50YXJnZXQudmFsdWVcbiAgICA6IGV2ZW50O1xuXG52YXIgZ2V0Tm9kZVBhcmVudE5hbWUgPSAobmFtZSkgPT4gbmFtZS5zdWJzdHJpbmcoMCwgbmFtZS5zZWFyY2goL1xcLlxcZCsoXFwufCQpLykpIHx8IG5hbWU7XG5cbnZhciBpc05hbWVJbkZpZWxkQXJyYXkgPSAobmFtZXMsIG5hbWUpID0+IG5hbWVzLmhhcyhnZXROb2RlUGFyZW50TmFtZShuYW1lKSk7XG5cbnZhciBpc1BsYWluT2JqZWN0ID0gKHRlbXBPYmplY3QpID0+IHtcbiAgICBjb25zdCBwcm90b3R5cGVDb3B5ID0gdGVtcE9iamVjdC5jb25zdHJ1Y3RvciAmJiB0ZW1wT2JqZWN0LmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgICByZXR1cm4gKGlzT2JqZWN0KHByb3RvdHlwZUNvcHkpICYmIHByb3RvdHlwZUNvcHkuaGFzT3duUHJvcGVydHkoJ2lzUHJvdG90eXBlT2YnKSk7XG59O1xuXG52YXIgaXNXZWIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiB3aW5kb3cuSFRNTEVsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcblxuZnVuY3Rpb24gY2xvbmVPYmplY3QoZGF0YSkge1xuICAgIGxldCBjb3B5O1xuICAgIGNvbnN0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KGRhdGEpO1xuICAgIGNvbnN0IGlzRmlsZUxpc3RJbnN0YW5jZSA9IHR5cGVvZiBGaWxlTGlzdCAhPT0gJ3VuZGVmaW5lZCcgPyBkYXRhIGluc3RhbmNlb2YgRmlsZUxpc3QgOiBmYWxzZTtcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgY29weSA9IG5ldyBEYXRlKGRhdGEpO1xuICAgIH1cbiAgICBlbHNlIGlmICghKGlzV2ViICYmIChkYXRhIGluc3RhbmNlb2YgQmxvYiB8fCBpc0ZpbGVMaXN0SW5zdGFuY2UpKSAmJlxuICAgICAgICAoaXNBcnJheSB8fCBpc09iamVjdChkYXRhKSkpIHtcbiAgICAgICAgY29weSA9IGlzQXJyYXkgPyBbXSA6IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKGRhdGEpKTtcbiAgICAgICAgaWYgKCFpc0FycmF5ICYmICFpc1BsYWluT2JqZWN0KGRhdGEpKSB7XG4gICAgICAgICAgICBjb3B5ID0gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvcHlba2V5XSA9IGNsb25lT2JqZWN0KGRhdGFba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIGNvcHk7XG59XG5cbnZhciBpc0tleSA9ICh2YWx1ZSkgPT4gL15cXHcqJC8udGVzdCh2YWx1ZSk7XG5cbnZhciBpc1VuZGVmaW5lZCA9ICh2YWwpID0+IHZhbCA9PT0gdW5kZWZpbmVkO1xuXG52YXIgY29tcGFjdCA9ICh2YWx1ZSkgPT4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5maWx0ZXIoQm9vbGVhbikgOiBbXTtcblxudmFyIHN0cmluZ1RvUGF0aCA9IChpbnB1dCkgPT4gY29tcGFjdChpbnB1dC5yZXBsYWNlKC9bXCJ8J118XFxdL2csICcnKS5zcGxpdCgvXFwufFxcWy8pKTtcblxudmFyIGdldCA9IChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkgPT4ge1xuICAgIGlmICghcGF0aCB8fCAhaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSAoaXNLZXkocGF0aCkgPyBbcGF0aF0gOiBzdHJpbmdUb1BhdGgocGF0aCkpLnJlZHVjZSgocmVzdWx0LCBrZXkpID0+IGlzTnVsbE9yVW5kZWZpbmVkKHJlc3VsdCkgPyByZXN1bHQgOiByZXN1bHRba2V5XSwgb2JqZWN0KTtcbiAgICByZXR1cm4gaXNVbmRlZmluZWQocmVzdWx0KSB8fCByZXN1bHQgPT09IG9iamVjdFxuICAgICAgICA/IGlzVW5kZWZpbmVkKG9iamVjdFtwYXRoXSlcbiAgICAgICAgICAgID8gZGVmYXVsdFZhbHVlXG4gICAgICAgICAgICA6IG9iamVjdFtwYXRoXVxuICAgICAgICA6IHJlc3VsdDtcbn07XG5cbnZhciBpc0Jvb2xlYW4gPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nO1xuXG52YXIgc2V0ID0gKG9iamVjdCwgcGF0aCwgdmFsdWUpID0+IHtcbiAgICBsZXQgaW5kZXggPSAtMTtcbiAgICBjb25zdCB0ZW1wUGF0aCA9IGlzS2V5KHBhdGgpID8gW3BhdGhdIDogc3RyaW5nVG9QYXRoKHBhdGgpO1xuICAgIGNvbnN0IGxlbmd0aCA9IHRlbXBQYXRoLmxlbmd0aDtcbiAgICBjb25zdCBsYXN0SW5kZXggPSBsZW5ndGggLSAxO1xuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHRlbXBQYXRoW2luZGV4XTtcbiAgICAgICAgbGV0IG5ld1ZhbHVlID0gdmFsdWU7XG4gICAgICAgIGlmIChpbmRleCAhPT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgICBjb25zdCBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgICAgICAgbmV3VmFsdWUgPVxuICAgICAgICAgICAgICAgIGlzT2JqZWN0KG9ialZhbHVlKSB8fCBBcnJheS5pc0FycmF5KG9ialZhbHVlKVxuICAgICAgICAgICAgICAgICAgICA/IG9ialZhbHVlXG4gICAgICAgICAgICAgICAgICAgIDogIWlzTmFOKCt0ZW1wUGF0aFtpbmRleCArIDFdKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBbXVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5ID09PSAnX19wcm90b19fJyB8fCBrZXkgPT09ICdjb25zdHJ1Y3RvcicgfHwga2V5ID09PSAncHJvdG90eXBlJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdFtrZXldID0gbmV3VmFsdWU7XG4gICAgICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xuICAgIH1cbn07XG5cbmNvbnN0IEVWRU5UUyA9IHtcbiAgICBCTFVSOiAnYmx1cicsXG4gICAgRk9DVVNfT1VUOiAnZm9jdXNvdXQnLFxuICAgIENIQU5HRTogJ2NoYW5nZScsXG59O1xuY29uc3QgVkFMSURBVElPTl9NT0RFID0ge1xuICAgIG9uQmx1cjogJ29uQmx1cicsXG4gICAgb25DaGFuZ2U6ICdvbkNoYW5nZScsXG4gICAgb25TdWJtaXQ6ICdvblN1Ym1pdCcsXG4gICAgb25Ub3VjaGVkOiAnb25Ub3VjaGVkJyxcbiAgICBhbGw6ICdhbGwnLFxufTtcbmNvbnN0IElOUFVUX1ZBTElEQVRJT05fUlVMRVMgPSB7XG4gICAgbWF4OiAnbWF4JyxcbiAgICBtaW46ICdtaW4nLFxuICAgIG1heExlbmd0aDogJ21heExlbmd0aCcsXG4gICAgbWluTGVuZ3RoOiAnbWluTGVuZ3RoJyxcbiAgICBwYXR0ZXJuOiAncGF0dGVybicsXG4gICAgcmVxdWlyZWQ6ICdyZXF1aXJlZCcsXG4gICAgdmFsaWRhdGU6ICd2YWxpZGF0ZScsXG59O1xuXG5jb25zdCBIb29rRm9ybUNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuSG9va0Zvcm1Db250ZXh0LmRpc3BsYXlOYW1lID0gJ0hvb2tGb3JtQ29udGV4dCc7XG4vKipcbiAqIFRoaXMgY3VzdG9tIGhvb2sgYWxsb3dzIHlvdSB0byBhY2Nlc3MgdGhlIGZvcm0gY29udGV4dC4gdXNlRm9ybUNvbnRleHQgaXMgaW50ZW5kZWQgdG8gYmUgdXNlZCBpbiBkZWVwbHkgbmVzdGVkIHN0cnVjdHVyZXMsIHdoZXJlIGl0IHdvdWxkIGJlY29tZSBpbmNvbnZlbmllbnQgdG8gcGFzcyB0aGUgY29udGV4dCBhcyBhIHByb3AuIFRvIGJlIHVzZWQgd2l0aCB7QGxpbmsgRm9ybVByb3ZpZGVyfS5cbiAqXG4gKiBAcmVtYXJrc1xuICogW0FQSV0oaHR0cHM6Ly9yZWFjdC1ob29rLWZvcm0uY29tL2RvY3MvdXNlZm9ybWNvbnRleHQpIOKAoiBbRGVtb10oaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL3JlYWN0LWhvb2stZm9ybS12Ny1mb3JtLWNvbnRleHQteXR1ZGkpXG4gKlxuICogQHJldHVybnMgcmV0dXJuIGFsbCB1c2VGb3JtIG1ldGhvZHNcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKiBmdW5jdGlvbiBBcHAoKSB7XG4gKiAgIGNvbnN0IG1ldGhvZHMgPSB1c2VGb3JtKCk7XG4gKiAgIGNvbnN0IG9uU3VibWl0ID0gZGF0YSA9PiBjb25zb2xlLmxvZyhkYXRhKTtcbiAqXG4gKiAgIHJldHVybiAoXG4gKiAgICAgPEZvcm1Qcm92aWRlciB7Li4ubWV0aG9kc30gPlxuICogICAgICAgPGZvcm0gb25TdWJtaXQ9e21ldGhvZHMuaGFuZGxlU3VibWl0KG9uU3VibWl0KX0+XG4gKiAgICAgICAgIDxOZXN0ZWRJbnB1dCAvPlxuICogICAgICAgICA8aW5wdXQgdHlwZT1cInN1Ym1pdFwiIC8+XG4gKiAgICAgICA8L2Zvcm0+XG4gKiAgICAgPC9Gb3JtUHJvdmlkZXI+XG4gKiAgICk7XG4gKiB9XG4gKlxuICogIGZ1bmN0aW9uIE5lc3RlZElucHV0KCkge1xuICogICBjb25zdCB7IHJlZ2lzdGVyIH0gPSB1c2VGb3JtQ29udGV4dCgpOyAvLyByZXRyaWV2ZSBhbGwgaG9vayBtZXRob2RzXG4gKiAgIHJldHVybiA8aW5wdXQgey4uLnJlZ2lzdGVyKFwidGVzdFwiKX0gLz47XG4gKiB9XG4gKiBgYGBcbiAqL1xuY29uc3QgdXNlRm9ybUNvbnRleHQgPSAoKSA9PiBSZWFjdC51c2VDb250ZXh0KEhvb2tGb3JtQ29udGV4dCk7XG4vKipcbiAqIEEgcHJvdmlkZXIgY29tcG9uZW50IHRoYXQgcHJvcGFnYXRlcyB0aGUgYHVzZUZvcm1gIG1ldGhvZHMgdG8gYWxsIGNoaWxkcmVuIGNvbXBvbmVudHMgdmlhIFtSZWFjdCBDb250ZXh0XShodHRwczovL3JlYWN0anMub3JnL2RvY3MvY29udGV4dC5odG1sKSBBUEkuIFRvIGJlIHVzZWQgd2l0aCB7QGxpbmsgdXNlRm9ybUNvbnRleHR9LlxuICpcbiAqIEByZW1hcmtzXG4gKiBbQVBJXShodHRwczovL3JlYWN0LWhvb2stZm9ybS5jb20vZG9jcy91c2Vmb3JtY29udGV4dCkg4oCiIFtEZW1vXShodHRwczovL2NvZGVzYW5kYm94LmlvL3MvcmVhY3QtaG9vay1mb3JtLXY3LWZvcm0tY29udGV4dC15dHVkaSlcbiAqXG4gKiBAcGFyYW0gcHJvcHMgLSBhbGwgdXNlRm9ybSBtZXRob2RzXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogZnVuY3Rpb24gQXBwKCkge1xuICogICBjb25zdCBtZXRob2RzID0gdXNlRm9ybSgpO1xuICogICBjb25zdCBvblN1Ym1pdCA9IGRhdGEgPT4gY29uc29sZS5sb2coZGF0YSk7XG4gKlxuICogICByZXR1cm4gKFxuICogICAgIDxGb3JtUHJvdmlkZXIgey4uLm1ldGhvZHN9ID5cbiAqICAgICAgIDxmb3JtIG9uU3VibWl0PXttZXRob2RzLmhhbmRsZVN1Ym1pdChvblN1Ym1pdCl9PlxuICogICAgICAgICA8TmVzdGVkSW5wdXQgLz5cbiAqICAgICAgICAgPGlucHV0IHR5cGU9XCJzdWJtaXRcIiAvPlxuICogICAgICAgPC9mb3JtPlxuICogICAgIDwvRm9ybVByb3ZpZGVyPlxuICogICApO1xuICogfVxuICpcbiAqICBmdW5jdGlvbiBOZXN0ZWRJbnB1dCgpIHtcbiAqICAgY29uc3QgeyByZWdpc3RlciB9ID0gdXNlRm9ybUNvbnRleHQoKTsgLy8gcmV0cmlldmUgYWxsIGhvb2sgbWV0aG9kc1xuICogICByZXR1cm4gPGlucHV0IHsuLi5yZWdpc3RlcihcInRlc3RcIil9IC8+O1xuICogfVxuICogYGBgXG4gKi9cbmNvbnN0IEZvcm1Qcm92aWRlciA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgY2hpbGRyZW4sIC4uLmRhdGEgfSA9IHByb3BzO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChIb29rRm9ybUNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGRhdGEgfSwgY2hpbGRyZW4pKTtcbn07XG5cbnZhciBnZXRQcm94eUZvcm1TdGF0ZSA9IChmb3JtU3RhdGUsIGNvbnRyb2wsIGxvY2FsUHJveHlGb3JtU3RhdGUsIGlzUm9vdCA9IHRydWUpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZXM6IGNvbnRyb2wuX2RlZmF1bHRWYWx1ZXMsXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBmb3JtU3RhdGUpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3VsdCwga2V5LCB7XG4gICAgICAgICAgICBnZXQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBfa2V5ID0ga2V5O1xuICAgICAgICAgICAgICAgIGlmIChjb250cm9sLl9wcm94eUZvcm1TdGF0ZVtfa2V5XSAhPT0gVkFMSURBVElPTl9NT0RFLmFsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sLl9wcm94eUZvcm1TdGF0ZVtfa2V5XSA9ICFpc1Jvb3QgfHwgVkFMSURBVElPTl9NT0RFLmFsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9jYWxQcm94eUZvcm1TdGF0ZSAmJiAobG9jYWxQcm94eUZvcm1TdGF0ZVtfa2V5XSA9IHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtU3RhdGVbX2tleV07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmNvbnN0IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IFJlYWN0LnVzZUxheW91dEVmZmVjdCA6IFJlYWN0LnVzZUVmZmVjdDtcblxuLyoqXG4gKiBUaGlzIGN1c3RvbSBob29rIGFsbG93cyB5b3UgdG8gc3Vic2NyaWJlIHRvIGVhY2ggZm9ybSBzdGF0ZSwgYW5kIGlzb2xhdGUgdGhlIHJlLXJlbmRlciBhdCB0aGUgY3VzdG9tIGhvb2sgbGV2ZWwuIEl0IGhhcyBpdHMgc2NvcGUgaW4gdGVybXMgb2YgZm9ybSBzdGF0ZSBzdWJzY3JpcHRpb24sIHNvIGl0IHdvdWxkIG5vdCBhZmZlY3Qgb3RoZXIgdXNlRm9ybVN0YXRlIGFuZCB1c2VGb3JtLiBVc2luZyB0aGlzIGhvb2sgY2FuIHJlZHVjZSB0aGUgcmUtcmVuZGVyIGltcGFjdCBvbiBsYXJnZSBhbmQgY29tcGxleCBmb3JtIGFwcGxpY2F0aW9uLlxuICpcbiAqIEByZW1hcmtzXG4gKiBbQVBJXShodHRwczovL3JlYWN0LWhvb2stZm9ybS5jb20vZG9jcy91c2Vmb3Jtc3RhdGUpIOKAoiBbRGVtb10oaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL3VzZWZvcm1zdGF0ZS03NXhseSlcbiAqXG4gKiBAcGFyYW0gcHJvcHMgLSBpbmNsdWRlIG9wdGlvbnMgb24gc3BlY2lmeSBmaWVsZHMgdG8gc3Vic2NyaWJlLiB7QGxpbmsgVXNlRm9ybVN0YXRlUmV0dXJufVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c3hcbiAqIGZ1bmN0aW9uIEFwcCgpIHtcbiAqICAgY29uc3QgeyByZWdpc3RlciwgaGFuZGxlU3VibWl0LCBjb250cm9sIH0gPSB1c2VGb3JtKHtcbiAqICAgICBkZWZhdWx0VmFsdWVzOiB7XG4gKiAgICAgZmlyc3ROYW1lOiBcImZpcnN0TmFtZVwiXG4gKiAgIH19KTtcbiAqICAgY29uc3QgeyBkaXJ0eUZpZWxkcyB9ID0gdXNlRm9ybVN0YXRlKHtcbiAqICAgICBjb250cm9sXG4gKiAgIH0pO1xuICogICBjb25zdCBvblN1Ym1pdCA9IChkYXRhKSA9PiBjb25zb2xlLmxvZyhkYXRhKTtcbiAqXG4gKiAgIHJldHVybiAoXG4gKiAgICAgPGZvcm0gb25TdWJtaXQ9e2hhbmRsZVN1Ym1pdChvblN1Ym1pdCl9PlxuICogICAgICAgPGlucHV0IHsuLi5yZWdpc3RlcihcImZpcnN0TmFtZVwiKX0gcGxhY2Vob2xkZXI9XCJGaXJzdCBOYW1lXCIgLz5cbiAqICAgICAgIHtkaXJ0eUZpZWxkcy5maXJzdE5hbWUgJiYgPHA+RmllbGQgaXMgZGlydHkuPC9wPn1cbiAqICAgICAgIDxpbnB1dCB0eXBlPVwic3VibWl0XCIgLz5cbiAqICAgICA8L2Zvcm0+XG4gKiAgICk7XG4gKiB9XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gdXNlRm9ybVN0YXRlKHByb3BzKSB7XG4gICAgY29uc3QgbWV0aG9kcyA9IHVzZUZvcm1Db250ZXh0KCk7XG4gICAgY29uc3QgeyBjb250cm9sID0gbWV0aG9kcy5jb250cm9sLCBkaXNhYmxlZCwgbmFtZSwgZXhhY3QgfSA9IHByb3BzIHx8IHt9O1xuICAgIGNvbnN0IFtmb3JtU3RhdGUsIHVwZGF0ZUZvcm1TdGF0ZV0gPSBSZWFjdC51c2VTdGF0ZShjb250cm9sLl9mb3JtU3RhdGUpO1xuICAgIGNvbnN0IF9sb2NhbFByb3h5Rm9ybVN0YXRlID0gUmVhY3QudXNlUmVmKHtcbiAgICAgICAgaXNEaXJ0eTogZmFsc2UsXG4gICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgIGRpcnR5RmllbGRzOiBmYWxzZSxcbiAgICAgICAgdG91Y2hlZEZpZWxkczogZmFsc2UsXG4gICAgICAgIHZhbGlkYXRpbmdGaWVsZHM6IGZhbHNlLFxuICAgICAgICBpc1ZhbGlkYXRpbmc6IGZhbHNlLFxuICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgZXJyb3JzOiBmYWxzZSxcbiAgICB9KTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IGNvbnRyb2wuX3N1YnNjcmliZSh7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIGZvcm1TdGF0ZTogX2xvY2FsUHJveHlGb3JtU3RhdGUuY3VycmVudCxcbiAgICAgICAgZXhhY3QsXG4gICAgICAgIGNhbGxiYWNrOiAoZm9ybVN0YXRlKSA9PiB7XG4gICAgICAgICAgICAhZGlzYWJsZWQgJiZcbiAgICAgICAgICAgICAgICB1cGRhdGVGb3JtU3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICAuLi5jb250cm9sLl9mb3JtU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIC4uLmZvcm1TdGF0ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICB9KSwgW25hbWUsIGRpc2FibGVkLCBleGFjdF0pO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIF9sb2NhbFByb3h5Rm9ybVN0YXRlLmN1cnJlbnQuaXNWYWxpZCAmJiBjb250cm9sLl9zZXRWYWxpZCh0cnVlKTtcbiAgICB9LCBbY29udHJvbF0pO1xuICAgIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IGdldFByb3h5Rm9ybVN0YXRlKGZvcm1TdGF0ZSwgY29udHJvbCwgX2xvY2FsUHJveHlGb3JtU3RhdGUuY3VycmVudCwgZmFsc2UpLCBbZm9ybVN0YXRlLCBjb250cm9sXSk7XG59XG5cbnZhciBpc1N0cmluZyA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcblxudmFyIGdlbmVyYXRlV2F0Y2hPdXRwdXQgPSAobmFtZXMsIF9uYW1lcywgZm9ybVZhbHVlcywgaXNHbG9iYWwsIGRlZmF1bHRWYWx1ZSkgPT4ge1xuICAgIGlmIChpc1N0cmluZyhuYW1lcykpIHtcbiAgICAgICAgaXNHbG9iYWwgJiYgX25hbWVzLndhdGNoLmFkZChuYW1lcyk7XG4gICAgICAgIHJldHVybiBnZXQoZm9ybVZhbHVlcywgbmFtZXMsIGRlZmF1bHRWYWx1ZSk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KG5hbWVzKSkge1xuICAgICAgICByZXR1cm4gbmFtZXMubWFwKChmaWVsZE5hbWUpID0+IChpc0dsb2JhbCAmJiBfbmFtZXMud2F0Y2guYWRkKGZpZWxkTmFtZSksXG4gICAgICAgICAgICBnZXQoZm9ybVZhbHVlcywgZmllbGROYW1lKSkpO1xuICAgIH1cbiAgICBpc0dsb2JhbCAmJiAoX25hbWVzLndhdGNoQWxsID0gdHJ1ZSk7XG4gICAgcmV0dXJuIGZvcm1WYWx1ZXM7XG59O1xuXG52YXIgaXNQcmltaXRpdmUgPSAodmFsdWUpID0+IGlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKSB8fCAhaXNPYmplY3RUeXBlKHZhbHVlKTtcblxuZnVuY3Rpb24gZGVlcEVxdWFsKG9iamVjdDEsIG9iamVjdDIsIF9pbnRlcm5hbF92aXNpdGVkID0gbmV3IFdlYWtTZXQoKSkge1xuICAgIGlmIChpc1ByaW1pdGl2ZShvYmplY3QxKSB8fCBpc1ByaW1pdGl2ZShvYmplY3QyKSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0MSA9PT0gb2JqZWN0MjtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZU9iamVjdChvYmplY3QxKSAmJiBpc0RhdGVPYmplY3Qob2JqZWN0MikpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDEuZ2V0VGltZSgpID09PSBvYmplY3QyLmdldFRpbWUoKTtcbiAgICB9XG4gICAgY29uc3Qga2V5czEgPSBPYmplY3Qua2V5cyhvYmplY3QxKTtcbiAgICBjb25zdCBrZXlzMiA9IE9iamVjdC5rZXlzKG9iamVjdDIpO1xuICAgIGlmIChrZXlzMS5sZW5ndGggIT09IGtleXMyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChfaW50ZXJuYWxfdmlzaXRlZC5oYXMob2JqZWN0MSkgfHwgX2ludGVybmFsX3Zpc2l0ZWQuaGFzKG9iamVjdDIpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdmlzaXRlZC5hZGQob2JqZWN0MSk7XG4gICAgX2ludGVybmFsX3Zpc2l0ZWQuYWRkKG9iamVjdDIpO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMxKSB7XG4gICAgICAgIGNvbnN0IHZhbDEgPSBvYmplY3QxW2tleV07XG4gICAgICAgIGlmICgha2V5czIuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkgIT09ICdyZWYnKSB7XG4gICAgICAgICAgICBjb25zdCB2YWwyID0gb2JqZWN0MltrZXldO1xuICAgICAgICAgICAgaWYgKChpc0RhdGVPYmplY3QodmFsMSkgJiYgaXNEYXRlT2JqZWN0KHZhbDIpKSB8fFxuICAgICAgICAgICAgICAgIChpc09iamVjdCh2YWwxKSAmJiBpc09iamVjdCh2YWwyKSkgfHxcbiAgICAgICAgICAgICAgICAoQXJyYXkuaXNBcnJheSh2YWwxKSAmJiBBcnJheS5pc0FycmF5KHZhbDIpKVxuICAgICAgICAgICAgICAgID8gIWRlZXBFcXVhbCh2YWwxLCB2YWwyLCBfaW50ZXJuYWxfdmlzaXRlZClcbiAgICAgICAgICAgICAgICA6IHZhbDEgIT09IHZhbDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQ3VzdG9tIGhvb2sgdG8gc3Vic2NyaWJlIHRvIGZpZWxkIGNoYW5nZSBhbmQgaXNvbGF0ZSByZS1yZW5kZXJpbmcgYXQgdGhlIGNvbXBvbmVudCBsZXZlbC5cbiAqXG4gKiBAcmVtYXJrc1xuICpcbiAqIFtBUEldKGh0dHBzOi8vcmVhY3QtaG9vay1mb3JtLmNvbS9kb2NzL3VzZXdhdGNoKSDigKIgW0RlbW9dKGh0dHBzOi8vY29kZXNhbmRib3guaW8vcy9yZWFjdC1ob29rLWZvcm0tdjctdHMtdXNld2F0Y2gtaDlpNWUpXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogY29uc3QgeyBjb250cm9sIH0gPSB1c2VGb3JtKCk7XG4gKiBjb25zdCB2YWx1ZXMgPSB1c2VXYXRjaCh7XG4gKiAgIG5hbWU6IFwiZmllbGROYW1lXCJcbiAqICAgY29udHJvbCxcbiAqIH0pXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gdXNlV2F0Y2gocHJvcHMpIHtcbiAgICBjb25zdCBtZXRob2RzID0gdXNlRm9ybUNvbnRleHQoKTtcbiAgICBjb25zdCB7IGNvbnRyb2wgPSBtZXRob2RzLmNvbnRyb2wsIG5hbWUsIGRlZmF1bHRWYWx1ZSwgZGlzYWJsZWQsIGV4YWN0LCBjb21wdXRlLCB9ID0gcHJvcHMgfHwge307XG4gICAgY29uc3QgX2RlZmF1bHRWYWx1ZSA9IFJlYWN0LnVzZVJlZihkZWZhdWx0VmFsdWUpO1xuICAgIGNvbnN0IF9jb21wdXRlID0gUmVhY3QudXNlUmVmKGNvbXB1dGUpO1xuICAgIGNvbnN0IF9jb21wdXRlRm9ybVZhbHVlcyA9IFJlYWN0LnVzZVJlZih1bmRlZmluZWQpO1xuICAgIF9jb21wdXRlLmN1cnJlbnQgPSBjb21wdXRlO1xuICAgIGNvbnN0IGRlZmF1bHRWYWx1ZU1lbW8gPSBSZWFjdC51c2VNZW1vKCgpID0+IGNvbnRyb2wuX2dldFdhdGNoKG5hbWUsIF9kZWZhdWx0VmFsdWUuY3VycmVudCksIFtjb250cm9sLCBuYW1lXSk7XG4gICAgY29uc3QgW3ZhbHVlLCB1cGRhdGVWYWx1ZV0gPSBSZWFjdC51c2VTdGF0ZShfY29tcHV0ZS5jdXJyZW50ID8gX2NvbXB1dGUuY3VycmVudChkZWZhdWx0VmFsdWVNZW1vKSA6IGRlZmF1bHRWYWx1ZU1lbW8pO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4gY29udHJvbC5fc3Vic2NyaWJlKHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgZm9ybVN0YXRlOiB7XG4gICAgICAgICAgICB2YWx1ZXM6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIGV4YWN0LFxuICAgICAgICBjYWxsYmFjazogKGZvcm1TdGF0ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFkaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZvcm1WYWx1ZXMgPSBnZW5lcmF0ZVdhdGNoT3V0cHV0KG5hbWUsIGNvbnRyb2wuX25hbWVzLCBmb3JtU3RhdGUudmFsdWVzIHx8IGNvbnRyb2wuX2Zvcm1WYWx1ZXMsIGZhbHNlLCBfZGVmYXVsdFZhbHVlLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIGlmIChfY29tcHV0ZS5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbXB1dGVkRm9ybVZhbHVlcyA9IF9jb21wdXRlLmN1cnJlbnQoZm9ybVZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZGVlcEVxdWFsKGNvbXB1dGVkRm9ybVZhbHVlcywgX2NvbXB1dGVGb3JtVmFsdWVzLmN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVWYWx1ZShjb21wdXRlZEZvcm1WYWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbXB1dGVGb3JtVmFsdWVzLmN1cnJlbnQgPSBjb21wdXRlZEZvcm1WYWx1ZXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVZhbHVlKGZvcm1WYWx1ZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KSwgW2NvbnRyb2wsIGRpc2FibGVkLCBuYW1lLCBleGFjdF0pO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiBjb250cm9sLl9yZW1vdmVVbm1vdW50ZWQoKSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIEN1c3RvbSBob29rIHRvIHdvcmsgd2l0aCBjb250cm9sbGVkIGNvbXBvbmVudCwgdGhpcyBmdW5jdGlvbiBwcm92aWRlIHlvdSB3aXRoIGJvdGggZm9ybSBhbmQgZmllbGQgbGV2ZWwgc3RhdGUuIFJlLXJlbmRlciBpcyBpc29sYXRlZCBhdCB0aGUgaG9vayBsZXZlbC5cbiAqXG4gKiBAcmVtYXJrc1xuICogW0FQSV0oaHR0cHM6Ly9yZWFjdC1ob29rLWZvcm0uY29tL2RvY3MvdXNlY29udHJvbGxlcikg4oCiIFtEZW1vXShodHRwczovL2NvZGVzYW5kYm94LmlvL3MvdXNlY29udHJvbGxlci0wbzhweClcbiAqXG4gKiBAcGFyYW0gcHJvcHMgLSB0aGUgcGF0aCBuYW1lIHRvIHRoZSBmb3JtIGZpZWxkIHZhbHVlLCBhbmQgdmFsaWRhdGlvbiBydWxlcy5cbiAqXG4gKiBAcmV0dXJucyBmaWVsZCBwcm9wZXJ0aWVzLCBmaWVsZCBhbmQgZm9ybSBzdGF0ZS4ge0BsaW5rIFVzZUNvbnRyb2xsZXJSZXR1cm59XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogZnVuY3Rpb24gSW5wdXQocHJvcHMpIHtcbiAqICAgY29uc3QgeyBmaWVsZCwgZmllbGRTdGF0ZSwgZm9ybVN0YXRlIH0gPSB1c2VDb250cm9sbGVyKHByb3BzKTtcbiAqICAgcmV0dXJuIChcbiAqICAgICA8ZGl2PlxuICogICAgICAgPGlucHV0IHsuLi5maWVsZH0gcGxhY2Vob2xkZXI9e3Byb3BzLm5hbWV9IC8+XG4gKiAgICAgICA8cD57ZmllbGRTdGF0ZS5pc1RvdWNoZWQgJiYgXCJUb3VjaGVkXCJ9PC9wPlxuICogICAgICAgPHA+e2Zvcm1TdGF0ZS5pc1N1Ym1pdHRlZCA/IFwic3VibWl0dGVkXCIgOiBcIlwifTwvcD5cbiAqICAgICA8L2Rpdj5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiB1c2VDb250cm9sbGVyKHByb3BzKSB7XG4gICAgY29uc3QgbWV0aG9kcyA9IHVzZUZvcm1Db250ZXh0KCk7XG4gICAgY29uc3QgeyBuYW1lLCBkaXNhYmxlZCwgY29udHJvbCA9IG1ldGhvZHMuY29udHJvbCwgc2hvdWxkVW5yZWdpc3RlciwgZGVmYXVsdFZhbHVlLCB9ID0gcHJvcHM7XG4gICAgY29uc3QgaXNBcnJheUZpZWxkID0gaXNOYW1lSW5GaWVsZEFycmF5KGNvbnRyb2wuX25hbWVzLmFycmF5LCBuYW1lKTtcbiAgICBjb25zdCBkZWZhdWx0VmFsdWVNZW1vID0gUmVhY3QudXNlTWVtbygoKSA9PiBnZXQoY29udHJvbC5fZm9ybVZhbHVlcywgbmFtZSwgZ2V0KGNvbnRyb2wuX2RlZmF1bHRWYWx1ZXMsIG5hbWUsIGRlZmF1bHRWYWx1ZSkpLCBbY29udHJvbCwgbmFtZSwgZGVmYXVsdFZhbHVlXSk7XG4gICAgY29uc3QgdmFsdWUgPSB1c2VXYXRjaCh7XG4gICAgICAgIGNvbnRyb2wsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogZGVmYXVsdFZhbHVlTWVtbyxcbiAgICAgICAgZXhhY3Q6IHRydWUsXG4gICAgfSk7XG4gICAgY29uc3QgZm9ybVN0YXRlID0gdXNlRm9ybVN0YXRlKHtcbiAgICAgICAgY29udHJvbCxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgZXhhY3Q6IHRydWUsXG4gICAgfSk7XG4gICAgY29uc3QgX3Byb3BzID0gUmVhY3QudXNlUmVmKHByb3BzKTtcbiAgICBjb25zdCBfcHJldmlvdXNOYW1lUmVmID0gUmVhY3QudXNlUmVmKHVuZGVmaW5lZCk7XG4gICAgY29uc3QgX3JlZ2lzdGVyUHJvcHMgPSBSZWFjdC51c2VSZWYoY29udHJvbC5yZWdpc3RlcihuYW1lLCB7XG4gICAgICAgIC4uLnByb3BzLnJ1bGVzLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgLi4uKGlzQm9vbGVhbihwcm9wcy5kaXNhYmxlZCkgPyB7IGRpc2FibGVkOiBwcm9wcy5kaXNhYmxlZCB9IDoge30pLFxuICAgIH0pKTtcbiAgICBfcHJvcHMuY3VycmVudCA9IHByb3BzO1xuICAgIGNvbnN0IGZpZWxkU3RhdGUgPSBSZWFjdC51c2VNZW1vKCgpID0+IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHt9LCB7XG4gICAgICAgIGludmFsaWQ6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6ICgpID0+ICEhZ2V0KGZvcm1TdGF0ZS5lcnJvcnMsIG5hbWUpLFxuICAgICAgICB9LFxuICAgICAgICBpc0RpcnR5OiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiAoKSA9PiAhIWdldChmb3JtU3RhdGUuZGlydHlGaWVsZHMsIG5hbWUpLFxuICAgICAgICB9LFxuICAgICAgICBpc1RvdWNoZWQ6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6ICgpID0+ICEhZ2V0KGZvcm1TdGF0ZS50b3VjaGVkRmllbGRzLCBuYW1lKSxcbiAgICAgICAgfSxcbiAgICAgICAgaXNWYWxpZGF0aW5nOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiAoKSA9PiAhIWdldChmb3JtU3RhdGUudmFsaWRhdGluZ0ZpZWxkcywgbmFtZSksXG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiAoKSA9PiBnZXQoZm9ybVN0YXRlLmVycm9ycywgbmFtZSksXG4gICAgICAgIH0sXG4gICAgfSksIFtmb3JtU3RhdGUsIG5hbWVdKTtcbiAgICBjb25zdCBvbkNoYW5nZSA9IFJlYWN0LnVzZUNhbGxiYWNrKChldmVudCkgPT4gX3JlZ2lzdGVyUHJvcHMuY3VycmVudC5vbkNoYW5nZSh7XG4gICAgICAgIHRhcmdldDoge1xuICAgICAgICAgICAgdmFsdWU6IGdldEV2ZW50VmFsdWUoZXZlbnQpLFxuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgfSxcbiAgICAgICAgdHlwZTogRVZFTlRTLkNIQU5HRSxcbiAgICB9KSwgW25hbWVdKTtcbiAgICBjb25zdCBvbkJsdXIgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiBfcmVnaXN0ZXJQcm9wcy5jdXJyZW50Lm9uQmx1cih7XG4gICAgICAgIHRhcmdldDoge1xuICAgICAgICAgICAgdmFsdWU6IGdldChjb250cm9sLl9mb3JtVmFsdWVzLCBuYW1lKSxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIH0sXG4gICAgICAgIHR5cGU6IEVWRU5UUy5CTFVSLFxuICAgIH0pLCBbbmFtZSwgY29udHJvbC5fZm9ybVZhbHVlc10pO1xuICAgIGNvbnN0IHJlZiA9IFJlYWN0LnVzZUNhbGxiYWNrKChlbG0pID0+IHtcbiAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoY29udHJvbC5fZmllbGRzLCBuYW1lKTtcbiAgICAgICAgaWYgKGZpZWxkICYmIGVsbSkge1xuICAgICAgICAgICAgZmllbGQuX2YucmVmID0ge1xuICAgICAgICAgICAgICAgIGZvY3VzOiAoKSA9PiBlbG0uZm9jdXMgJiYgZWxtLmZvY3VzKCksXG4gICAgICAgICAgICAgICAgc2VsZWN0OiAoKSA9PiBlbG0uc2VsZWN0ICYmIGVsbS5zZWxlY3QoKSxcbiAgICAgICAgICAgICAgICBzZXRDdXN0b21WYWxpZGl0eTogKG1lc3NhZ2UpID0+IGVsbS5zZXRDdXN0b21WYWxpZGl0eShtZXNzYWdlKSxcbiAgICAgICAgICAgICAgICByZXBvcnRWYWxpZGl0eTogKCkgPT4gZWxtLnJlcG9ydFZhbGlkaXR5KCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSwgW2NvbnRyb2wuX2ZpZWxkcywgbmFtZV0pO1xuICAgIGNvbnN0IGZpZWxkID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgICAgICBuYW1lLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgLi4uKGlzQm9vbGVhbihkaXNhYmxlZCkgfHwgZm9ybVN0YXRlLmRpc2FibGVkXG4gICAgICAgICAgICA/IHsgZGlzYWJsZWQ6IGZvcm1TdGF0ZS5kaXNhYmxlZCB8fCBkaXNhYmxlZCB9XG4gICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgb25DaGFuZ2UsXG4gICAgICAgIG9uQmx1cixcbiAgICAgICAgcmVmLFxuICAgIH0pLCBbbmFtZSwgZGlzYWJsZWQsIGZvcm1TdGF0ZS5kaXNhYmxlZCwgb25DaGFuZ2UsIG9uQmx1ciwgcmVmLCB2YWx1ZV0pO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IF9zaG91bGRVbnJlZ2lzdGVyRmllbGQgPSBjb250cm9sLl9vcHRpb25zLnNob3VsZFVucmVnaXN0ZXIgfHwgc2hvdWxkVW5yZWdpc3RlcjtcbiAgICAgICAgY29uc3QgcHJldmlvdXNOYW1lID0gX3ByZXZpb3VzTmFtZVJlZi5jdXJyZW50O1xuICAgICAgICBpZiAocHJldmlvdXNOYW1lICYmIHByZXZpb3VzTmFtZSAhPT0gbmFtZSAmJiAhaXNBcnJheUZpZWxkKSB7XG4gICAgICAgICAgICBjb250cm9sLnVucmVnaXN0ZXIocHJldmlvdXNOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBjb250cm9sLnJlZ2lzdGVyKG5hbWUsIHtcbiAgICAgICAgICAgIC4uLl9wcm9wcy5jdXJyZW50LnJ1bGVzLFxuICAgICAgICAgICAgLi4uKGlzQm9vbGVhbihfcHJvcHMuY3VycmVudC5kaXNhYmxlZClcbiAgICAgICAgICAgICAgICA/IHsgZGlzYWJsZWQ6IF9wcm9wcy5jdXJyZW50LmRpc2FibGVkIH1cbiAgICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHVwZGF0ZU1vdW50ZWQgPSAobmFtZSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KGNvbnRyb2wuX2ZpZWxkcywgbmFtZSk7XG4gICAgICAgICAgICBpZiAoZmllbGQgJiYgZmllbGQuX2YpIHtcbiAgICAgICAgICAgICAgICBmaWVsZC5fZi5tb3VudCA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB1cGRhdGVNb3VudGVkKG5hbWUsIHRydWUpO1xuICAgICAgICBpZiAoX3Nob3VsZFVucmVnaXN0ZXJGaWVsZCkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBjbG9uZU9iamVjdChnZXQoY29udHJvbC5fb3B0aW9ucy5kZWZhdWx0VmFsdWVzLCBuYW1lKSk7XG4gICAgICAgICAgICBzZXQoY29udHJvbC5fZGVmYXVsdFZhbHVlcywgbmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGdldChjb250cm9sLl9mb3JtVmFsdWVzLCBuYW1lKSkpIHtcbiAgICAgICAgICAgICAgICBzZXQoY29udHJvbC5fZm9ybVZhbHVlcywgbmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICFpc0FycmF5RmllbGQgJiYgY29udHJvbC5yZWdpc3RlcihuYW1lKTtcbiAgICAgICAgX3ByZXZpb3VzTmFtZVJlZi5jdXJyZW50ID0gbmFtZTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIChpc0FycmF5RmllbGRcbiAgICAgICAgICAgICAgICA/IF9zaG91bGRVbnJlZ2lzdGVyRmllbGQgJiYgIWNvbnRyb2wuX3N0YXRlLmFjdGlvblxuICAgICAgICAgICAgICAgIDogX3Nob3VsZFVucmVnaXN0ZXJGaWVsZClcbiAgICAgICAgICAgICAgICA/IGNvbnRyb2wudW5yZWdpc3RlcihuYW1lKVxuICAgICAgICAgICAgICAgIDogdXBkYXRlTW91bnRlZChuYW1lLCBmYWxzZSk7XG4gICAgICAgIH07XG4gICAgfSwgW25hbWUsIGNvbnRyb2wsIGlzQXJyYXlGaWVsZCwgc2hvdWxkVW5yZWdpc3Rlcl0pO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnRyb2wuX3NldERpc2FibGVkRmllbGQoe1xuICAgICAgICAgICAgZGlzYWJsZWQsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICB9KTtcbiAgICB9LCBbZGlzYWJsZWQsIG5hbWUsIGNvbnRyb2xdKTtcbiAgICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgICAgICBmaWVsZCxcbiAgICAgICAgZm9ybVN0YXRlLFxuICAgICAgICBmaWVsZFN0YXRlLFxuICAgIH0pLCBbZmllbGQsIGZvcm1TdGF0ZSwgZmllbGRTdGF0ZV0pO1xufVxuXG4vKipcbiAqIENvbXBvbmVudCBiYXNlZCBvbiBgdXNlQ29udHJvbGxlcmAgaG9vayB0byB3b3JrIHdpdGggY29udHJvbGxlZCBjb21wb25lbnQuXG4gKlxuICogQHJlbWFya3NcbiAqIFtBUEldKGh0dHBzOi8vcmVhY3QtaG9vay1mb3JtLmNvbS9kb2NzL3VzZWNvbnRyb2xsZXIvY29udHJvbGxlcikg4oCiIFtEZW1vXShodHRwczovL2NvZGVzYW5kYm94LmlvL3MvcmVhY3QtaG9vay1mb3JtLXY2LWNvbnRyb2xsZXItdHMtand5encpIOKAoiBbVmlkZW9dKGh0dHBzOi8vd3d3LnlvdXR1YmUuY29tL3dhdGNoP3Y9TjJVTmtfVUNWeUEpXG4gKlxuICogQHBhcmFtIHByb3BzIC0gdGhlIHBhdGggbmFtZSB0byB0aGUgZm9ybSBmaWVsZCB2YWx1ZSwgYW5kIHZhbGlkYXRpb24gcnVsZXMuXG4gKlxuICogQHJldHVybnMgcHJvdmlkZSBmaWVsZCBoYW5kbGVyIGZ1bmN0aW9ucywgZmllbGQgYW5kIGZvcm0gc3RhdGUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogZnVuY3Rpb24gQXBwKCkge1xuICogICBjb25zdCB7IGNvbnRyb2wgfSA9IHVzZUZvcm08Rm9ybVZhbHVlcz4oe1xuICogICAgIGRlZmF1bHRWYWx1ZXM6IHtcbiAqICAgICAgIHRlc3Q6IFwiXCJcbiAqICAgICB9XG4gKiAgIH0pO1xuICpcbiAqICAgcmV0dXJuIChcbiAqICAgICA8Zm9ybT5cbiAqICAgICAgIDxDb250cm9sbGVyXG4gKiAgICAgICAgIGNvbnRyb2w9e2NvbnRyb2x9XG4gKiAgICAgICAgIG5hbWU9XCJ0ZXN0XCJcbiAqICAgICAgICAgcmVuZGVyPXsoeyBmaWVsZDogeyBvbkNoYW5nZSwgb25CbHVyLCB2YWx1ZSwgcmVmIH0sIGZvcm1TdGF0ZSwgZmllbGRTdGF0ZSB9KSA9PiAoXG4gKiAgICAgICAgICAgPD5cbiAqICAgICAgICAgICAgIDxpbnB1dFxuICogICAgICAgICAgICAgICBvbkNoYW5nZT17b25DaGFuZ2V9IC8vIHNlbmQgdmFsdWUgdG8gaG9vayBmb3JtXG4gKiAgICAgICAgICAgICAgIG9uQmx1cj17b25CbHVyfSAvLyBub3RpZnkgd2hlbiBpbnB1dCBpcyB0b3VjaGVkXG4gKiAgICAgICAgICAgICAgIHZhbHVlPXt2YWx1ZX0gLy8gcmV0dXJuIHVwZGF0ZWQgdmFsdWVcbiAqICAgICAgICAgICAgICAgcmVmPXtyZWZ9IC8vIHNldCByZWYgZm9yIGZvY3VzIG1hbmFnZW1lbnRcbiAqICAgICAgICAgICAgIC8+XG4gKiAgICAgICAgICAgICA8cD57Zm9ybVN0YXRlLmlzU3VibWl0dGVkID8gXCJzdWJtaXR0ZWRcIiA6IFwiXCJ9PC9wPlxuICogICAgICAgICAgICAgPHA+e2ZpZWxkU3RhdGUuaXNUb3VjaGVkID8gXCJ0b3VjaGVkXCIgOiBcIlwifTwvcD5cbiAqICAgICAgICAgICA8Lz5cbiAqICAgICAgICAgKX1cbiAqICAgICAgIC8+XG4gKiAgICAgPC9mb3JtPlxuICogICApO1xuICogfVxuICogYGBgXG4gKi9cbmNvbnN0IENvbnRyb2xsZXIgPSAocHJvcHMpID0+IHByb3BzLnJlbmRlcih1c2VDb250cm9sbGVyKHByb3BzKSk7XG5cbmNvbnN0IGZsYXR0ZW4gPSAob2JqKSA9PiB7XG4gICAgY29uc3Qgb3V0cHV0ID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMob2JqKSkge1xuICAgICAgICBpZiAoaXNPYmplY3RUeXBlKG9ialtrZXldKSAmJiBvYmpba2V5XSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgbmVzdGVkID0gZmxhdHRlbihvYmpba2V5XSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5lc3RlZEtleSBvZiBPYmplY3Qua2V5cyhuZXN0ZWQpKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W2Ake2tleX0uJHtuZXN0ZWRLZXl9YF0gPSBuZXN0ZWRbbmVzdGVkS2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dFtrZXldID0gb2JqW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbn07XG5cbmNvbnN0IFBPU1RfUkVRVUVTVCA9ICdwb3N0Jztcbi8qKlxuICogRm9ybSBjb21wb25lbnQgdG8gbWFuYWdlIHN1Ym1pc3Npb24uXG4gKlxuICogQHBhcmFtIHByb3BzIC0gdG8gc2V0dXAgc3VibWlzc2lvbiBkZXRhaWwuIHtAbGluayBGb3JtUHJvcHN9XG4gKlxuICogQHJldHVybnMgZm9ybSBjb21wb25lbnQgb3IgaGVhZGxlc3MgcmVuZGVyIHByb3AuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogZnVuY3Rpb24gQXBwKCkge1xuICogICBjb25zdCB7IGNvbnRyb2wsIGZvcm1TdGF0ZTogeyBlcnJvcnMgfSB9ID0gdXNlRm9ybSgpO1xuICpcbiAqICAgcmV0dXJuIChcbiAqICAgICA8Rm9ybSBhY3Rpb249XCIvYXBpXCIgY29udHJvbD17Y29udHJvbH0+XG4gKiAgICAgICA8aW5wdXQgey4uLnJlZ2lzdGVyKFwibmFtZVwiKX0gLz5cbiAqICAgICAgIDxwPntlcnJvcnM/LnJvb3Q/LnNlcnZlciAmJiAnU2VydmVyIGVycm9yJ308L3A+XG4gKiAgICAgICA8YnV0dG9uPlN1Ym1pdDwvYnV0dG9uPlxuICogICAgIDwvRm9ybT5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiBGb3JtKHByb3BzKSB7XG4gICAgY29uc3QgbWV0aG9kcyA9IHVzZUZvcm1Db250ZXh0KCk7XG4gICAgY29uc3QgW21vdW50ZWQsIHNldE1vdW50ZWRdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IHsgY29udHJvbCA9IG1ldGhvZHMuY29udHJvbCwgb25TdWJtaXQsIGNoaWxkcmVuLCBhY3Rpb24sIG1ldGhvZCA9IFBPU1RfUkVRVUVTVCwgaGVhZGVycywgZW5jVHlwZSwgb25FcnJvciwgcmVuZGVyLCBvblN1Y2Nlc3MsIHZhbGlkYXRlU3RhdHVzLCAuLi5yZXN0IH0gPSBwcm9wcztcbiAgICBjb25zdCBzdWJtaXQgPSBhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgbGV0IGhhc0Vycm9yID0gZmFsc2U7XG4gICAgICAgIGxldCB0eXBlID0gJyc7XG4gICAgICAgIGF3YWl0IGNvbnRyb2wuaGFuZGxlU3VibWl0KGFzeW5jIChkYXRhKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICAgICAgbGV0IGZvcm1EYXRhSnNvbiA9ICcnO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3JtRGF0YUpzb24gPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfYSkgeyB9XG4gICAgICAgICAgICBjb25zdCBmbGF0dGVuRm9ybVZhbHVlcyA9IGZsYXR0ZW4oY29udHJvbC5fZm9ybVZhbHVlcyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBmbGF0dGVuRm9ybVZhbHVlcykge1xuICAgICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChrZXksIGZsYXR0ZW5Gb3JtVmFsdWVzW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9uU3VibWl0KSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgb25TdWJtaXQoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICBmb3JtRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgZm9ybURhdGFKc29uLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFjdGlvbikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNob3VsZFN0cmluZ2lmeVN1Ym1pc3Npb25EYXRhID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVycyAmJiBoZWFkZXJzWydDb250ZW50LVR5cGUnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuY1R5cGUsXG4gICAgICAgICAgICAgICAgICAgIF0uc29tZSgodmFsdWUpID0+IHZhbHVlICYmIHZhbHVlLmluY2x1ZGVzKCdqc29uJykpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFN0cmluZyhhY3Rpb24pLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi4oZW5jVHlwZSAmJiBlbmNUeXBlICE9PSAnbXVsdGlwYXJ0L2Zvcm0tZGF0YSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB7ICdDb250ZW50LVR5cGUnOiBlbmNUeXBlIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB7fSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogc2hvdWxkU3RyaW5naWZ5U3VibWlzc2lvbkRhdGEgPyBmb3JtRGF0YUpzb24gOiBmb3JtRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKHZhbGlkYXRlU3RhdHVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAhdmFsaWRhdGVTdGF0dXMocmVzcG9uc2Uuc3RhdHVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcmVzcG9uc2Uuc3RhdHVzIDwgMjAwIHx8IHJlc3BvbnNlLnN0YXR1cyA+PSAzMDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yICYmIG9uRXJyb3IoeyByZXNwb25zZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSBTdHJpbmcocmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uU3VjY2VzcyAmJiBvblN1Y2Nlc3MoeyByZXNwb25zZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBvbkVycm9yICYmIG9uRXJyb3IoeyBlcnJvciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKGV2ZW50KTtcbiAgICAgICAgaWYgKGhhc0Vycm9yICYmIHByb3BzLmNvbnRyb2wpIHtcbiAgICAgICAgICAgIHByb3BzLmNvbnRyb2wuX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgICAgIGlzU3VibWl0U3VjY2Vzc2Z1bDogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHByb3BzLmNvbnRyb2wuc2V0RXJyb3IoJ3Jvb3Quc2VydmVyJywge1xuICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgc2V0TW91bnRlZCh0cnVlKTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIHJlbmRlciA/IChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCByZW5kZXIoe1xuICAgICAgICBzdWJtaXQsXG4gICAgfSkpKSA6IChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZm9ybVwiLCB7IG5vVmFsaWRhdGU6IG1vdW50ZWQsIGFjdGlvbjogYWN0aW9uLCBtZXRob2Q6IG1ldGhvZCwgZW5jVHlwZTogZW5jVHlwZSwgb25TdWJtaXQ6IHN1Ym1pdCwgLi4ucmVzdCB9LCBjaGlsZHJlbikpO1xufVxuXG52YXIgYXBwZW5kRXJyb3JzID0gKG5hbWUsIHZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSwgZXJyb3JzLCB0eXBlLCBtZXNzYWdlKSA9PiB2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWFcbiAgICA/IHtcbiAgICAgICAgLi4uZXJyb3JzW25hbWVdLFxuICAgICAgICB0eXBlczoge1xuICAgICAgICAgICAgLi4uKGVycm9yc1tuYW1lXSAmJiBlcnJvcnNbbmFtZV0udHlwZXMgPyBlcnJvcnNbbmFtZV0udHlwZXMgOiB7fSksXG4gICAgICAgICAgICBbdHlwZV06IG1lc3NhZ2UgfHwgdHJ1ZSxcbiAgICAgICAgfSxcbiAgICB9XG4gICAgOiB7fTtcblxudmFyIGNvbnZlcnRUb0FycmF5UGF5bG9hZCA9ICh2YWx1ZSkgPT4gKEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdKTtcblxudmFyIGNyZWF0ZVN1YmplY3QgPSAoKSA9PiB7XG4gICAgbGV0IF9vYnNlcnZlcnMgPSBbXTtcbiAgICBjb25zdCBuZXh0ID0gKHZhbHVlKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3Qgb2JzZXJ2ZXIgb2YgX29ic2VydmVycykge1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCAmJiBvYnNlcnZlci5uZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc3Vic2NyaWJlID0gKG9ic2VydmVyKSA9PiB7XG4gICAgICAgIF9vYnNlcnZlcnMucHVzaChvYnNlcnZlcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1bnN1YnNjcmliZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIF9vYnNlcnZlcnMgPSBfb2JzZXJ2ZXJzLmZpbHRlcigobykgPT4gbyAhPT0gb2JzZXJ2ZXIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gKCkgPT4ge1xuICAgICAgICBfb2JzZXJ2ZXJzID0gW107XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZXQgb2JzZXJ2ZXJzKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9vYnNlcnZlcnM7XG4gICAgICAgIH0sXG4gICAgICAgIG5leHQsXG4gICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgdW5zdWJzY3JpYmUsXG4gICAgfTtcbn07XG5cbmZ1bmN0aW9uIGV4dHJhY3RGb3JtVmFsdWVzKGZpZWxkc1N0YXRlLCBmb3JtVmFsdWVzKSB7XG4gICAgY29uc3QgdmFsdWVzID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZmllbGRzU3RhdGUpIHtcbiAgICAgICAgaWYgKGZpZWxkc1N0YXRlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkU3RhdGUgPSBmaWVsZHNTdGF0ZVtrZXldO1xuICAgICAgICAgICAgY29uc3QgZmllbGRWYWx1ZSA9IGZvcm1WYWx1ZXNba2V5XTtcbiAgICAgICAgICAgIGlmIChmaWVsZFN0YXRlICYmIGlzT2JqZWN0KGZpZWxkU3RhdGUpICYmIGZpZWxkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXN0ZWRGaWVsZHNTdGF0ZSA9IGV4dHJhY3RGb3JtVmFsdWVzKGZpZWxkU3RhdGUsIGZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChuZXN0ZWRGaWVsZHNTdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzW2tleV0gPSBuZXN0ZWRGaWVsZHNTdGF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZHNTdGF0ZVtrZXldKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVzW2tleV0gPSBmaWVsZFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG59XG5cbnZhciBpc0VtcHR5T2JqZWN0ID0gKHZhbHVlKSA9PiBpc09iamVjdCh2YWx1ZSkgJiYgIU9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGg7XG5cbnZhciBpc0ZpbGVJbnB1dCA9IChlbGVtZW50KSA9PiBlbGVtZW50LnR5cGUgPT09ICdmaWxlJztcblxudmFyIGlzRnVuY3Rpb24gPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcblxudmFyIGlzSFRNTEVsZW1lbnQgPSAodmFsdWUpID0+IHtcbiAgICBpZiAoIWlzV2ViKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgb3duZXIgPSB2YWx1ZSA/IHZhbHVlLm93bmVyRG9jdW1lbnQgOiAwO1xuICAgIHJldHVybiAodmFsdWUgaW5zdGFuY2VvZlxuICAgICAgICAob3duZXIgJiYgb3duZXIuZGVmYXVsdFZpZXcgPyBvd25lci5kZWZhdWx0Vmlldy5IVE1MRWxlbWVudCA6IEhUTUxFbGVtZW50KSk7XG59O1xuXG52YXIgaXNNdWx0aXBsZVNlbGVjdCA9IChlbGVtZW50KSA9PiBlbGVtZW50LnR5cGUgPT09IGBzZWxlY3QtbXVsdGlwbGVgO1xuXG52YXIgaXNSYWRpb0lucHV0ID0gKGVsZW1lbnQpID0+IGVsZW1lbnQudHlwZSA9PT0gJ3JhZGlvJztcblxudmFyIGlzUmFkaW9PckNoZWNrYm94ID0gKHJlZikgPT4gaXNSYWRpb0lucHV0KHJlZikgfHwgaXNDaGVja0JveElucHV0KHJlZik7XG5cbnZhciBsaXZlID0gKHJlZikgPT4gaXNIVE1MRWxlbWVudChyZWYpICYmIHJlZi5pc0Nvbm5lY3RlZDtcblxuZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHVwZGF0ZVBhdGgpIHtcbiAgICBjb25zdCBsZW5ndGggPSB1cGRhdGVQYXRoLnNsaWNlKDAsIC0xKS5sZW5ndGg7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgb2JqZWN0ID0gaXNVbmRlZmluZWQob2JqZWN0KSA/IGluZGV4KysgOiBvYmplY3RbdXBkYXRlUGF0aFtpbmRleCsrXV07XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG59XG5mdW5jdGlvbiBpc0VtcHR5QXJyYXkob2JqKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSAmJiAhaXNVbmRlZmluZWQob2JqW2tleV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiB1bnNldChvYmplY3QsIHBhdGgpIHtcbiAgICBjb25zdCBwYXRocyA9IEFycmF5LmlzQXJyYXkocGF0aClcbiAgICAgICAgPyBwYXRoXG4gICAgICAgIDogaXNLZXkocGF0aClcbiAgICAgICAgICAgID8gW3BhdGhdXG4gICAgICAgICAgICA6IHN0cmluZ1RvUGF0aChwYXRoKTtcbiAgICBjb25zdCBjaGlsZE9iamVjdCA9IHBhdGhzLmxlbmd0aCA9PT0gMSA/IG9iamVjdCA6IGJhc2VHZXQob2JqZWN0LCBwYXRocyk7XG4gICAgY29uc3QgaW5kZXggPSBwYXRocy5sZW5ndGggLSAxO1xuICAgIGNvbnN0IGtleSA9IHBhdGhzW2luZGV4XTtcbiAgICBpZiAoY2hpbGRPYmplY3QpIHtcbiAgICAgICAgZGVsZXRlIGNoaWxkT2JqZWN0W2tleV07XG4gICAgfVxuICAgIGlmIChpbmRleCAhPT0gMCAmJlxuICAgICAgICAoKGlzT2JqZWN0KGNoaWxkT2JqZWN0KSAmJiBpc0VtcHR5T2JqZWN0KGNoaWxkT2JqZWN0KSkgfHxcbiAgICAgICAgICAgIChBcnJheS5pc0FycmF5KGNoaWxkT2JqZWN0KSAmJiBpc0VtcHR5QXJyYXkoY2hpbGRPYmplY3QpKSkpIHtcbiAgICAgICAgdW5zZXQob2JqZWN0LCBwYXRocy5zbGljZSgwLCAtMSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xufVxuXG52YXIgb2JqZWN0SGFzRnVuY3Rpb24gPSAoZGF0YSkgPT4ge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGRhdGEpIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oZGF0YVtrZXldKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuZnVuY3Rpb24gaXNUcmF2ZXJzYWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSB8fCAoaXNPYmplY3QodmFsdWUpICYmICFvYmplY3RIYXNGdW5jdGlvbih2YWx1ZSkpO1xufVxuZnVuY3Rpb24gbWFya0ZpZWxkc0RpcnR5KGRhdGEsIGZpZWxkcyA9IHt9KSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZGF0YSkge1xuICAgICAgICBpZiAoaXNUcmF2ZXJzYWJsZShkYXRhW2tleV0pKSB7XG4gICAgICAgICAgICBmaWVsZHNba2V5XSA9IEFycmF5LmlzQXJyYXkoZGF0YVtrZXldKSA/IFtdIDoge307XG4gICAgICAgICAgICBtYXJrRmllbGRzRGlydHkoZGF0YVtrZXldLCBmaWVsZHNba2V5XSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKGRhdGFba2V5XSkpIHtcbiAgICAgICAgICAgIGZpZWxkc1trZXldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmllbGRzO1xufVxuZnVuY3Rpb24gZ2V0RGlydHlGaWVsZHMoZGF0YSwgZm9ybVZhbHVlcywgZGlydHlGaWVsZHNGcm9tVmFsdWVzKSB7XG4gICAgaWYgKCFkaXJ0eUZpZWxkc0Zyb21WYWx1ZXMpIHtcbiAgICAgICAgZGlydHlGaWVsZHNGcm9tVmFsdWVzID0gbWFya0ZpZWxkc0RpcnR5KGZvcm1WYWx1ZXMpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG4gICAgICAgIGlmIChpc1RyYXZlcnNhYmxlKGRhdGFba2V5XSkpIHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChmb3JtVmFsdWVzKSB8fCBpc1ByaW1pdGl2ZShkaXJ0eUZpZWxkc0Zyb21WYWx1ZXNba2V5XSkpIHtcbiAgICAgICAgICAgICAgICBkaXJ0eUZpZWxkc0Zyb21WYWx1ZXNba2V5XSA9IG1hcmtGaWVsZHNEaXJ0eShkYXRhW2tleV0sIEFycmF5LmlzQXJyYXkoZGF0YVtrZXldKSA/IFtdIDoge30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2V0RGlydHlGaWVsZHMoZGF0YVtrZXldLCBpc051bGxPclVuZGVmaW5lZChmb3JtVmFsdWVzKSA/IHt9IDogZm9ybVZhbHVlc1trZXldLCBkaXJ0eUZpZWxkc0Zyb21WYWx1ZXNba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkaXJ0eUZpZWxkc0Zyb21WYWx1ZXNba2V5XSA9ICFkZWVwRXF1YWwoZGF0YVtrZXldLCBmb3JtVmFsdWVzW2tleV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkaXJ0eUZpZWxkc0Zyb21WYWx1ZXM7XG59XG5cbmNvbnN0IGRlZmF1bHRSZXN1bHQgPSB7XG4gICAgdmFsdWU6IGZhbHNlLFxuICAgIGlzVmFsaWQ6IGZhbHNlLFxufTtcbmNvbnN0IHZhbGlkUmVzdWx0ID0geyB2YWx1ZTogdHJ1ZSwgaXNWYWxpZDogdHJ1ZSB9O1xudmFyIGdldENoZWNrYm94VmFsdWUgPSAob3B0aW9ucykgPT4ge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IG9wdGlvbnNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChvcHRpb24pID0+IG9wdGlvbiAmJiBvcHRpb24uY2hlY2tlZCAmJiAhb3B0aW9uLmRpc2FibGVkKVxuICAgICAgICAgICAgICAgIC5tYXAoKG9wdGlvbikgPT4gb3B0aW9uLnZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB2YWx1ZXMsIGlzVmFsaWQ6ICEhdmFsdWVzLmxlbmd0aCB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcHRpb25zWzBdLmNoZWNrZWQgJiYgIW9wdGlvbnNbMF0uZGlzYWJsZWRcbiAgICAgICAgICAgID8gLy8gQHRzLWV4cGVjdC1lcnJvciBleHBlY3RlZCB0byB3b3JrIGluIHRoZSBicm93c2VyXG4gICAgICAgICAgICAgICAgb3B0aW9uc1swXS5hdHRyaWJ1dGVzICYmICFpc1VuZGVmaW5lZChvcHRpb25zWzBdLmF0dHJpYnV0ZXMudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgID8gaXNVbmRlZmluZWQob3B0aW9uc1swXS52YWx1ZSkgfHwgb3B0aW9uc1swXS52YWx1ZSA9PT0gJydcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdmFsaWRSZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgIDogeyB2YWx1ZTogb3B0aW9uc1swXS52YWx1ZSwgaXNWYWxpZDogdHJ1ZSB9XG4gICAgICAgICAgICAgICAgICAgIDogdmFsaWRSZXN1bHRcbiAgICAgICAgICAgIDogZGVmYXVsdFJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRSZXN1bHQ7XG59O1xuXG52YXIgZ2V0RmllbGRWYWx1ZUFzID0gKHZhbHVlLCB7IHZhbHVlQXNOdW1iZXIsIHZhbHVlQXNEYXRlLCBzZXRWYWx1ZUFzIH0pID0+IGlzVW5kZWZpbmVkKHZhbHVlKVxuICAgID8gdmFsdWVcbiAgICA6IHZhbHVlQXNOdW1iZXJcbiAgICAgICAgPyB2YWx1ZSA9PT0gJydcbiAgICAgICAgICAgID8gTmFOXG4gICAgICAgICAgICA6IHZhbHVlXG4gICAgICAgICAgICAgICAgPyArdmFsdWVcbiAgICAgICAgICAgICAgICA6IHZhbHVlXG4gICAgICAgIDogdmFsdWVBc0RhdGUgJiYgaXNTdHJpbmcodmFsdWUpXG4gICAgICAgICAgICA/IG5ldyBEYXRlKHZhbHVlKVxuICAgICAgICAgICAgOiBzZXRWYWx1ZUFzXG4gICAgICAgICAgICAgICAgPyBzZXRWYWx1ZUFzKHZhbHVlKVxuICAgICAgICAgICAgICAgIDogdmFsdWU7XG5cbmNvbnN0IGRlZmF1bHRSZXR1cm4gPSB7XG4gICAgaXNWYWxpZDogZmFsc2UsXG4gICAgdmFsdWU6IG51bGwsXG59O1xudmFyIGdldFJhZGlvVmFsdWUgPSAob3B0aW9ucykgPT4gQXJyYXkuaXNBcnJheShvcHRpb25zKVxuICAgID8gb3B0aW9ucy5yZWR1Y2UoKHByZXZpb3VzLCBvcHRpb24pID0+IG9wdGlvbiAmJiBvcHRpb24uY2hlY2tlZCAmJiAhb3B0aW9uLmRpc2FibGVkXG4gICAgICAgID8ge1xuICAgICAgICAgICAgaXNWYWxpZDogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBvcHRpb24udmFsdWUsXG4gICAgICAgIH1cbiAgICAgICAgOiBwcmV2aW91cywgZGVmYXVsdFJldHVybilcbiAgICA6IGRlZmF1bHRSZXR1cm47XG5cbmZ1bmN0aW9uIGdldEZpZWxkVmFsdWUoX2YpIHtcbiAgICBjb25zdCByZWYgPSBfZi5yZWY7XG4gICAgaWYgKGlzRmlsZUlucHV0KHJlZikpIHtcbiAgICAgICAgcmV0dXJuIHJlZi5maWxlcztcbiAgICB9XG4gICAgaWYgKGlzUmFkaW9JbnB1dChyZWYpKSB7XG4gICAgICAgIHJldHVybiBnZXRSYWRpb1ZhbHVlKF9mLnJlZnMpLnZhbHVlO1xuICAgIH1cbiAgICBpZiAoaXNNdWx0aXBsZVNlbGVjdChyZWYpKSB7XG4gICAgICAgIHJldHVybiBbLi4ucmVmLnNlbGVjdGVkT3B0aW9uc10ubWFwKCh7IHZhbHVlIH0pID0+IHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKGlzQ2hlY2tCb3hJbnB1dChyZWYpKSB7XG4gICAgICAgIHJldHVybiBnZXRDaGVja2JveFZhbHVlKF9mLnJlZnMpLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0RmllbGRWYWx1ZUFzKGlzVW5kZWZpbmVkKHJlZi52YWx1ZSkgPyBfZi5yZWYudmFsdWUgOiByZWYudmFsdWUsIF9mKTtcbn1cblxudmFyIGdldFJlc29sdmVyT3B0aW9ucyA9IChmaWVsZHNOYW1lcywgX2ZpZWxkcywgY3JpdGVyaWFNb2RlLCBzaG91bGRVc2VOYXRpdmVWYWxpZGF0aW9uKSA9PiB7XG4gICAgY29uc3QgZmllbGRzID0ge307XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIGZpZWxkc05hbWVzKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KF9maWVsZHMsIG5hbWUpO1xuICAgICAgICBmaWVsZCAmJiBzZXQoZmllbGRzLCBuYW1lLCBmaWVsZC5fZik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGNyaXRlcmlhTW9kZSxcbiAgICAgICAgbmFtZXM6IFsuLi5maWVsZHNOYW1lc10sXG4gICAgICAgIGZpZWxkcyxcbiAgICAgICAgc2hvdWxkVXNlTmF0aXZlVmFsaWRhdGlvbixcbiAgICB9O1xufTtcblxudmFyIGlzUmVnZXggPSAodmFsdWUpID0+IHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwO1xuXG52YXIgZ2V0UnVsZVZhbHVlID0gKHJ1bGUpID0+IGlzVW5kZWZpbmVkKHJ1bGUpXG4gICAgPyBydWxlXG4gICAgOiBpc1JlZ2V4KHJ1bGUpXG4gICAgICAgID8gcnVsZS5zb3VyY2VcbiAgICAgICAgOiBpc09iamVjdChydWxlKVxuICAgICAgICAgICAgPyBpc1JlZ2V4KHJ1bGUudmFsdWUpXG4gICAgICAgICAgICAgICAgPyBydWxlLnZhbHVlLnNvdXJjZVxuICAgICAgICAgICAgICAgIDogcnVsZS52YWx1ZVxuICAgICAgICAgICAgOiBydWxlO1xuXG52YXIgZ2V0VmFsaWRhdGlvbk1vZGVzID0gKG1vZGUpID0+ICh7XG4gICAgaXNPblN1Ym1pdDogIW1vZGUgfHwgbW9kZSA9PT0gVkFMSURBVElPTl9NT0RFLm9uU3VibWl0LFxuICAgIGlzT25CbHVyOiBtb2RlID09PSBWQUxJREFUSU9OX01PREUub25CbHVyLFxuICAgIGlzT25DaGFuZ2U6IG1vZGUgPT09IFZBTElEQVRJT05fTU9ERS5vbkNoYW5nZSxcbiAgICBpc09uQWxsOiBtb2RlID09PSBWQUxJREFUSU9OX01PREUuYWxsLFxuICAgIGlzT25Ub3VjaDogbW9kZSA9PT0gVkFMSURBVElPTl9NT0RFLm9uVG91Y2hlZCxcbn0pO1xuXG5jb25zdCBBU1lOQ19GVU5DVElPTiA9ICdBc3luY0Z1bmN0aW9uJztcbnZhciBoYXNQcm9taXNlVmFsaWRhdGlvbiA9IChmaWVsZFJlZmVyZW5jZSkgPT4gISFmaWVsZFJlZmVyZW5jZSAmJlxuICAgICEhZmllbGRSZWZlcmVuY2UudmFsaWRhdGUgJiZcbiAgICAhISgoaXNGdW5jdGlvbihmaWVsZFJlZmVyZW5jZS52YWxpZGF0ZSkgJiZcbiAgICAgICAgZmllbGRSZWZlcmVuY2UudmFsaWRhdGUuY29uc3RydWN0b3IubmFtZSA9PT0gQVNZTkNfRlVOQ1RJT04pIHx8XG4gICAgICAgIChpc09iamVjdChmaWVsZFJlZmVyZW5jZS52YWxpZGF0ZSkgJiZcbiAgICAgICAgICAgIE9iamVjdC52YWx1ZXMoZmllbGRSZWZlcmVuY2UudmFsaWRhdGUpLmZpbmQoKHZhbGlkYXRlRnVuY3Rpb24pID0+IHZhbGlkYXRlRnVuY3Rpb24uY29uc3RydWN0b3IubmFtZSA9PT0gQVNZTkNfRlVOQ1RJT04pKSk7XG5cbnZhciBoYXNWYWxpZGF0aW9uID0gKG9wdGlvbnMpID0+IG9wdGlvbnMubW91bnQgJiZcbiAgICAob3B0aW9ucy5yZXF1aXJlZCB8fFxuICAgICAgICBvcHRpb25zLm1pbiB8fFxuICAgICAgICBvcHRpb25zLm1heCB8fFxuICAgICAgICBvcHRpb25zLm1heExlbmd0aCB8fFxuICAgICAgICBvcHRpb25zLm1pbkxlbmd0aCB8fFxuICAgICAgICBvcHRpb25zLnBhdHRlcm4gfHxcbiAgICAgICAgb3B0aW9ucy52YWxpZGF0ZSk7XG5cbnZhciBpc1dhdGNoZWQgPSAobmFtZSwgX25hbWVzLCBpc0JsdXJFdmVudCkgPT4gIWlzQmx1ckV2ZW50ICYmXG4gICAgKF9uYW1lcy53YXRjaEFsbCB8fFxuICAgICAgICBfbmFtZXMud2F0Y2guaGFzKG5hbWUpIHx8XG4gICAgICAgIFsuLi5fbmFtZXMud2F0Y2hdLnNvbWUoKHdhdGNoTmFtZSkgPT4gbmFtZS5zdGFydHNXaXRoKHdhdGNoTmFtZSkgJiZcbiAgICAgICAgICAgIC9eXFwuXFx3Ky8udGVzdChuYW1lLnNsaWNlKHdhdGNoTmFtZS5sZW5ndGgpKSkpO1xuXG5jb25zdCBpdGVyYXRlRmllbGRzQnlBY3Rpb24gPSAoZmllbGRzLCBhY3Rpb24sIGZpZWxkc05hbWVzLCBhYm9ydEVhcmx5KSA9PiB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgZmllbGRzTmFtZXMgfHwgT2JqZWN0LmtleXMoZmllbGRzKSkge1xuICAgICAgICBjb25zdCBmaWVsZCA9IGdldChmaWVsZHMsIGtleSk7XG4gICAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICAgICAgY29uc3QgeyBfZiwgLi4uY3VycmVudEZpZWxkIH0gPSBmaWVsZDtcbiAgICAgICAgICAgIGlmIChfZikge1xuICAgICAgICAgICAgICAgIGlmIChfZi5yZWZzICYmIF9mLnJlZnNbMF0gJiYgYWN0aW9uKF9mLnJlZnNbMF0sIGtleSkgJiYgIWFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKF9mLnJlZiAmJiBhY3Rpb24oX2YucmVmLCBfZi5uYW1lKSAmJiAhYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVyYXRlRmllbGRzQnlBY3Rpb24oY3VycmVudEZpZWxkLCBhY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KGN1cnJlbnRGaWVsZCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlcmF0ZUZpZWxkc0J5QWN0aW9uKGN1cnJlbnRGaWVsZCwgYWN0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuO1xufTtcblxuZnVuY3Rpb24gc2NoZW1hRXJyb3JMb29rdXAoZXJyb3JzLCBfZmllbGRzLCBuYW1lKSB7XG4gICAgY29uc3QgZXJyb3IgPSBnZXQoZXJyb3JzLCBuYW1lKTtcbiAgICBpZiAoZXJyb3IgfHwgaXNLZXkobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgbmFtZXMgPSBuYW1lLnNwbGl0KCcuJyk7XG4gICAgd2hpbGUgKG5hbWVzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBmaWVsZE5hbWUgPSBuYW1lcy5qb2luKCcuJyk7XG4gICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KF9maWVsZHMsIGZpZWxkTmFtZSk7XG4gICAgICAgIGNvbnN0IGZvdW5kRXJyb3IgPSBnZXQoZXJyb3JzLCBmaWVsZE5hbWUpO1xuICAgICAgICBpZiAoZmllbGQgJiYgIUFycmF5LmlzQXJyYXkoZmllbGQpICYmIG5hbWUgIT09IGZpZWxkTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgbmFtZSB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3VuZEVycm9yICYmIGZvdW5kRXJyb3IudHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBmaWVsZE5hbWUsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGZvdW5kRXJyb3IsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3VuZEVycm9yICYmIGZvdW5kRXJyb3Iucm9vdCAmJiBmb3VuZEVycm9yLnJvb3QudHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBgJHtmaWVsZE5hbWV9LnJvb3RgLFxuICAgICAgICAgICAgICAgIGVycm9yOiBmb3VuZEVycm9yLnJvb3QsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIG5hbWVzLnBvcCgpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lLFxuICAgIH07XG59XG5cbnZhciBzaG91bGRSZW5kZXJGb3JtU3RhdGUgPSAoZm9ybVN0YXRlRGF0YSwgX3Byb3h5Rm9ybVN0YXRlLCB1cGRhdGVGb3JtU3RhdGUsIGlzUm9vdCkgPT4ge1xuICAgIHVwZGF0ZUZvcm1TdGF0ZShmb3JtU3RhdGVEYXRhKTtcbiAgICBjb25zdCB7IG5hbWUsIC4uLmZvcm1TdGF0ZSB9ID0gZm9ybVN0YXRlRGF0YTtcbiAgICByZXR1cm4gKGlzRW1wdHlPYmplY3QoZm9ybVN0YXRlKSB8fFxuICAgICAgICBPYmplY3Qua2V5cyhmb3JtU3RhdGUpLmxlbmd0aCA+PSBPYmplY3Qua2V5cyhfcHJveHlGb3JtU3RhdGUpLmxlbmd0aCB8fFxuICAgICAgICBPYmplY3Qua2V5cyhmb3JtU3RhdGUpLmZpbmQoKGtleSkgPT4gX3Byb3h5Rm9ybVN0YXRlW2tleV0gPT09XG4gICAgICAgICAgICAoIWlzUm9vdCB8fCBWQUxJREFUSU9OX01PREUuYWxsKSkpO1xufTtcblxudmFyIHNob3VsZFN1YnNjcmliZUJ5TmFtZSA9IChuYW1lLCBzaWduYWxOYW1lLCBleGFjdCkgPT4gIW5hbWUgfHxcbiAgICAhc2lnbmFsTmFtZSB8fFxuICAgIG5hbWUgPT09IHNpZ25hbE5hbWUgfHxcbiAgICBjb252ZXJ0VG9BcnJheVBheWxvYWQobmFtZSkuc29tZSgoY3VycmVudE5hbWUpID0+IGN1cnJlbnROYW1lICYmXG4gICAgICAgIChleGFjdFxuICAgICAgICAgICAgPyBjdXJyZW50TmFtZSA9PT0gc2lnbmFsTmFtZVxuICAgICAgICAgICAgOiBjdXJyZW50TmFtZS5zdGFydHNXaXRoKHNpZ25hbE5hbWUpIHx8XG4gICAgICAgICAgICAgICAgc2lnbmFsTmFtZS5zdGFydHNXaXRoKGN1cnJlbnROYW1lKSkpO1xuXG52YXIgc2tpcFZhbGlkYXRpb24gPSAoaXNCbHVyRXZlbnQsIGlzVG91Y2hlZCwgaXNTdWJtaXR0ZWQsIHJlVmFsaWRhdGVNb2RlLCBtb2RlKSA9PiB7XG4gICAgaWYgKG1vZGUuaXNPbkFsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFpc1N1Ym1pdHRlZCAmJiBtb2RlLmlzT25Ub3VjaCkge1xuICAgICAgICByZXR1cm4gIShpc1RvdWNoZWQgfHwgaXNCbHVyRXZlbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1N1Ym1pdHRlZCA/IHJlVmFsaWRhdGVNb2RlLmlzT25CbHVyIDogbW9kZS5pc09uQmx1cikge1xuICAgICAgICByZXR1cm4gIWlzQmx1ckV2ZW50O1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1N1Ym1pdHRlZCA/IHJlVmFsaWRhdGVNb2RlLmlzT25DaGFuZ2UgOiBtb2RlLmlzT25DaGFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIGlzQmx1ckV2ZW50O1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciB1bnNldEVtcHR5QXJyYXkgPSAocmVmLCBuYW1lKSA9PiAhY29tcGFjdChnZXQocmVmLCBuYW1lKSkubGVuZ3RoICYmIHVuc2V0KHJlZiwgbmFtZSk7XG5cbnZhciB1cGRhdGVGaWVsZEFycmF5Um9vdEVycm9yID0gKGVycm9ycywgZXJyb3IsIG5hbWUpID0+IHtcbiAgICBjb25zdCBmaWVsZEFycmF5RXJyb3JzID0gY29udmVydFRvQXJyYXlQYXlsb2FkKGdldChlcnJvcnMsIG5hbWUpKTtcbiAgICBzZXQoZmllbGRBcnJheUVycm9ycywgJ3Jvb3QnLCBlcnJvcltuYW1lXSk7XG4gICAgc2V0KGVycm9ycywgbmFtZSwgZmllbGRBcnJheUVycm9ycyk7XG4gICAgcmV0dXJuIGVycm9ycztcbn07XG5cbmZ1bmN0aW9uIGdldFZhbGlkYXRlRXJyb3IocmVzdWx0LCByZWYsIHR5cGUgPSAndmFsaWRhdGUnKSB7XG4gICAgaWYgKGlzU3RyaW5nKHJlc3VsdCkgfHxcbiAgICAgICAgKEFycmF5LmlzQXJyYXkocmVzdWx0KSAmJiByZXN1bHQuZXZlcnkoaXNTdHJpbmcpKSB8fFxuICAgICAgICAoaXNCb29sZWFuKHJlc3VsdCkgJiYgIXJlc3VsdCkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBtZXNzYWdlOiBpc1N0cmluZyhyZXN1bHQpID8gcmVzdWx0IDogJycsXG4gICAgICAgICAgICByZWYsXG4gICAgICAgIH07XG4gICAgfVxufVxuXG52YXIgZ2V0VmFsdWVBbmRNZXNzYWdlID0gKHZhbGlkYXRpb25EYXRhKSA9PiBpc09iamVjdCh2YWxpZGF0aW9uRGF0YSkgJiYgIWlzUmVnZXgodmFsaWRhdGlvbkRhdGEpXG4gICAgPyB2YWxpZGF0aW9uRGF0YVxuICAgIDoge1xuICAgICAgICB2YWx1ZTogdmFsaWRhdGlvbkRhdGEsXG4gICAgICAgIG1lc3NhZ2U6ICcnLFxuICAgIH07XG5cbnZhciB2YWxpZGF0ZUZpZWxkID0gYXN5bmMgKGZpZWxkLCBkaXNhYmxlZEZpZWxkTmFtZXMsIGZvcm1WYWx1ZXMsIHZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSwgc2hvdWxkVXNlTmF0aXZlVmFsaWRhdGlvbiwgaXNGaWVsZEFycmF5KSA9PiB7XG4gICAgY29uc3QgeyByZWYsIHJlZnMsIHJlcXVpcmVkLCBtYXhMZW5ndGgsIG1pbkxlbmd0aCwgbWluLCBtYXgsIHBhdHRlcm4sIHZhbGlkYXRlLCBuYW1lLCB2YWx1ZUFzTnVtYmVyLCBtb3VudCwgfSA9IGZpZWxkLl9mO1xuICAgIGNvbnN0IGlucHV0VmFsdWUgPSBnZXQoZm9ybVZhbHVlcywgbmFtZSk7XG4gICAgaWYgKCFtb3VudCB8fCBkaXNhYmxlZEZpZWxkTmFtZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgY29uc3QgaW5wdXRSZWYgPSByZWZzID8gcmVmc1swXSA6IHJlZjtcbiAgICBjb25zdCBzZXRDdXN0b21WYWxpZGl0eSA9IChtZXNzYWdlKSA9PiB7XG4gICAgICAgIGlmIChzaG91bGRVc2VOYXRpdmVWYWxpZGF0aW9uICYmIGlucHV0UmVmLnJlcG9ydFZhbGlkaXR5KSB7XG4gICAgICAgICAgICBpbnB1dFJlZi5zZXRDdXN0b21WYWxpZGl0eShpc0Jvb2xlYW4obWVzc2FnZSkgPyAnJyA6IG1lc3NhZ2UgfHwgJycpO1xuICAgICAgICAgICAgaW5wdXRSZWYucmVwb3J0VmFsaWRpdHkoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZXJyb3IgPSB7fTtcbiAgICBjb25zdCBpc1JhZGlvID0gaXNSYWRpb0lucHV0KHJlZik7XG4gICAgY29uc3QgaXNDaGVja0JveCA9IGlzQ2hlY2tCb3hJbnB1dChyZWYpO1xuICAgIGNvbnN0IGlzUmFkaW9PckNoZWNrYm94ID0gaXNSYWRpbyB8fCBpc0NoZWNrQm94O1xuICAgIGNvbnN0IGlzRW1wdHkgPSAoKHZhbHVlQXNOdW1iZXIgfHwgaXNGaWxlSW5wdXQocmVmKSkgJiZcbiAgICAgICAgaXNVbmRlZmluZWQocmVmLnZhbHVlKSAmJlxuICAgICAgICBpc1VuZGVmaW5lZChpbnB1dFZhbHVlKSkgfHxcbiAgICAgICAgKGlzSFRNTEVsZW1lbnQocmVmKSAmJiByZWYudmFsdWUgPT09ICcnKSB8fFxuICAgICAgICBpbnB1dFZhbHVlID09PSAnJyB8fFxuICAgICAgICAoQXJyYXkuaXNBcnJheShpbnB1dFZhbHVlKSAmJiAhaW5wdXRWYWx1ZS5sZW5ndGgpO1xuICAgIGNvbnN0IGFwcGVuZEVycm9yc0N1cnJ5ID0gYXBwZW5kRXJyb3JzLmJpbmQobnVsbCwgbmFtZSwgdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhLCBlcnJvcik7XG4gICAgY29uc3QgZ2V0TWluTWF4TWVzc2FnZSA9IChleGNlZWRNYXgsIG1heExlbmd0aE1lc3NhZ2UsIG1pbkxlbmd0aE1lc3NhZ2UsIG1heFR5cGUgPSBJTlBVVF9WQUxJREFUSU9OX1JVTEVTLm1heExlbmd0aCwgbWluVHlwZSA9IElOUFVUX1ZBTElEQVRJT05fUlVMRVMubWluTGVuZ3RoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBleGNlZWRNYXggPyBtYXhMZW5ndGhNZXNzYWdlIDogbWluTGVuZ3RoTWVzc2FnZTtcbiAgICAgICAgZXJyb3JbbmFtZV0gPSB7XG4gICAgICAgICAgICB0eXBlOiBleGNlZWRNYXggPyBtYXhUeXBlIDogbWluVHlwZSxcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICByZWYsXG4gICAgICAgICAgICAuLi5hcHBlbmRFcnJvcnNDdXJyeShleGNlZWRNYXggPyBtYXhUeXBlIDogbWluVHlwZSwgbWVzc2FnZSksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBpZiAoaXNGaWVsZEFycmF5XG4gICAgICAgID8gIUFycmF5LmlzQXJyYXkoaW5wdXRWYWx1ZSkgfHwgIWlucHV0VmFsdWUubGVuZ3RoXG4gICAgICAgIDogcmVxdWlyZWQgJiZcbiAgICAgICAgICAgICgoIWlzUmFkaW9PckNoZWNrYm94ICYmIChpc0VtcHR5IHx8IGlzTnVsbE9yVW5kZWZpbmVkKGlucHV0VmFsdWUpKSkgfHxcbiAgICAgICAgICAgICAgICAoaXNCb29sZWFuKGlucHV0VmFsdWUpICYmICFpbnB1dFZhbHVlKSB8fFxuICAgICAgICAgICAgICAgIChpc0NoZWNrQm94ICYmICFnZXRDaGVja2JveFZhbHVlKHJlZnMpLmlzVmFsaWQpIHx8XG4gICAgICAgICAgICAgICAgKGlzUmFkaW8gJiYgIWdldFJhZGlvVmFsdWUocmVmcykuaXNWYWxpZCkpKSB7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUsIG1lc3NhZ2UgfSA9IGlzU3RyaW5nKHJlcXVpcmVkKVxuICAgICAgICAgICAgPyB7IHZhbHVlOiAhIXJlcXVpcmVkLCBtZXNzYWdlOiByZXF1aXJlZCB9XG4gICAgICAgICAgICA6IGdldFZhbHVlQW5kTWVzc2FnZShyZXF1aXJlZCk7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgZXJyb3JbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogSU5QVVRfVkFMSURBVElPTl9SVUxFUy5yZXF1aXJlZCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICAgIHJlZjogaW5wdXRSZWYsXG4gICAgICAgICAgICAgICAgLi4uYXBwZW5kRXJyb3JzQ3VycnkoSU5QVVRfVkFMSURBVElPTl9SVUxFUy5yZXF1aXJlZCwgbWVzc2FnZSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEpIHtcbiAgICAgICAgICAgICAgICBzZXRDdXN0b21WYWxpZGl0eShtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpc0VtcHR5ICYmICghaXNOdWxsT3JVbmRlZmluZWQobWluKSB8fCAhaXNOdWxsT3JVbmRlZmluZWQobWF4KSkpIHtcbiAgICAgICAgbGV0IGV4Y2VlZE1heDtcbiAgICAgICAgbGV0IGV4Y2VlZE1pbjtcbiAgICAgICAgY29uc3QgbWF4T3V0cHV0ID0gZ2V0VmFsdWVBbmRNZXNzYWdlKG1heCk7XG4gICAgICAgIGNvbnN0IG1pbk91dHB1dCA9IGdldFZhbHVlQW5kTWVzc2FnZShtaW4pO1xuICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKGlucHV0VmFsdWUpICYmICFpc05hTihpbnB1dFZhbHVlKSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWVOdW1iZXIgPSByZWYudmFsdWVBc051bWJlciB8fFxuICAgICAgICAgICAgICAgIChpbnB1dFZhbHVlID8gK2lucHV0VmFsdWUgOiBpbnB1dFZhbHVlKTtcbiAgICAgICAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQobWF4T3V0cHV0LnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGV4Y2VlZE1heCA9IHZhbHVlTnVtYmVyID4gbWF4T3V0cHV0LnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChtaW5PdXRwdXQudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZXhjZWVkTWluID0gdmFsdWVOdW1iZXIgPCBtaW5PdXRwdXQudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZURhdGUgPSByZWYudmFsdWVBc0RhdGUgfHwgbmV3IERhdGUoaW5wdXRWYWx1ZSk7XG4gICAgICAgICAgICBjb25zdCBjb252ZXJ0VGltZVRvRGF0ZSA9ICh0aW1lKSA9PiBuZXcgRGF0ZShuZXcgRGF0ZSgpLnRvRGF0ZVN0cmluZygpICsgJyAnICsgdGltZSk7XG4gICAgICAgICAgICBjb25zdCBpc1RpbWUgPSByZWYudHlwZSA9PSAndGltZSc7XG4gICAgICAgICAgICBjb25zdCBpc1dlZWsgPSByZWYudHlwZSA9PSAnd2Vlayc7XG4gICAgICAgICAgICBpZiAoaXNTdHJpbmcobWF4T3V0cHV0LnZhbHVlKSAmJiBpbnB1dFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZXhjZWVkTWF4ID0gaXNUaW1lXG4gICAgICAgICAgICAgICAgICAgID8gY29udmVydFRpbWVUb0RhdGUoaW5wdXRWYWx1ZSkgPiBjb252ZXJ0VGltZVRvRGF0ZShtYXhPdXRwdXQudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIDogaXNXZWVrXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGlucHV0VmFsdWUgPiBtYXhPdXRwdXQudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdmFsdWVEYXRlID4gbmV3IERhdGUobWF4T3V0cHV0LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmluZyhtaW5PdXRwdXQudmFsdWUpICYmIGlucHV0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBleGNlZWRNaW4gPSBpc1RpbWVcbiAgICAgICAgICAgICAgICAgICAgPyBjb252ZXJ0VGltZVRvRGF0ZShpbnB1dFZhbHVlKSA8IGNvbnZlcnRUaW1lVG9EYXRlKG1pbk91dHB1dC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgOiBpc1dlZWtcbiAgICAgICAgICAgICAgICAgICAgICAgID8gaW5wdXRWYWx1ZSA8IG1pbk91dHB1dC52YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZURhdGUgPCBuZXcgRGF0ZShtaW5PdXRwdXQudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChleGNlZWRNYXggfHwgZXhjZWVkTWluKSB7XG4gICAgICAgICAgICBnZXRNaW5NYXhNZXNzYWdlKCEhZXhjZWVkTWF4LCBtYXhPdXRwdXQubWVzc2FnZSwgbWluT3V0cHV0Lm1lc3NhZ2UsIElOUFVUX1ZBTElEQVRJT05fUlVMRVMubWF4LCBJTlBVVF9WQUxJREFUSU9OX1JVTEVTLm1pbik7XG4gICAgICAgICAgICBpZiAoIXZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSkge1xuICAgICAgICAgICAgICAgIHNldEN1c3RvbVZhbGlkaXR5KGVycm9yW25hbWVdLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoKG1heExlbmd0aCB8fCBtaW5MZW5ndGgpICYmXG4gICAgICAgICFpc0VtcHR5ICYmXG4gICAgICAgIChpc1N0cmluZyhpbnB1dFZhbHVlKSB8fCAoaXNGaWVsZEFycmF5ICYmIEFycmF5LmlzQXJyYXkoaW5wdXRWYWx1ZSkpKSkge1xuICAgICAgICBjb25zdCBtYXhMZW5ndGhPdXRwdXQgPSBnZXRWYWx1ZUFuZE1lc3NhZ2UobWF4TGVuZ3RoKTtcbiAgICAgICAgY29uc3QgbWluTGVuZ3RoT3V0cHV0ID0gZ2V0VmFsdWVBbmRNZXNzYWdlKG1pbkxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGV4Y2VlZE1heCA9ICFpc051bGxPclVuZGVmaW5lZChtYXhMZW5ndGhPdXRwdXQudmFsdWUpICYmXG4gICAgICAgICAgICBpbnB1dFZhbHVlLmxlbmd0aCA+ICttYXhMZW5ndGhPdXRwdXQudmFsdWU7XG4gICAgICAgIGNvbnN0IGV4Y2VlZE1pbiA9ICFpc051bGxPclVuZGVmaW5lZChtaW5MZW5ndGhPdXRwdXQudmFsdWUpICYmXG4gICAgICAgICAgICBpbnB1dFZhbHVlLmxlbmd0aCA8ICttaW5MZW5ndGhPdXRwdXQudmFsdWU7XG4gICAgICAgIGlmIChleGNlZWRNYXggfHwgZXhjZWVkTWluKSB7XG4gICAgICAgICAgICBnZXRNaW5NYXhNZXNzYWdlKGV4Y2VlZE1heCwgbWF4TGVuZ3RoT3V0cHV0Lm1lc3NhZ2UsIG1pbkxlbmd0aE91dHB1dC5tZXNzYWdlKTtcbiAgICAgICAgICAgIGlmICghdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhKSB7XG4gICAgICAgICAgICAgICAgc2V0Q3VzdG9tVmFsaWRpdHkoZXJyb3JbbmFtZV0ubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwYXR0ZXJuICYmICFpc0VtcHR5ICYmIGlzU3RyaW5nKGlucHV0VmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IHsgdmFsdWU6IHBhdHRlcm5WYWx1ZSwgbWVzc2FnZSB9ID0gZ2V0VmFsdWVBbmRNZXNzYWdlKHBhdHRlcm4pO1xuICAgICAgICBpZiAoaXNSZWdleChwYXR0ZXJuVmFsdWUpICYmICFpbnB1dFZhbHVlLm1hdGNoKHBhdHRlcm5WYWx1ZSkpIHtcbiAgICAgICAgICAgIGVycm9yW25hbWVdID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IElOUFVUX1ZBTElEQVRJT05fUlVMRVMucGF0dGVybixcbiAgICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICAgIHJlZixcbiAgICAgICAgICAgICAgICAuLi5hcHBlbmRFcnJvcnNDdXJyeShJTlBVVF9WQUxJREFUSU9OX1JVTEVTLnBhdHRlcm4sIG1lc3NhZ2UpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICghdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhKSB7XG4gICAgICAgICAgICAgICAgc2V0Q3VzdG9tVmFsaWRpdHkobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh2YWxpZGF0ZSkge1xuICAgICAgICBpZiAoaXNGdW5jdGlvbih2YWxpZGF0ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZhbGlkYXRlKGlucHV0VmFsdWUsIGZvcm1WYWx1ZXMpO1xuICAgICAgICAgICAgY29uc3QgdmFsaWRhdGVFcnJvciA9IGdldFZhbGlkYXRlRXJyb3IocmVzdWx0LCBpbnB1dFJlZik7XG4gICAgICAgICAgICBpZiAodmFsaWRhdGVFcnJvcikge1xuICAgICAgICAgICAgICAgIGVycm9yW25hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi52YWxpZGF0ZUVycm9yLFxuICAgICAgICAgICAgICAgICAgICAuLi5hcHBlbmRFcnJvcnNDdXJyeShJTlBVVF9WQUxJREFUSU9OX1JVTEVTLnZhbGlkYXRlLCB2YWxpZGF0ZUVycm9yLm1lc3NhZ2UpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0Q3VzdG9tVmFsaWRpdHkodmFsaWRhdGVFcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc09iamVjdCh2YWxpZGF0ZSkpIHtcbiAgICAgICAgICAgIGxldCB2YWxpZGF0aW9uUmVzdWx0ID0ge307XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWxpZGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNFbXB0eU9iamVjdCh2YWxpZGF0aW9uUmVzdWx0KSAmJiAhdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB2YWxpZGF0ZUVycm9yID0gZ2V0VmFsaWRhdGVFcnJvcihhd2FpdCB2YWxpZGF0ZVtrZXldKGlucHV0VmFsdWUsIGZvcm1WYWx1ZXMpLCBpbnB1dFJlZiwga2V5KTtcbiAgICAgICAgICAgICAgICBpZiAodmFsaWRhdGVFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4udmFsaWRhdGVFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmFwcGVuZEVycm9yc0N1cnJ5KGtleSwgdmFsaWRhdGVFcnJvci5tZXNzYWdlKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgc2V0Q3VzdG9tVmFsaWRpdHkodmFsaWRhdGVFcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JbbmFtZV0gPSB2YWxpZGF0aW9uUmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0VtcHR5T2JqZWN0KHZhbGlkYXRpb25SZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZjogaW5wdXRSZWYsXG4gICAgICAgICAgICAgICAgICAgIC4uLnZhbGlkYXRpb25SZXN1bHQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNldEN1c3RvbVZhbGlkaXR5KHRydWUpO1xuICAgIHJldHVybiBlcnJvcjtcbn07XG5cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgIG1vZGU6IFZBTElEQVRJT05fTU9ERS5vblN1Ym1pdCxcbiAgICByZVZhbGlkYXRlTW9kZTogVkFMSURBVElPTl9NT0RFLm9uQ2hhbmdlLFxuICAgIHNob3VsZEZvY3VzRXJyb3I6IHRydWUsXG59O1xuZnVuY3Rpb24gY3JlYXRlRm9ybUNvbnRyb2wocHJvcHMgPSB7fSkge1xuICAgIGxldCBfb3B0aW9ucyA9IHtcbiAgICAgICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgICAgIC4uLnByb3BzLFxuICAgIH07XG4gICAgbGV0IF9mb3JtU3RhdGUgPSB7XG4gICAgICAgIHN1Ym1pdENvdW50OiAwLFxuICAgICAgICBpc0RpcnR5OiBmYWxzZSxcbiAgICAgICAgaXNSZWFkeTogZmFsc2UsXG4gICAgICAgIGlzTG9hZGluZzogaXNGdW5jdGlvbihfb3B0aW9ucy5kZWZhdWx0VmFsdWVzKSxcbiAgICAgICAgaXNWYWxpZGF0aW5nOiBmYWxzZSxcbiAgICAgICAgaXNTdWJtaXR0ZWQ6IGZhbHNlLFxuICAgICAgICBpc1N1Ym1pdHRpbmc6IGZhbHNlLFxuICAgICAgICBpc1N1Ym1pdFN1Y2Nlc3NmdWw6IGZhbHNlLFxuICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgdG91Y2hlZEZpZWxkczoge30sXG4gICAgICAgIGRpcnR5RmllbGRzOiB7fSxcbiAgICAgICAgdmFsaWRhdGluZ0ZpZWxkczoge30sXG4gICAgICAgIGVycm9yczogX29wdGlvbnMuZXJyb3JzIHx8IHt9LFxuICAgICAgICBkaXNhYmxlZDogX29wdGlvbnMuZGlzYWJsZWQgfHwgZmFsc2UsXG4gICAgfTtcbiAgICBsZXQgX2ZpZWxkcyA9IHt9O1xuICAgIGxldCBfZGVmYXVsdFZhbHVlcyA9IGlzT2JqZWN0KF9vcHRpb25zLmRlZmF1bHRWYWx1ZXMpIHx8IGlzT2JqZWN0KF9vcHRpb25zLnZhbHVlcylcbiAgICAgICAgPyBjbG9uZU9iamVjdChfb3B0aW9ucy5kZWZhdWx0VmFsdWVzIHx8IF9vcHRpb25zLnZhbHVlcykgfHwge31cbiAgICAgICAgOiB7fTtcbiAgICBsZXQgX2Zvcm1WYWx1ZXMgPSBfb3B0aW9ucy5zaG91bGRVbnJlZ2lzdGVyXG4gICAgICAgID8ge31cbiAgICAgICAgOiBjbG9uZU9iamVjdChfZGVmYXVsdFZhbHVlcyk7XG4gICAgbGV0IF9zdGF0ZSA9IHtcbiAgICAgICAgYWN0aW9uOiBmYWxzZSxcbiAgICAgICAgbW91bnQ6IGZhbHNlLFxuICAgICAgICB3YXRjaDogZmFsc2UsXG4gICAgfTtcbiAgICBsZXQgX25hbWVzID0ge1xuICAgICAgICBtb3VudDogbmV3IFNldCgpLFxuICAgICAgICBkaXNhYmxlZDogbmV3IFNldCgpLFxuICAgICAgICB1bk1vdW50OiBuZXcgU2V0KCksXG4gICAgICAgIGFycmF5OiBuZXcgU2V0KCksXG4gICAgICAgIHdhdGNoOiBuZXcgU2V0KCksXG4gICAgfTtcbiAgICBsZXQgZGVsYXlFcnJvckNhbGxiYWNrO1xuICAgIGxldCB0aW1lciA9IDA7XG4gICAgY29uc3QgX3Byb3h5Rm9ybVN0YXRlID0ge1xuICAgICAgICBpc0RpcnR5OiBmYWxzZSxcbiAgICAgICAgZGlydHlGaWVsZHM6IGZhbHNlLFxuICAgICAgICB2YWxpZGF0aW5nRmllbGRzOiBmYWxzZSxcbiAgICAgICAgdG91Y2hlZEZpZWxkczogZmFsc2UsXG4gICAgICAgIGlzVmFsaWRhdGluZzogZmFsc2UsXG4gICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgICBlcnJvcnM6IGZhbHNlLFxuICAgIH07XG4gICAgbGV0IF9wcm94eVN1YnNjcmliZUZvcm1TdGF0ZSA9IHtcbiAgICAgICAgLi4uX3Byb3h5Rm9ybVN0YXRlLFxuICAgIH07XG4gICAgY29uc3QgX3N1YmplY3RzID0ge1xuICAgICAgICBhcnJheTogY3JlYXRlU3ViamVjdCgpLFxuICAgICAgICBzdGF0ZTogY3JlYXRlU3ViamVjdCgpLFxuICAgIH07XG4gICAgY29uc3Qgc2hvdWxkRGlzcGxheUFsbEFzc29jaWF0ZWRFcnJvcnMgPSBfb3B0aW9ucy5jcml0ZXJpYU1vZGUgPT09IFZBTElEQVRJT05fTU9ERS5hbGw7XG4gICAgY29uc3QgZGVib3VuY2UgPSAoY2FsbGJhY2spID0+ICh3YWl0KSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dChjYWxsYmFjaywgd2FpdCk7XG4gICAgfTtcbiAgICBjb25zdCBfc2V0VmFsaWQgPSBhc3luYyAoc2hvdWxkVXBkYXRlVmFsaWQpID0+IHtcbiAgICAgICAgaWYgKCFfb3B0aW9ucy5kaXNhYmxlZCAmJlxuICAgICAgICAgICAgKF9wcm94eUZvcm1TdGF0ZS5pc1ZhbGlkIHx8XG4gICAgICAgICAgICAgICAgX3Byb3h5U3Vic2NyaWJlRm9ybVN0YXRlLmlzVmFsaWQgfHxcbiAgICAgICAgICAgICAgICBzaG91bGRVcGRhdGVWYWxpZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzVmFsaWQgPSBfb3B0aW9ucy5yZXNvbHZlclxuICAgICAgICAgICAgICAgID8gaXNFbXB0eU9iamVjdCgoYXdhaXQgX3J1blNjaGVtYSgpKS5lcnJvcnMpXG4gICAgICAgICAgICAgICAgOiBhd2FpdCBleGVjdXRlQnVpbHRJblZhbGlkYXRpb24oX2ZpZWxkcywgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZCAhPT0gX2Zvcm1TdGF0ZS5pc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBfdXBkYXRlSXNWYWxpZGF0aW5nID0gKG5hbWVzLCBpc1ZhbGlkYXRpbmcpID0+IHtcbiAgICAgICAgaWYgKCFfb3B0aW9ucy5kaXNhYmxlZCAmJlxuICAgICAgICAgICAgKF9wcm94eUZvcm1TdGF0ZS5pc1ZhbGlkYXRpbmcgfHxcbiAgICAgICAgICAgICAgICBfcHJveHlGb3JtU3RhdGUudmFsaWRhdGluZ0ZpZWxkcyB8fFxuICAgICAgICAgICAgICAgIF9wcm94eVN1YnNjcmliZUZvcm1TdGF0ZS5pc1ZhbGlkYXRpbmcgfHxcbiAgICAgICAgICAgICAgICBfcHJveHlTdWJzY3JpYmVGb3JtU3RhdGUudmFsaWRhdGluZ0ZpZWxkcykpIHtcbiAgICAgICAgICAgIChuYW1lcyB8fCBBcnJheS5mcm9tKF9uYW1lcy5tb3VudCkpLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkYXRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc2V0KF9mb3JtU3RhdGUudmFsaWRhdGluZ0ZpZWxkcywgbmFtZSwgaXNWYWxpZGF0aW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB1bnNldChfZm9ybVN0YXRlLnZhbGlkYXRpbmdGaWVsZHMsIG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgICAgIHZhbGlkYXRpbmdGaWVsZHM6IF9mb3JtU3RhdGUudmFsaWRhdGluZ0ZpZWxkcyxcbiAgICAgICAgICAgICAgICBpc1ZhbGlkYXRpbmc6ICFpc0VtcHR5T2JqZWN0KF9mb3JtU3RhdGUudmFsaWRhdGluZ0ZpZWxkcyksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgX3NldEZpZWxkQXJyYXkgPSAobmFtZSwgdmFsdWVzID0gW10sIG1ldGhvZCwgYXJncywgc2hvdWxkU2V0VmFsdWVzID0gdHJ1ZSwgc2hvdWxkVXBkYXRlRmllbGRzQW5kU3RhdGUgPSB0cnVlKSA9PiB7XG4gICAgICAgIGlmIChhcmdzICYmIG1ldGhvZCAmJiAhX29wdGlvbnMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIF9zdGF0ZS5hY3Rpb24gPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHNob3VsZFVwZGF0ZUZpZWxkc0FuZFN0YXRlICYmIEFycmF5LmlzQXJyYXkoZ2V0KF9maWVsZHMsIG5hbWUpKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkVmFsdWVzID0gbWV0aG9kKGdldChfZmllbGRzLCBuYW1lKSwgYXJncy5hcmdBLCBhcmdzLmFyZ0IpO1xuICAgICAgICAgICAgICAgIHNob3VsZFNldFZhbHVlcyAmJiBzZXQoX2ZpZWxkcywgbmFtZSwgZmllbGRWYWx1ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNob3VsZFVwZGF0ZUZpZWxkc0FuZFN0YXRlICYmXG4gICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShnZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUpKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9ycyA9IG1ldGhvZChnZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUpLCBhcmdzLmFyZ0EsIGFyZ3MuYXJnQik7XG4gICAgICAgICAgICAgICAgc2hvdWxkU2V0VmFsdWVzICYmIHNldChfZm9ybVN0YXRlLmVycm9ycywgbmFtZSwgZXJyb3JzKTtcbiAgICAgICAgICAgICAgICB1bnNldEVtcHR5QXJyYXkoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChfcHJveHlGb3JtU3RhdGUudG91Y2hlZEZpZWxkcyB8fFxuICAgICAgICAgICAgICAgIF9wcm94eVN1YnNjcmliZUZvcm1TdGF0ZS50b3VjaGVkRmllbGRzKSAmJlxuICAgICAgICAgICAgICAgIHNob3VsZFVwZGF0ZUZpZWxkc0FuZFN0YXRlICYmXG4gICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShnZXQoX2Zvcm1TdGF0ZS50b3VjaGVkRmllbGRzLCBuYW1lKSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b3VjaGVkRmllbGRzID0gbWV0aG9kKGdldChfZm9ybVN0YXRlLnRvdWNoZWRGaWVsZHMsIG5hbWUpLCBhcmdzLmFyZ0EsIGFyZ3MuYXJnQik7XG4gICAgICAgICAgICAgICAgc2hvdWxkU2V0VmFsdWVzICYmIHNldChfZm9ybVN0YXRlLnRvdWNoZWRGaWVsZHMsIG5hbWUsIHRvdWNoZWRGaWVsZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF9wcm94eUZvcm1TdGF0ZS5kaXJ0eUZpZWxkcyB8fCBfcHJveHlTdWJzY3JpYmVGb3JtU3RhdGUuZGlydHlGaWVsZHMpIHtcbiAgICAgICAgICAgICAgICBfZm9ybVN0YXRlLmRpcnR5RmllbGRzID0gZ2V0RGlydHlGaWVsZHMoX2RlZmF1bHRWYWx1ZXMsIF9mb3JtVmFsdWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIGlzRGlydHk6IF9nZXREaXJ0eShuYW1lLCB2YWx1ZXMpLFxuICAgICAgICAgICAgICAgIGRpcnR5RmllbGRzOiBfZm9ybVN0YXRlLmRpcnR5RmllbGRzLFxuICAgICAgICAgICAgICAgIGVycm9yczogX2Zvcm1TdGF0ZS5lcnJvcnMsXG4gICAgICAgICAgICAgICAgaXNWYWxpZDogX2Zvcm1TdGF0ZS5pc1ZhbGlkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXQoX2Zvcm1WYWx1ZXMsIG5hbWUsIHZhbHVlcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHVwZGF0ZUVycm9ycyA9IChuYW1lLCBlcnJvcikgPT4ge1xuICAgICAgICBzZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUsIGVycm9yKTtcbiAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgZXJyb3JzOiBfZm9ybVN0YXRlLmVycm9ycyxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBfc2V0RXJyb3JzID0gKGVycm9ycykgPT4ge1xuICAgICAgICBfZm9ybVN0YXRlLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgZXJyb3JzOiBfZm9ybVN0YXRlLmVycm9ycyxcbiAgICAgICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHVwZGF0ZVZhbGlkQW5kVmFsdWUgPSAobmFtZSwgc2hvdWxkU2tpcFNldFZhbHVlQXMsIHZhbHVlLCByZWYpID0+IHtcbiAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoX2ZpZWxkcywgbmFtZSk7XG4gICAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gZ2V0KF9mb3JtVmFsdWVzLCBuYW1lLCBpc1VuZGVmaW5lZCh2YWx1ZSkgPyBnZXQoX2RlZmF1bHRWYWx1ZXMsIG5hbWUpIDogdmFsdWUpO1xuICAgICAgICAgICAgaXNVbmRlZmluZWQoZGVmYXVsdFZhbHVlKSB8fFxuICAgICAgICAgICAgICAgIChyZWYgJiYgcmVmLmRlZmF1bHRDaGVja2VkKSB8fFxuICAgICAgICAgICAgICAgIHNob3VsZFNraXBTZXRWYWx1ZUFzXG4gICAgICAgICAgICAgICAgPyBzZXQoX2Zvcm1WYWx1ZXMsIG5hbWUsIHNob3VsZFNraXBTZXRWYWx1ZUFzID8gZGVmYXVsdFZhbHVlIDogZ2V0RmllbGRWYWx1ZShmaWVsZC5fZikpXG4gICAgICAgICAgICAgICAgOiBzZXRGaWVsZFZhbHVlKG5hbWUsIGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgICBfc3RhdGUubW91bnQgJiYgX3NldFZhbGlkKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHVwZGF0ZVRvdWNoQW5kRGlydHkgPSAobmFtZSwgZmllbGRWYWx1ZSwgaXNCbHVyRXZlbnQsIHNob3VsZERpcnR5LCBzaG91bGRSZW5kZXIpID0+IHtcbiAgICAgICAgbGV0IHNob3VsZFVwZGF0ZUZpZWxkID0gZmFsc2U7XG4gICAgICAgIGxldCBpc1ByZXZpb3VzRGlydHkgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0ge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFfb3B0aW9ucy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgaWYgKCFpc0JsdXJFdmVudCB8fCBzaG91bGREaXJ0eSkge1xuICAgICAgICAgICAgICAgIGlmIChfcHJveHlGb3JtU3RhdGUuaXNEaXJ0eSB8fCBfcHJveHlTdWJzY3JpYmVGb3JtU3RhdGUuaXNEaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICBpc1ByZXZpb3VzRGlydHkgPSBfZm9ybVN0YXRlLmlzRGlydHk7XG4gICAgICAgICAgICAgICAgICAgIF9mb3JtU3RhdGUuaXNEaXJ0eSA9IG91dHB1dC5pc0RpcnR5ID0gX2dldERpcnR5KCk7XG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFVwZGF0ZUZpZWxkID0gaXNQcmV2aW91c0RpcnR5ICE9PSBvdXRwdXQuaXNEaXJ0eTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaXNDdXJyZW50RmllbGRQcmlzdGluZSA9IGRlZXBFcXVhbChnZXQoX2RlZmF1bHRWYWx1ZXMsIG5hbWUpLCBmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgICAgICBpc1ByZXZpb3VzRGlydHkgPSAhIWdldChfZm9ybVN0YXRlLmRpcnR5RmllbGRzLCBuYW1lKTtcbiAgICAgICAgICAgICAgICBpc0N1cnJlbnRGaWVsZFByaXN0aW5lXG4gICAgICAgICAgICAgICAgICAgID8gdW5zZXQoX2Zvcm1TdGF0ZS5kaXJ0eUZpZWxkcywgbmFtZSlcbiAgICAgICAgICAgICAgICAgICAgOiBzZXQoX2Zvcm1TdGF0ZS5kaXJ0eUZpZWxkcywgbmFtZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgb3V0cHV0LmRpcnR5RmllbGRzID0gX2Zvcm1TdGF0ZS5kaXJ0eUZpZWxkcztcbiAgICAgICAgICAgICAgICBzaG91bGRVcGRhdGVGaWVsZCA9XG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFVwZGF0ZUZpZWxkIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoKF9wcm94eUZvcm1TdGF0ZS5kaXJ0eUZpZWxkcyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wcm94eVN1YnNjcmliZUZvcm1TdGF0ZS5kaXJ0eUZpZWxkcykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1ByZXZpb3VzRGlydHkgIT09ICFpc0N1cnJlbnRGaWVsZFByaXN0aW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0JsdXJFdmVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzUHJldmlvdXNGaWVsZFRvdWNoZWQgPSBnZXQoX2Zvcm1TdGF0ZS50b3VjaGVkRmllbGRzLCBuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzUHJldmlvdXNGaWVsZFRvdWNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0KF9mb3JtU3RhdGUudG91Y2hlZEZpZWxkcywgbmFtZSwgaXNCbHVyRXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQudG91Y2hlZEZpZWxkcyA9IF9mb3JtU3RhdGUudG91Y2hlZEZpZWxkcztcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkVXBkYXRlRmllbGQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkVXBkYXRlRmllbGQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKF9wcm94eUZvcm1TdGF0ZS50b3VjaGVkRmllbGRzIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wcm94eVN1YnNjcmliZUZvcm1TdGF0ZS50b3VjaGVkRmllbGRzKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1ByZXZpb3VzRmllbGRUb3VjaGVkICE9PSBpc0JsdXJFdmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2hvdWxkVXBkYXRlRmllbGQgJiYgc2hvdWxkUmVuZGVyICYmIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KG91dHB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNob3VsZFVwZGF0ZUZpZWxkID8gb3V0cHV0IDoge307XG4gICAgfTtcbiAgICBjb25zdCBzaG91bGRSZW5kZXJCeUVycm9yID0gKG5hbWUsIGlzVmFsaWQsIGVycm9yLCBmaWVsZFN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzRmllbGRFcnJvciA9IGdldChfZm9ybVN0YXRlLmVycm9ycywgbmFtZSk7XG4gICAgICAgIGNvbnN0IHNob3VsZFVwZGF0ZVZhbGlkID0gKF9wcm94eUZvcm1TdGF0ZS5pc1ZhbGlkIHx8IF9wcm94eVN1YnNjcmliZUZvcm1TdGF0ZS5pc1ZhbGlkKSAmJlxuICAgICAgICAgICAgaXNCb29sZWFuKGlzVmFsaWQpICYmXG4gICAgICAgICAgICBfZm9ybVN0YXRlLmlzVmFsaWQgIT09IGlzVmFsaWQ7XG4gICAgICAgIGlmIChfb3B0aW9ucy5kZWxheUVycm9yICYmIGVycm9yKSB7XG4gICAgICAgICAgICBkZWxheUVycm9yQ2FsbGJhY2sgPSBkZWJvdW5jZSgoKSA9PiB1cGRhdGVFcnJvcnMobmFtZSwgZXJyb3IpKTtcbiAgICAgICAgICAgIGRlbGF5RXJyb3JDYWxsYmFjayhfb3B0aW9ucy5kZWxheUVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICBkZWxheUVycm9yQ2FsbGJhY2sgPSBudWxsO1xuICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICAgICA/IHNldChfZm9ybVN0YXRlLmVycm9ycywgbmFtZSwgZXJyb3IpXG4gICAgICAgICAgICAgICAgOiB1bnNldChfZm9ybVN0YXRlLmVycm9ycywgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChlcnJvciA/ICFkZWVwRXF1YWwocHJldmlvdXNGaWVsZEVycm9yLCBlcnJvcikgOiBwcmV2aW91c0ZpZWxkRXJyb3IpIHx8XG4gICAgICAgICAgICAhaXNFbXB0eU9iamVjdChmaWVsZFN0YXRlKSB8fFxuICAgICAgICAgICAgc2hvdWxkVXBkYXRlVmFsaWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRGb3JtU3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgLi4uZmllbGRTdGF0ZSxcbiAgICAgICAgICAgICAgICAuLi4oc2hvdWxkVXBkYXRlVmFsaWQgJiYgaXNCb29sZWFuKGlzVmFsaWQpID8geyBpc1ZhbGlkIH0gOiB7fSksXG4gICAgICAgICAgICAgICAgZXJyb3JzOiBfZm9ybVN0YXRlLmVycm9ycyxcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9mb3JtU3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgLi4uX2Zvcm1TdGF0ZSxcbiAgICAgICAgICAgICAgICAuLi51cGRhdGVkRm9ybVN0YXRlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHVwZGF0ZWRGb3JtU3RhdGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBfcnVuU2NoZW1hID0gYXN5bmMgKG5hbWUpID0+IHtcbiAgICAgICAgX3VwZGF0ZUlzVmFsaWRhdGluZyhuYW1lLCB0cnVlKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgX29wdGlvbnMucmVzb2x2ZXIoX2Zvcm1WYWx1ZXMsIF9vcHRpb25zLmNvbnRleHQsIGdldFJlc29sdmVyT3B0aW9ucyhuYW1lIHx8IF9uYW1lcy5tb3VudCwgX2ZpZWxkcywgX29wdGlvbnMuY3JpdGVyaWFNb2RlLCBfb3B0aW9ucy5zaG91bGRVc2VOYXRpdmVWYWxpZGF0aW9uKSk7XG4gICAgICAgIF91cGRhdGVJc1ZhbGlkYXRpbmcobmFtZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBjb25zdCBleGVjdXRlU2NoZW1hQW5kVXBkYXRlU3RhdGUgPSBhc3luYyAobmFtZXMpID0+IHtcbiAgICAgICAgY29uc3QgeyBlcnJvcnMgfSA9IGF3YWl0IF9ydW5TY2hlbWEobmFtZXMpO1xuICAgICAgICBpZiAobmFtZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBuYW1lcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gZ2V0KGVycm9ycywgbmFtZSk7XG4gICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgPyBzZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUsIGVycm9yKVxuICAgICAgICAgICAgICAgICAgICA6IHVuc2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF9mb3JtU3RhdGUuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgfTtcbiAgICBjb25zdCBleGVjdXRlQnVpbHRJblZhbGlkYXRpb24gPSBhc3luYyAoZmllbGRzLCBzaG91bGRPbmx5Q2hlY2tWYWxpZCwgY29udGV4dCA9IHtcbiAgICAgICAgdmFsaWQ6IHRydWUsXG4gICAgfSkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZmllbGRzKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IGZpZWxkc1tuYW1lXTtcbiAgICAgICAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgX2YsIC4uLmZpZWxkVmFsdWUgfSA9IGZpZWxkO1xuICAgICAgICAgICAgICAgIGlmIChfZikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0ZpZWxkQXJyYXlSb290ID0gX25hbWVzLmFycmF5LmhhcyhfZi5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNQcm9taXNlRnVuY3Rpb24gPSBmaWVsZC5fZiAmJiBoYXNQcm9taXNlVmFsaWRhdGlvbihmaWVsZC5fZik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1Byb21pc2VGdW5jdGlvbiAmJiBfcHJveHlGb3JtU3RhdGUudmFsaWRhdGluZ0ZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3VwZGF0ZUlzVmFsaWRhdGluZyhbX2YubmFtZV0sIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkRXJyb3IgPSBhd2FpdCB2YWxpZGF0ZUZpZWxkKGZpZWxkLCBfbmFtZXMuZGlzYWJsZWQsIF9mb3JtVmFsdWVzLCBzaG91bGREaXNwbGF5QWxsQXNzb2NpYXRlZEVycm9ycywgX29wdGlvbnMuc2hvdWxkVXNlTmF0aXZlVmFsaWRhdGlvbiAmJiAhc2hvdWxkT25seUNoZWNrVmFsaWQsIGlzRmllbGRBcnJheVJvb3QpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNQcm9taXNlRnVuY3Rpb24gJiYgX3Byb3h5Rm9ybVN0YXRlLnZhbGlkYXRpbmdGaWVsZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF91cGRhdGVJc1ZhbGlkYXRpbmcoW19mLm5hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGRFcnJvcltfZi5uYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC52YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZE9ubHlDaGVja1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgIXNob3VsZE9ubHlDaGVja1ZhbGlkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoZ2V0KGZpZWxkRXJyb3IsIF9mLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBpc0ZpZWxkQXJyYXlSb290XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdXBkYXRlRmllbGRBcnJheVJvb3RFcnJvcihfZm9ybVN0YXRlLmVycm9ycywgZmllbGRFcnJvciwgX2YubmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBzZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIF9mLm5hbWUsIGZpZWxkRXJyb3JbX2YubmFtZV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bnNldChfZm9ybVN0YXRlLmVycm9ycywgX2YubmFtZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAhaXNFbXB0eU9iamVjdChmaWVsZFZhbHVlKSAmJlxuICAgICAgICAgICAgICAgICAgICAoYXdhaXQgZXhlY3V0ZUJ1aWx0SW5WYWxpZGF0aW9uKGZpZWxkVmFsdWUsIHNob3VsZE9ubHlDaGVja1ZhbGlkLCBjb250ZXh0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRleHQudmFsaWQ7XG4gICAgfTtcbiAgICBjb25zdCBfcmVtb3ZlVW5tb3VudGVkID0gKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgX25hbWVzLnVuTW91bnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KF9maWVsZHMsIG5hbWUpO1xuICAgICAgICAgICAgZmllbGQgJiZcbiAgICAgICAgICAgICAgICAoZmllbGQuX2YucmVmc1xuICAgICAgICAgICAgICAgICAgICA/IGZpZWxkLl9mLnJlZnMuZXZlcnkoKHJlZikgPT4gIWxpdmUocmVmKSlcbiAgICAgICAgICAgICAgICAgICAgOiAhbGl2ZShmaWVsZC5fZi5yZWYpKSAmJlxuICAgICAgICAgICAgICAgIHVucmVnaXN0ZXIobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgX25hbWVzLnVuTW91bnQgPSBuZXcgU2V0KCk7XG4gICAgfTtcbiAgICBjb25zdCBfZ2V0RGlydHkgPSAobmFtZSwgZGF0YSkgPT4gIV9vcHRpb25zLmRpc2FibGVkICYmXG4gICAgICAgIChuYW1lICYmIGRhdGEgJiYgc2V0KF9mb3JtVmFsdWVzLCBuYW1lLCBkYXRhKSxcbiAgICAgICAgICAgICFkZWVwRXF1YWwoZ2V0VmFsdWVzKCksIF9kZWZhdWx0VmFsdWVzKSk7XG4gICAgY29uc3QgX2dldFdhdGNoID0gKG5hbWVzLCBkZWZhdWx0VmFsdWUsIGlzR2xvYmFsKSA9PiBnZW5lcmF0ZVdhdGNoT3V0cHV0KG5hbWVzLCBfbmFtZXMsIHtcbiAgICAgICAgLi4uKF9zdGF0ZS5tb3VudFxuICAgICAgICAgICAgPyBfZm9ybVZhbHVlc1xuICAgICAgICAgICAgOiBpc1VuZGVmaW5lZChkZWZhdWx0VmFsdWUpXG4gICAgICAgICAgICAgICAgPyBfZGVmYXVsdFZhbHVlc1xuICAgICAgICAgICAgICAgIDogaXNTdHJpbmcobmFtZXMpXG4gICAgICAgICAgICAgICAgICAgID8geyBbbmFtZXNdOiBkZWZhdWx0VmFsdWUgfVxuICAgICAgICAgICAgICAgICAgICA6IGRlZmF1bHRWYWx1ZSksXG4gICAgfSwgaXNHbG9iYWwsIGRlZmF1bHRWYWx1ZSk7XG4gICAgY29uc3QgX2dldEZpZWxkQXJyYXkgPSAobmFtZSkgPT4gY29tcGFjdChnZXQoX3N0YXRlLm1vdW50ID8gX2Zvcm1WYWx1ZXMgOiBfZGVmYXVsdFZhbHVlcywgbmFtZSwgX29wdGlvbnMuc2hvdWxkVW5yZWdpc3RlciA/IGdldChfZGVmYXVsdFZhbHVlcywgbmFtZSwgW10pIDogW10pKTtcbiAgICBjb25zdCBzZXRGaWVsZFZhbHVlID0gKG5hbWUsIHZhbHVlLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoX2ZpZWxkcywgbmFtZSk7XG4gICAgICAgIGxldCBmaWVsZFZhbHVlID0gdmFsdWU7XG4gICAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICAgICAgY29uc3QgZmllbGRSZWZlcmVuY2UgPSBmaWVsZC5fZjtcbiAgICAgICAgICAgIGlmIChmaWVsZFJlZmVyZW5jZSkge1xuICAgICAgICAgICAgICAgICFmaWVsZFJlZmVyZW5jZS5kaXNhYmxlZCAmJlxuICAgICAgICAgICAgICAgICAgICBzZXQoX2Zvcm1WYWx1ZXMsIG5hbWUsIGdldEZpZWxkVmFsdWVBcyh2YWx1ZSwgZmllbGRSZWZlcmVuY2UpKTtcbiAgICAgICAgICAgICAgICBmaWVsZFZhbHVlID1cbiAgICAgICAgICAgICAgICAgICAgaXNIVE1MRWxlbWVudChmaWVsZFJlZmVyZW5jZS5yZWYpICYmIGlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyAnJ1xuICAgICAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoaXNNdWx0aXBsZVNlbGVjdChmaWVsZFJlZmVyZW5jZS5yZWYpKSB7XG4gICAgICAgICAgICAgICAgICAgIFsuLi5maWVsZFJlZmVyZW5jZS5yZWYub3B0aW9uc10uZm9yRWFjaCgob3B0aW9uUmVmKSA9PiAob3B0aW9uUmVmLnNlbGVjdGVkID0gZmllbGRWYWx1ZS5pbmNsdWRlcyhvcHRpb25SZWYudmFsdWUpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkUmVmZXJlbmNlLnJlZnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ2hlY2tCb3hJbnB1dChmaWVsZFJlZmVyZW5jZS5yZWYpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZFJlZmVyZW5jZS5yZWZzLmZvckVhY2goKGNoZWNrYm94UmVmKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGVja2JveFJlZi5kZWZhdWx0Q2hlY2tlZCB8fCAhY2hlY2tib3hSZWYuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZmllbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrYm94UmVmLmNoZWNrZWQgPSAhIWZpZWxkVmFsdWUuZmluZCgoZGF0YSkgPT4gZGF0YSA9PT0gY2hlY2tib3hSZWYudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tib3hSZWYuY2hlY2tlZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRWYWx1ZSA9PT0gY2hlY2tib3hSZWYudmFsdWUgfHwgISFmaWVsZFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZFJlZmVyZW5jZS5yZWZzLmZvckVhY2goKHJhZGlvUmVmKSA9PiAocmFkaW9SZWYuY2hlY2tlZCA9IHJhZGlvUmVmLnZhbHVlID09PSBmaWVsZFZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNGaWxlSW5wdXQoZmllbGRSZWZlcmVuY2UucmVmKSkge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZFJlZmVyZW5jZS5yZWYudmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkUmVmZXJlbmNlLnJlZi52YWx1ZSA9IGZpZWxkVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZmllbGRSZWZlcmVuY2UucmVmLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlczogY2xvbmVPYmplY3QoX2Zvcm1WYWx1ZXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKG9wdGlvbnMuc2hvdWxkRGlydHkgfHwgb3B0aW9ucy5zaG91bGRUb3VjaCkgJiZcbiAgICAgICAgICAgIHVwZGF0ZVRvdWNoQW5kRGlydHkobmFtZSwgZmllbGRWYWx1ZSwgb3B0aW9ucy5zaG91bGRUb3VjaCwgb3B0aW9ucy5zaG91bGREaXJ0eSwgdHJ1ZSk7XG4gICAgICAgIG9wdGlvbnMuc2hvdWxkVmFsaWRhdGUgJiYgdHJpZ2dlcihuYW1lKTtcbiAgICB9O1xuICAgIGNvbnN0IHNldFZhbHVlcyA9IChuYW1lLCB2YWx1ZSwgb3B0aW9ucykgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkS2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIXZhbHVlLmhhc093blByb3BlcnR5KGZpZWxkS2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZpZWxkVmFsdWUgPSB2YWx1ZVtmaWVsZEtleV07XG4gICAgICAgICAgICBjb25zdCBmaWVsZE5hbWUgPSBuYW1lICsgJy4nICsgZmllbGRLZXk7XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IGdldChfZmllbGRzLCBmaWVsZE5hbWUpO1xuICAgICAgICAgICAgKF9uYW1lcy5hcnJheS5oYXMobmFtZSkgfHxcbiAgICAgICAgICAgICAgICBpc09iamVjdChmaWVsZFZhbHVlKSB8fFxuICAgICAgICAgICAgICAgIChmaWVsZCAmJiAhZmllbGQuX2YpKSAmJlxuICAgICAgICAgICAgICAgICFpc0RhdGVPYmplY3QoZmllbGRWYWx1ZSlcbiAgICAgICAgICAgICAgICA/IHNldFZhbHVlcyhmaWVsZE5hbWUsIGZpZWxkVmFsdWUsIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgOiBzZXRGaWVsZFZhbHVlKGZpZWxkTmFtZSwgZmllbGRWYWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHNldFZhbHVlID0gKG5hbWUsIHZhbHVlLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoX2ZpZWxkcywgbmFtZSk7XG4gICAgICAgIGNvbnN0IGlzRmllbGRBcnJheSA9IF9uYW1lcy5hcnJheS5oYXMobmFtZSk7XG4gICAgICAgIGNvbnN0IGNsb25lVmFsdWUgPSBjbG9uZU9iamVjdCh2YWx1ZSk7XG4gICAgICAgIHNldChfZm9ybVZhbHVlcywgbmFtZSwgY2xvbmVWYWx1ZSk7XG4gICAgICAgIGlmIChpc0ZpZWxkQXJyYXkpIHtcbiAgICAgICAgICAgIF9zdWJqZWN0cy5hcnJheS5uZXh0KHtcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIHZhbHVlczogY2xvbmVPYmplY3QoX2Zvcm1WYWx1ZXMpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoKF9wcm94eUZvcm1TdGF0ZS5pc0RpcnR5IHx8XG4gICAgICAgICAgICAgICAgX3Byb3h5Rm9ybVN0YXRlLmRpcnR5RmllbGRzIHx8XG4gICAgICAgICAgICAgICAgX3Byb3h5U3Vic2NyaWJlRm9ybVN0YXRlLmlzRGlydHkgfHxcbiAgICAgICAgICAgICAgICBfcHJveHlTdWJzY3JpYmVGb3JtU3RhdGUuZGlydHlGaWVsZHMpICYmXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zaG91bGREaXJ0eSkge1xuICAgICAgICAgICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZGlydHlGaWVsZHM6IGdldERpcnR5RmllbGRzKF9kZWZhdWx0VmFsdWVzLCBfZm9ybVZhbHVlcyksXG4gICAgICAgICAgICAgICAgICAgIGlzRGlydHk6IF9nZXREaXJ0eShuYW1lLCBjbG9uZVZhbHVlKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZpZWxkICYmICFmaWVsZC5fZiAmJiAhaXNOdWxsT3JVbmRlZmluZWQoY2xvbmVWYWx1ZSlcbiAgICAgICAgICAgICAgICA/IHNldFZhbHVlcyhuYW1lLCBjbG9uZVZhbHVlLCBvcHRpb25zKVxuICAgICAgICAgICAgICAgIDogc2V0RmllbGRWYWx1ZShuYW1lLCBjbG9uZVZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpc1dhdGNoZWQobmFtZSwgX25hbWVzKSAmJiBfc3ViamVjdHMuc3RhdGUubmV4dCh7IC4uLl9mb3JtU3RhdGUsIG5hbWUgfSk7XG4gICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgIG5hbWU6IF9zdGF0ZS5tb3VudCA/IG5hbWUgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB2YWx1ZXM6IGNsb25lT2JqZWN0KF9mb3JtVmFsdWVzKSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBvbkNoYW5nZSA9IGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgICBfc3RhdGUubW91bnQgPSB0cnVlO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIGxldCBuYW1lID0gdGFyZ2V0Lm5hbWU7XG4gICAgICAgIGxldCBpc0ZpZWxkVmFsdWVVcGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoX2ZpZWxkcywgbmFtZSk7XG4gICAgICAgIGNvbnN0IF91cGRhdGVJc0ZpZWxkVmFsdWVVcGRhdGVkID0gKGZpZWxkVmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlzRmllbGRWYWx1ZVVwZGF0ZWQgPVxuICAgICAgICAgICAgICAgIE51bWJlci5pc05hTihmaWVsZFZhbHVlKSB8fFxuICAgICAgICAgICAgICAgICAgICAoaXNEYXRlT2JqZWN0KGZpZWxkVmFsdWUpICYmIGlzTmFOKGZpZWxkVmFsdWUuZ2V0VGltZSgpKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgZGVlcEVxdWFsKGZpZWxkVmFsdWUsIGdldChfZm9ybVZhbHVlcywgbmFtZSwgZmllbGRWYWx1ZSkpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB2YWxpZGF0aW9uTW9kZUJlZm9yZVN1Ym1pdCA9IGdldFZhbGlkYXRpb25Nb2Rlcyhfb3B0aW9ucy5tb2RlKTtcbiAgICAgICAgY29uc3QgdmFsaWRhdGlvbk1vZGVBZnRlclN1Ym1pdCA9IGdldFZhbGlkYXRpb25Nb2Rlcyhfb3B0aW9ucy5yZVZhbGlkYXRlTW9kZSk7XG4gICAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICAgICAgbGV0IGVycm9yO1xuICAgICAgICAgICAgbGV0IGlzVmFsaWQ7XG4gICAgICAgICAgICBjb25zdCBmaWVsZFZhbHVlID0gdGFyZ2V0LnR5cGVcbiAgICAgICAgICAgICAgICA/IGdldEZpZWxkVmFsdWUoZmllbGQuX2YpXG4gICAgICAgICAgICAgICAgOiBnZXRFdmVudFZhbHVlKGV2ZW50KTtcbiAgICAgICAgICAgIGNvbnN0IGlzQmx1ckV2ZW50ID0gZXZlbnQudHlwZSA9PT0gRVZFTlRTLkJMVVIgfHwgZXZlbnQudHlwZSA9PT0gRVZFTlRTLkZPQ1VTX09VVDtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZFNraXBWYWxpZGF0aW9uID0gKCFoYXNWYWxpZGF0aW9uKGZpZWxkLl9mKSAmJlxuICAgICAgICAgICAgICAgICFfb3B0aW9ucy5yZXNvbHZlciAmJlxuICAgICAgICAgICAgICAgICFnZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICAgIWZpZWxkLl9mLmRlcHMpIHx8XG4gICAgICAgICAgICAgICAgc2tpcFZhbGlkYXRpb24oaXNCbHVyRXZlbnQsIGdldChfZm9ybVN0YXRlLnRvdWNoZWRGaWVsZHMsIG5hbWUpLCBfZm9ybVN0YXRlLmlzU3VibWl0dGVkLCB2YWxpZGF0aW9uTW9kZUFmdGVyU3VibWl0LCB2YWxpZGF0aW9uTW9kZUJlZm9yZVN1Ym1pdCk7XG4gICAgICAgICAgICBjb25zdCB3YXRjaGVkID0gaXNXYXRjaGVkKG5hbWUsIF9uYW1lcywgaXNCbHVyRXZlbnQpO1xuICAgICAgICAgICAgc2V0KF9mb3JtVmFsdWVzLCBuYW1lLCBmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgIGlmIChpc0JsdXJFdmVudCkge1xuICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0IHx8ICF0YXJnZXQucmVhZE9ubHkpIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQuX2Yub25CbHVyICYmIGZpZWxkLl9mLm9uQmx1cihldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGF5RXJyb3JDYWxsYmFjayAmJiBkZWxheUVycm9yQ2FsbGJhY2soMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGQuX2Yub25DaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBmaWVsZC5fZi5vbkNoYW5nZShldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmaWVsZFN0YXRlID0gdXBkYXRlVG91Y2hBbmREaXJ0eShuYW1lLCBmaWVsZFZhbHVlLCBpc0JsdXJFdmVudCk7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRSZW5kZXIgPSAhaXNFbXB0eU9iamVjdChmaWVsZFN0YXRlKSB8fCB3YXRjaGVkO1xuICAgICAgICAgICAgIWlzQmx1ckV2ZW50ICYmXG4gICAgICAgICAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBldmVudC50eXBlLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IGNsb25lT2JqZWN0KF9mb3JtVmFsdWVzKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChzaG91bGRTa2lwVmFsaWRhdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChfcHJveHlGb3JtU3RhdGUuaXNWYWxpZCB8fCBfcHJveHlTdWJzY3JpYmVGb3JtU3RhdGUuaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX29wdGlvbnMubW9kZSA9PT0gJ29uQmx1cicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0JsdXJFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zZXRWYWxpZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpc0JsdXJFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3NldFZhbGlkKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIChzaG91bGRSZW5kZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoeyBuYW1lLCAuLi4od2F0Y2hlZCA/IHt9IDogZmllbGRTdGF0ZSkgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgIWlzQmx1ckV2ZW50ICYmIHdhdGNoZWQgJiYgX3N1YmplY3RzLnN0YXRlLm5leHQoeyAuLi5fZm9ybVN0YXRlIH0pO1xuICAgICAgICAgICAgaWYgKF9vcHRpb25zLnJlc29sdmVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlcnJvcnMgfSA9IGF3YWl0IF9ydW5TY2hlbWEoW25hbWVdKTtcbiAgICAgICAgICAgICAgICBfdXBkYXRlSXNGaWVsZFZhbHVlVXBkYXRlZChmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNGaWVsZFZhbHVlVXBkYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c0Vycm9yTG9va3VwUmVzdWx0ID0gc2NoZW1hRXJyb3JMb29rdXAoX2Zvcm1TdGF0ZS5lcnJvcnMsIF9maWVsZHMsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvckxvb2t1cFJlc3VsdCA9IHNjaGVtYUVycm9yTG9va3VwKGVycm9ycywgX2ZpZWxkcywgcHJldmlvdXNFcnJvckxvb2t1cFJlc3VsdC5uYW1lIHx8IG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBlcnJvciA9IGVycm9yTG9va3VwUmVzdWx0LmVycm9yO1xuICAgICAgICAgICAgICAgICAgICBuYW1lID0gZXJyb3JMb29rdXBSZXN1bHQubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgaXNWYWxpZCA9IGlzRW1wdHlPYmplY3QoZXJyb3JzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdXBkYXRlSXNWYWxpZGF0aW5nKFtuYW1lXSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSAoYXdhaXQgdmFsaWRhdGVGaWVsZChmaWVsZCwgX25hbWVzLmRpc2FibGVkLCBfZm9ybVZhbHVlcywgc2hvdWxkRGlzcGxheUFsbEFzc29jaWF0ZWRFcnJvcnMsIF9vcHRpb25zLnNob3VsZFVzZU5hdGl2ZVZhbGlkYXRpb24pKVtuYW1lXTtcbiAgICAgICAgICAgICAgICBfdXBkYXRlSXNWYWxpZGF0aW5nKFtuYW1lXSk7XG4gICAgICAgICAgICAgICAgX3VwZGF0ZUlzRmllbGRWYWx1ZVVwZGF0ZWQoZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRmllbGRWYWx1ZVVwZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoX3Byb3h5Rm9ybVN0YXRlLmlzVmFsaWQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9wcm94eVN1YnNjcmliZUZvcm1TdGF0ZS5pc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkID0gYXdhaXQgZXhlY3V0ZUJ1aWx0SW5WYWxpZGF0aW9uKF9maWVsZHMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRmllbGRWYWx1ZVVwZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICBmaWVsZC5fZi5kZXBzICYmXG4gICAgICAgICAgICAgICAgICAgICghQXJyYXkuaXNBcnJheShmaWVsZC5fZi5kZXBzKSB8fCBmaWVsZC5fZi5kZXBzLmxlbmd0aCA+IDApICYmXG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXIoZmllbGQuX2YuZGVwcyk7XG4gICAgICAgICAgICAgICAgc2hvdWxkUmVuZGVyQnlFcnJvcihuYW1lLCBpc1ZhbGlkLCBlcnJvciwgZmllbGRTdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IF9mb2N1c0lucHV0ID0gKHJlZiwga2V5KSA9PiB7XG4gICAgICAgIGlmIChnZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIGtleSkgJiYgcmVmLmZvY3VzKSB7XG4gICAgICAgICAgICByZWYuZm9jdXMoKTtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9O1xuICAgIGNvbnN0IHRyaWdnZXIgPSBhc3luYyAobmFtZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgIGxldCBpc1ZhbGlkO1xuICAgICAgICBsZXQgdmFsaWRhdGlvblJlc3VsdDtcbiAgICAgICAgY29uc3QgZmllbGROYW1lcyA9IGNvbnZlcnRUb0FycmF5UGF5bG9hZChuYW1lKTtcbiAgICAgICAgaWYgKF9vcHRpb25zLnJlc29sdmVyKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvcnMgPSBhd2FpdCBleGVjdXRlU2NoZW1hQW5kVXBkYXRlU3RhdGUoaXNVbmRlZmluZWQobmFtZSkgPyBuYW1lIDogZmllbGROYW1lcyk7XG4gICAgICAgICAgICBpc1ZhbGlkID0gaXNFbXB0eU9iamVjdChlcnJvcnMpO1xuICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdCA9IG5hbWVcbiAgICAgICAgICAgICAgICA/ICFmaWVsZE5hbWVzLnNvbWUoKG5hbWUpID0+IGdldChlcnJvcnMsIG5hbWUpKVxuICAgICAgICAgICAgICAgIDogaXNWYWxpZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuYW1lKSB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0ID0gKGF3YWl0IFByb21pc2UuYWxsKGZpZWxkTmFtZXMubWFwKGFzeW5jIChmaWVsZE5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZCA9IGdldChfZmllbGRzLCBmaWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBleGVjdXRlQnVpbHRJblZhbGlkYXRpb24oZmllbGQgJiYgZmllbGQuX2YgPyB7IFtmaWVsZE5hbWVdOiBmaWVsZCB9IDogZmllbGQpO1xuICAgICAgICAgICAgfSkpKS5ldmVyeShCb29sZWFuKTtcbiAgICAgICAgICAgICEoIXZhbGlkYXRpb25SZXN1bHQgJiYgIV9mb3JtU3RhdGUuaXNWYWxpZCkgJiYgX3NldFZhbGlkKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0ID0gaXNWYWxpZCA9IGF3YWl0IGV4ZWN1dGVCdWlsdEluVmFsaWRhdGlvbihfZmllbGRzKTtcbiAgICAgICAgfVxuICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICAuLi4oIWlzU3RyaW5nKG5hbWUpIHx8XG4gICAgICAgICAgICAgICAgKChfcHJveHlGb3JtU3RhdGUuaXNWYWxpZCB8fCBfcHJveHlTdWJzY3JpYmVGb3JtU3RhdGUuaXNWYWxpZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNWYWxpZCAhPT0gX2Zvcm1TdGF0ZS5pc1ZhbGlkKVxuICAgICAgICAgICAgICAgID8ge31cbiAgICAgICAgICAgICAgICA6IHsgbmFtZSB9KSxcbiAgICAgICAgICAgIC4uLihfb3B0aW9ucy5yZXNvbHZlciB8fCAhbmFtZSA/IHsgaXNWYWxpZCB9IDoge30pLFxuICAgICAgICAgICAgZXJyb3JzOiBfZm9ybVN0YXRlLmVycm9ycyxcbiAgICAgICAgfSk7XG4gICAgICAgIG9wdGlvbnMuc2hvdWxkRm9jdXMgJiZcbiAgICAgICAgICAgICF2YWxpZGF0aW9uUmVzdWx0ICYmXG4gICAgICAgICAgICBpdGVyYXRlRmllbGRzQnlBY3Rpb24oX2ZpZWxkcywgX2ZvY3VzSW5wdXQsIG5hbWUgPyBmaWVsZE5hbWVzIDogX25hbWVzLm1vdW50KTtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRpb25SZXN1bHQ7XG4gICAgfTtcbiAgICBjb25zdCBnZXRWYWx1ZXMgPSAoZmllbGROYW1lcywgY29uZmlnKSA9PiB7XG4gICAgICAgIGxldCB2YWx1ZXMgPSB7XG4gICAgICAgICAgICAuLi4oX3N0YXRlLm1vdW50ID8gX2Zvcm1WYWx1ZXMgOiBfZGVmYXVsdFZhbHVlcyksXG4gICAgICAgIH07XG4gICAgICAgIGlmIChjb25maWcpIHtcbiAgICAgICAgICAgIHZhbHVlcyA9IGV4dHJhY3RGb3JtVmFsdWVzKGNvbmZpZy5kaXJ0eUZpZWxkcyA/IF9mb3JtU3RhdGUuZGlydHlGaWVsZHMgOiBfZm9ybVN0YXRlLnRvdWNoZWRGaWVsZHMsIHZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzVW5kZWZpbmVkKGZpZWxkTmFtZXMpXG4gICAgICAgICAgICA/IHZhbHVlc1xuICAgICAgICAgICAgOiBpc1N0cmluZyhmaWVsZE5hbWVzKVxuICAgICAgICAgICAgICAgID8gZ2V0KHZhbHVlcywgZmllbGROYW1lcylcbiAgICAgICAgICAgICAgICA6IGZpZWxkTmFtZXMubWFwKChuYW1lKSA9PiBnZXQodmFsdWVzLCBuYW1lKSk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRGaWVsZFN0YXRlID0gKG5hbWUsIGZvcm1TdGF0ZSkgPT4gKHtcbiAgICAgICAgaW52YWxpZDogISFnZXQoKGZvcm1TdGF0ZSB8fCBfZm9ybVN0YXRlKS5lcnJvcnMsIG5hbWUpLFxuICAgICAgICBpc0RpcnR5OiAhIWdldCgoZm9ybVN0YXRlIHx8IF9mb3JtU3RhdGUpLmRpcnR5RmllbGRzLCBuYW1lKSxcbiAgICAgICAgZXJyb3I6IGdldCgoZm9ybVN0YXRlIHx8IF9mb3JtU3RhdGUpLmVycm9ycywgbmFtZSksXG4gICAgICAgIGlzVmFsaWRhdGluZzogISFnZXQoX2Zvcm1TdGF0ZS52YWxpZGF0aW5nRmllbGRzLCBuYW1lKSxcbiAgICAgICAgaXNUb3VjaGVkOiAhIWdldCgoZm9ybVN0YXRlIHx8IF9mb3JtU3RhdGUpLnRvdWNoZWRGaWVsZHMsIG5hbWUpLFxuICAgIH0pO1xuICAgIGNvbnN0IGNsZWFyRXJyb3JzID0gKG5hbWUpID0+IHtcbiAgICAgICAgbmFtZSAmJlxuICAgICAgICAgICAgY29udmVydFRvQXJyYXlQYXlsb2FkKG5hbWUpLmZvckVhY2goKGlucHV0TmFtZSkgPT4gdW5zZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIGlucHV0TmFtZSkpO1xuICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICBlcnJvcnM6IG5hbWUgPyBfZm9ybVN0YXRlLmVycm9ycyA6IHt9LFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHNldEVycm9yID0gKG5hbWUsIGVycm9yLCBvcHRpb25zKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlZiA9IChnZXQoX2ZpZWxkcywgbmFtZSwgeyBfZjoge30gfSkuX2YgfHwge30pLnJlZjtcbiAgICAgICAgY29uc3QgY3VycmVudEVycm9yID0gZ2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lKSB8fCB7fTtcbiAgICAgICAgLy8gRG9uJ3Qgb3ZlcnJpZGUgZXhpc3RpbmcgZXJyb3IgbWVzc2FnZXMgZWxzZXdoZXJlIGluIHRoZSBvYmplY3QgdHJlZS5cbiAgICAgICAgY29uc3QgeyByZWY6IGN1cnJlbnRSZWYsIG1lc3NhZ2UsIHR5cGUsIC4uLnJlc3RPZkVycm9yVHJlZSB9ID0gY3VycmVudEVycm9yO1xuICAgICAgICBzZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUsIHtcbiAgICAgICAgICAgIC4uLnJlc3RPZkVycm9yVHJlZSxcbiAgICAgICAgICAgIC4uLmVycm9yLFxuICAgICAgICAgICAgcmVmLFxuICAgICAgICB9KTtcbiAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGVycm9yczogX2Zvcm1TdGF0ZS5lcnJvcnMsXG4gICAgICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIG9wdGlvbnMgJiYgb3B0aW9ucy5zaG91bGRGb2N1cyAmJiByZWYgJiYgcmVmLmZvY3VzICYmIHJlZi5mb2N1cygpO1xuICAgIH07XG4gICAgY29uc3Qgd2F0Y2ggPSAobmFtZSwgZGVmYXVsdFZhbHVlKSA9PiBpc0Z1bmN0aW9uKG5hbWUpXG4gICAgICAgID8gX3N1YmplY3RzLnN0YXRlLnN1YnNjcmliZSh7XG4gICAgICAgICAgICBuZXh0OiAocGF5bG9hZCkgPT4gJ3ZhbHVlcycgaW4gcGF5bG9hZCAmJlxuICAgICAgICAgICAgICAgIG5hbWUoX2dldFdhdGNoKHVuZGVmaW5lZCwgZGVmYXVsdFZhbHVlKSwgcGF5bG9hZCksXG4gICAgICAgIH0pXG4gICAgICAgIDogX2dldFdhdGNoKG5hbWUsIGRlZmF1bHRWYWx1ZSwgdHJ1ZSk7XG4gICAgY29uc3QgX3N1YnNjcmliZSA9IChwcm9wcykgPT4gX3N1YmplY3RzLnN0YXRlLnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQ6IChmb3JtU3RhdGUpID0+IHtcbiAgICAgICAgICAgIGlmIChzaG91bGRTdWJzY3JpYmVCeU5hbWUocHJvcHMubmFtZSwgZm9ybVN0YXRlLm5hbWUsIHByb3BzLmV4YWN0KSAmJlxuICAgICAgICAgICAgICAgIHNob3VsZFJlbmRlckZvcm1TdGF0ZShmb3JtU3RhdGUsIHByb3BzLmZvcm1TdGF0ZSB8fCBfcHJveHlGb3JtU3RhdGUsIF9zZXRGb3JtU3RhdGUsIHByb3BzLnJlUmVuZGVyUm9vdCkpIHtcbiAgICAgICAgICAgICAgICBwcm9wcy5jYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlczogeyAuLi5fZm9ybVZhbHVlcyB9LFxuICAgICAgICAgICAgICAgICAgICAuLi5fZm9ybVN0YXRlLFxuICAgICAgICAgICAgICAgICAgICAuLi5mb3JtU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZXM6IF9kZWZhdWx0VmFsdWVzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pLnVuc3Vic2NyaWJlO1xuICAgIGNvbnN0IHN1YnNjcmliZSA9IChwcm9wcykgPT4ge1xuICAgICAgICBfc3RhdGUubW91bnQgPSB0cnVlO1xuICAgICAgICBfcHJveHlTdWJzY3JpYmVGb3JtU3RhdGUgPSB7XG4gICAgICAgICAgICAuLi5fcHJveHlTdWJzY3JpYmVGb3JtU3RhdGUsXG4gICAgICAgICAgICAuLi5wcm9wcy5mb3JtU3RhdGUsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfc3Vic2NyaWJlKHtcbiAgICAgICAgICAgIC4uLnByb3BzLFxuICAgICAgICAgICAgZm9ybVN0YXRlOiBfcHJveHlTdWJzY3JpYmVGb3JtU3RhdGUsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgdW5yZWdpc3RlciA9IChuYW1lLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZE5hbWUgb2YgbmFtZSA/IGNvbnZlcnRUb0FycmF5UGF5bG9hZChuYW1lKSA6IF9uYW1lcy5tb3VudCkge1xuICAgICAgICAgICAgX25hbWVzLm1vdW50LmRlbGV0ZShmaWVsZE5hbWUpO1xuICAgICAgICAgICAgX25hbWVzLmFycmF5LmRlbGV0ZShmaWVsZE5hbWUpO1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmtlZXBWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHVuc2V0KF9maWVsZHMsIGZpZWxkTmFtZSk7XG4gICAgICAgICAgICAgICAgdW5zZXQoX2Zvcm1WYWx1ZXMsIGZpZWxkTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAhb3B0aW9ucy5rZWVwRXJyb3IgJiYgdW5zZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIGZpZWxkTmFtZSk7XG4gICAgICAgICAgICAhb3B0aW9ucy5rZWVwRGlydHkgJiYgdW5zZXQoX2Zvcm1TdGF0ZS5kaXJ0eUZpZWxkcywgZmllbGROYW1lKTtcbiAgICAgICAgICAgICFvcHRpb25zLmtlZXBUb3VjaGVkICYmIHVuc2V0KF9mb3JtU3RhdGUudG91Y2hlZEZpZWxkcywgZmllbGROYW1lKTtcbiAgICAgICAgICAgICFvcHRpb25zLmtlZXBJc1ZhbGlkYXRpbmcgJiZcbiAgICAgICAgICAgICAgICB1bnNldChfZm9ybVN0YXRlLnZhbGlkYXRpbmdGaWVsZHMsIGZpZWxkTmFtZSk7XG4gICAgICAgICAgICAhX29wdGlvbnMuc2hvdWxkVW5yZWdpc3RlciAmJlxuICAgICAgICAgICAgICAgICFvcHRpb25zLmtlZXBEZWZhdWx0VmFsdWUgJiZcbiAgICAgICAgICAgICAgICB1bnNldChfZGVmYXVsdFZhbHVlcywgZmllbGROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICB2YWx1ZXM6IGNsb25lT2JqZWN0KF9mb3JtVmFsdWVzKSxcbiAgICAgICAgfSk7XG4gICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgIC4uLl9mb3JtU3RhdGUsXG4gICAgICAgICAgICAuLi4oIW9wdGlvbnMua2VlcERpcnR5ID8ge30gOiB7IGlzRGlydHk6IF9nZXREaXJ0eSgpIH0pLFxuICAgICAgICB9KTtcbiAgICAgICAgIW9wdGlvbnMua2VlcElzVmFsaWQgJiYgX3NldFZhbGlkKCk7XG4gICAgfTtcbiAgICBjb25zdCBfc2V0RGlzYWJsZWRGaWVsZCA9ICh7IGRpc2FibGVkLCBuYW1lLCB9KSA9PiB7XG4gICAgICAgIGlmICgoaXNCb29sZWFuKGRpc2FibGVkKSAmJiBfc3RhdGUubW91bnQpIHx8XG4gICAgICAgICAgICAhIWRpc2FibGVkIHx8XG4gICAgICAgICAgICBfbmFtZXMuZGlzYWJsZWQuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICBkaXNhYmxlZCA/IF9uYW1lcy5kaXNhYmxlZC5hZGQobmFtZSkgOiBfbmFtZXMuZGlzYWJsZWQuZGVsZXRlKG5hbWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZWdpc3RlciA9IChuYW1lLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgbGV0IGZpZWxkID0gZ2V0KF9maWVsZHMsIG5hbWUpO1xuICAgICAgICBjb25zdCBkaXNhYmxlZElzRGVmaW5lZCA9IGlzQm9vbGVhbihvcHRpb25zLmRpc2FibGVkKSB8fCBpc0Jvb2xlYW4oX29wdGlvbnMuZGlzYWJsZWQpO1xuICAgICAgICBzZXQoX2ZpZWxkcywgbmFtZSwge1xuICAgICAgICAgICAgLi4uKGZpZWxkIHx8IHt9KSxcbiAgICAgICAgICAgIF9mOiB7XG4gICAgICAgICAgICAgICAgLi4uKGZpZWxkICYmIGZpZWxkLl9mID8gZmllbGQuX2YgOiB7IHJlZjogeyBuYW1lIH0gfSksXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICBtb3VudDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIF9uYW1lcy5tb3VudC5hZGQobmFtZSk7XG4gICAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICAgICAgX3NldERpc2FibGVkRmllbGQoe1xuICAgICAgICAgICAgICAgIGRpc2FibGVkOiBpc0Jvb2xlYW4ob3B0aW9ucy5kaXNhYmxlZClcbiAgICAgICAgICAgICAgICAgICAgPyBvcHRpb25zLmRpc2FibGVkXG4gICAgICAgICAgICAgICAgICAgIDogX29wdGlvbnMuZGlzYWJsZWQsXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXBkYXRlVmFsaWRBbmRWYWx1ZShuYW1lLCB0cnVlLCBvcHRpb25zLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uKGRpc2FibGVkSXNEZWZpbmVkXG4gICAgICAgICAgICAgICAgPyB7IGRpc2FibGVkOiBvcHRpb25zLmRpc2FibGVkIHx8IF9vcHRpb25zLmRpc2FibGVkIH1cbiAgICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgICAgIC4uLihfb3B0aW9ucy5wcm9ncmVzc2l2ZVxuICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogISFvcHRpb25zLnJlcXVpcmVkLFxuICAgICAgICAgICAgICAgICAgICBtaW46IGdldFJ1bGVWYWx1ZShvcHRpb25zLm1pbiksXG4gICAgICAgICAgICAgICAgICAgIG1heDogZ2V0UnVsZVZhbHVlKG9wdGlvbnMubWF4KSxcbiAgICAgICAgICAgICAgICAgICAgbWluTGVuZ3RoOiBnZXRSdWxlVmFsdWUob3B0aW9ucy5taW5MZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgICBtYXhMZW5ndGg6IGdldFJ1bGVWYWx1ZShvcHRpb25zLm1heExlbmd0aCksXG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm46IGdldFJ1bGVWYWx1ZShvcHRpb25zLnBhdHRlcm4pLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBvbkNoYW5nZSxcbiAgICAgICAgICAgIG9uQmx1cjogb25DaGFuZ2UsXG4gICAgICAgICAgICByZWY6IChyZWYpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyKG5hbWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBmaWVsZCA9IGdldChfZmllbGRzLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmllbGRSZWYgPSBpc1VuZGVmaW5lZChyZWYudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHJlZi5xdWVyeVNlbGVjdG9yQWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyByZWYucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQsc2VsZWN0LHRleHRhcmVhJylbMF0gfHwgcmVmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiByZWZcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcmVmO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByYWRpb09yQ2hlY2tib3ggPSBpc1JhZGlvT3JDaGVja2JveChmaWVsZFJlZik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlZnMgPSBmaWVsZC5fZi5yZWZzIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmFkaW9PckNoZWNrYm94XG4gICAgICAgICAgICAgICAgICAgICAgICA/IHJlZnMuZmluZCgob3B0aW9uKSA9PiBvcHRpb24gPT09IGZpZWxkUmVmKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBmaWVsZFJlZiA9PT0gZmllbGQuX2YucmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2V0KF9maWVsZHMsIG5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9mOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uZmllbGQuX2YsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uKHJhZGlvT3JDaGVja2JveFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5yZWZzLmZpbHRlcihsaXZlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZFJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi4oQXJyYXkuaXNBcnJheShnZXQoX2RlZmF1bHRWYWx1ZXMsIG5hbWUpKSA/IFt7fV0gOiBbXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmOiB7IHR5cGU6IGZpZWxkUmVmLnR5cGUsIG5hbWUgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHsgcmVmOiBmaWVsZFJlZiB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVWYWxpZEFuZFZhbHVlKG5hbWUsIGZhbHNlLCB1bmRlZmluZWQsIGZpZWxkUmVmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkID0gZ2V0KF9maWVsZHMsIG5hbWUsIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkLl9mKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZC5fZi5tb3VudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIChfb3B0aW9ucy5zaG91bGRVbnJlZ2lzdGVyIHx8IG9wdGlvbnMuc2hvdWxkVW5yZWdpc3RlcikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICEoaXNOYW1lSW5GaWVsZEFycmF5KF9uYW1lcy5hcnJheSwgbmFtZSkgJiYgX3N0YXRlLmFjdGlvbikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIF9uYW1lcy51bk1vdW50LmFkZChuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgX2ZvY3VzRXJyb3IgPSAoKSA9PiBfb3B0aW9ucy5zaG91bGRGb2N1c0Vycm9yICYmXG4gICAgICAgIGl0ZXJhdGVGaWVsZHNCeUFjdGlvbihfZmllbGRzLCBfZm9jdXNJbnB1dCwgX25hbWVzLm1vdW50KTtcbiAgICBjb25zdCBfZGlzYWJsZUZvcm0gPSAoZGlzYWJsZWQpID0+IHtcbiAgICAgICAgaWYgKGlzQm9vbGVhbihkaXNhYmxlZCkpIHtcbiAgICAgICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHsgZGlzYWJsZWQgfSk7XG4gICAgICAgICAgICBpdGVyYXRlRmllbGRzQnlBY3Rpb24oX2ZpZWxkcywgKHJlZiwgbmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRGaWVsZCA9IGdldChfZmllbGRzLCBuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZi5kaXNhYmxlZCA9IGN1cnJlbnRGaWVsZC5fZi5kaXNhYmxlZCB8fCBkaXNhYmxlZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudEZpZWxkLl9mLnJlZnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RmllbGQuX2YucmVmcy5mb3JFYWNoKChpbnB1dFJlZikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0UmVmLmRpc2FibGVkID0gY3VycmVudEZpZWxkLl9mLmRpc2FibGVkIHx8IGRpc2FibGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAwLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZVN1Ym1pdCA9IChvblZhbGlkLCBvbkludmFsaWQpID0+IGFzeW5jIChlKSA9PiB7XG4gICAgICAgIGxldCBvblZhbGlkRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0ICYmIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGUucGVyc2lzdCAmJlxuICAgICAgICAgICAgICAgIGUucGVyc2lzdCgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmaWVsZFZhbHVlcyA9IGNsb25lT2JqZWN0KF9mb3JtVmFsdWVzKTtcbiAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgaXNTdWJtaXR0aW5nOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKF9vcHRpb25zLnJlc29sdmVyKSB7XG4gICAgICAgICAgICBjb25zdCB7IGVycm9ycywgdmFsdWVzIH0gPSBhd2FpdCBfcnVuU2NoZW1hKCk7XG4gICAgICAgICAgICBfZm9ybVN0YXRlLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgICAgIGZpZWxkVmFsdWVzID0gY2xvbmVPYmplY3QodmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IGV4ZWN1dGVCdWlsdEluVmFsaWRhdGlvbihfZmllbGRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX25hbWVzLmRpc2FibGVkLnNpemUpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBfbmFtZXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB1bnNldChmaWVsZFZhbHVlcywgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdW5zZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsICdyb290Jyk7XG4gICAgICAgIGlmIChpc0VtcHR5T2JqZWN0KF9mb3JtU3RhdGUuZXJyb3JzKSkge1xuICAgICAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgICAgIGVycm9yczoge30sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgb25WYWxpZChmaWVsZFZhbHVlcywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBvblZhbGlkRXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChvbkludmFsaWQpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBvbkludmFsaWQoeyAuLi5fZm9ybVN0YXRlLmVycm9ycyB9LCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9mb2N1c0Vycm9yKCk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KF9mb2N1c0Vycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICBpc1N1Ym1pdHRlZDogdHJ1ZSxcbiAgICAgICAgICAgIGlzU3VibWl0dGluZzogZmFsc2UsXG4gICAgICAgICAgICBpc1N1Ym1pdFN1Y2Nlc3NmdWw6IGlzRW1wdHlPYmplY3QoX2Zvcm1TdGF0ZS5lcnJvcnMpICYmICFvblZhbGlkRXJyb3IsXG4gICAgICAgICAgICBzdWJtaXRDb3VudDogX2Zvcm1TdGF0ZS5zdWJtaXRDb3VudCArIDEsXG4gICAgICAgICAgICBlcnJvcnM6IF9mb3JtU3RhdGUuZXJyb3JzLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG9uVmFsaWRFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgb25WYWxpZEVycm9yO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZXNldEZpZWxkID0gKG5hbWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICBpZiAoZ2V0KF9maWVsZHMsIG5hbWUpKSB7XG4gICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQob3B0aW9ucy5kZWZhdWx0VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgc2V0VmFsdWUobmFtZSwgY2xvbmVPYmplY3QoZ2V0KF9kZWZhdWx0VmFsdWVzLCBuYW1lKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0VmFsdWUobmFtZSwgb3B0aW9ucy5kZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgICAgIHNldChfZGVmYXVsdFZhbHVlcywgbmFtZSwgY2xvbmVPYmplY3Qob3B0aW9ucy5kZWZhdWx0VmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5rZWVwVG91Y2hlZCkge1xuICAgICAgICAgICAgICAgIHVuc2V0KF9mb3JtU3RhdGUudG91Y2hlZEZpZWxkcywgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMua2VlcERpcnR5KSB7XG4gICAgICAgICAgICAgICAgdW5zZXQoX2Zvcm1TdGF0ZS5kaXJ0eUZpZWxkcywgbmFtZSk7XG4gICAgICAgICAgICAgICAgX2Zvcm1TdGF0ZS5pc0RpcnR5ID0gb3B0aW9ucy5kZWZhdWx0VmFsdWVcbiAgICAgICAgICAgICAgICAgICAgPyBfZ2V0RGlydHkobmFtZSwgY2xvbmVPYmplY3QoZ2V0KF9kZWZhdWx0VmFsdWVzLCBuYW1lKSkpXG4gICAgICAgICAgICAgICAgICAgIDogX2dldERpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMua2VlcEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdW5zZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUpO1xuICAgICAgICAgICAgICAgIF9wcm94eUZvcm1TdGF0ZS5pc1ZhbGlkICYmIF9zZXRWYWxpZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoeyAuLi5fZm9ybVN0YXRlIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBfcmVzZXQgPSAoZm9ybVZhbHVlcywga2VlcFN0YXRlT3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRWYWx1ZXMgPSBmb3JtVmFsdWVzID8gY2xvbmVPYmplY3QoZm9ybVZhbHVlcykgOiBfZGVmYXVsdFZhbHVlcztcbiAgICAgICAgY29uc3QgY2xvbmVVcGRhdGVkVmFsdWVzID0gY2xvbmVPYmplY3QodXBkYXRlZFZhbHVlcyk7XG4gICAgICAgIGNvbnN0IGlzRW1wdHlSZXNldFZhbHVlcyA9IGlzRW1wdHlPYmplY3QoZm9ybVZhbHVlcyk7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IGlzRW1wdHlSZXNldFZhbHVlcyA/IF9kZWZhdWx0VmFsdWVzIDogY2xvbmVVcGRhdGVkVmFsdWVzO1xuICAgICAgICBpZiAoIWtlZXBTdGF0ZU9wdGlvbnMua2VlcERlZmF1bHRWYWx1ZXMpIHtcbiAgICAgICAgICAgIF9kZWZhdWx0VmFsdWVzID0gdXBkYXRlZFZhbHVlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWtlZXBTdGF0ZU9wdGlvbnMua2VlcFZhbHVlcykge1xuICAgICAgICAgICAgaWYgKGtlZXBTdGF0ZU9wdGlvbnMua2VlcERpcnR5VmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGRzVG9DaGVjayA9IG5ldyBTZXQoW1xuICAgICAgICAgICAgICAgICAgICAuLi5fbmFtZXMubW91bnQsXG4gICAgICAgICAgICAgICAgICAgIC4uLk9iamVjdC5rZXlzKGdldERpcnR5RmllbGRzKF9kZWZhdWx0VmFsdWVzLCBfZm9ybVZhbHVlcykpLFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZmllbGROYW1lIG9mIEFycmF5LmZyb20oZmllbGRzVG9DaGVjaykpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0KF9mb3JtU3RhdGUuZGlydHlGaWVsZHMsIGZpZWxkTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc2V0KHZhbHVlcywgZmllbGROYW1lLCBnZXQoX2Zvcm1WYWx1ZXMsIGZpZWxkTmFtZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHNldFZhbHVlKGZpZWxkTmFtZSwgZ2V0KHZhbHVlcywgZmllbGROYW1lKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzV2ViICYmIGlzVW5kZWZpbmVkKGZvcm1WYWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBfbmFtZXMubW91bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KF9maWVsZHMsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkICYmIGZpZWxkLl9mKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmllbGRSZWZlcmVuY2UgPSBBcnJheS5pc0FycmF5KGZpZWxkLl9mLnJlZnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZmllbGQuX2YucmVmc1swXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGZpZWxkLl9mLnJlZjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNIVE1MRWxlbWVudChmaWVsZFJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZm9ybSA9IGZpZWxkUmVmZXJlbmNlLmNsb3Nlc3QoJ2Zvcm0nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm0ucmVzZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChrZWVwU3RhdGVPcHRpb25zLmtlZXBGaWVsZHNSZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBmaWVsZE5hbWUgb2YgX25hbWVzLm1vdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZShmaWVsZE5hbWUsIGdldCh2YWx1ZXMsIGZpZWxkTmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfZmllbGRzID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2Zvcm1WYWx1ZXMgPSBfb3B0aW9ucy5zaG91bGRVbnJlZ2lzdGVyXG4gICAgICAgICAgICAgICAgPyBrZWVwU3RhdGVPcHRpb25zLmtlZXBEZWZhdWx0VmFsdWVzXG4gICAgICAgICAgICAgICAgICAgID8gY2xvbmVPYmplY3QoX2RlZmF1bHRWYWx1ZXMpXG4gICAgICAgICAgICAgICAgICAgIDoge31cbiAgICAgICAgICAgICAgICA6IGNsb25lT2JqZWN0KHZhbHVlcyk7XG4gICAgICAgICAgICBfc3ViamVjdHMuYXJyYXkubmV4dCh7XG4gICAgICAgICAgICAgICAgdmFsdWVzOiB7IC4uLnZhbHVlcyB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICAgICAgdmFsdWVzOiB7IC4uLnZhbHVlcyB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgX25hbWVzID0ge1xuICAgICAgICAgICAgbW91bnQ6IGtlZXBTdGF0ZU9wdGlvbnMua2VlcERpcnR5VmFsdWVzID8gX25hbWVzLm1vdW50IDogbmV3IFNldCgpLFxuICAgICAgICAgICAgdW5Nb3VudDogbmV3IFNldCgpLFxuICAgICAgICAgICAgYXJyYXk6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgIGRpc2FibGVkOiBuZXcgU2V0KCksXG4gICAgICAgICAgICB3YXRjaDogbmV3IFNldCgpLFxuICAgICAgICAgICAgd2F0Y2hBbGw6IGZhbHNlLFxuICAgICAgICAgICAgZm9jdXM6ICcnLFxuICAgICAgICB9O1xuICAgICAgICBfc3RhdGUubW91bnQgPVxuICAgICAgICAgICAgIV9wcm94eUZvcm1TdGF0ZS5pc1ZhbGlkIHx8XG4gICAgICAgICAgICAgICAgISFrZWVwU3RhdGVPcHRpb25zLmtlZXBJc1ZhbGlkIHx8XG4gICAgICAgICAgICAgICAgISFrZWVwU3RhdGVPcHRpb25zLmtlZXBEaXJ0eVZhbHVlcztcbiAgICAgICAgX3N0YXRlLndhdGNoID0gISFfb3B0aW9ucy5zaG91bGRVbnJlZ2lzdGVyO1xuICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICBzdWJtaXRDb3VudDoga2VlcFN0YXRlT3B0aW9ucy5rZWVwU3VibWl0Q291bnRcbiAgICAgICAgICAgICAgICA/IF9mb3JtU3RhdGUuc3VibWl0Q291bnRcbiAgICAgICAgICAgICAgICA6IDAsXG4gICAgICAgICAgICBpc0RpcnR5OiBpc0VtcHR5UmVzZXRWYWx1ZXNcbiAgICAgICAgICAgICAgICA/IGZhbHNlXG4gICAgICAgICAgICAgICAgOiBrZWVwU3RhdGVPcHRpb25zLmtlZXBEaXJ0eVxuICAgICAgICAgICAgICAgICAgICA/IF9mb3JtU3RhdGUuaXNEaXJ0eVxuICAgICAgICAgICAgICAgICAgICA6ICEhKGtlZXBTdGF0ZU9wdGlvbnMua2VlcERlZmF1bHRWYWx1ZXMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFkZWVwRXF1YWwoZm9ybVZhbHVlcywgX2RlZmF1bHRWYWx1ZXMpKSxcbiAgICAgICAgICAgIGlzU3VibWl0dGVkOiBrZWVwU3RhdGVPcHRpb25zLmtlZXBJc1N1Ym1pdHRlZFxuICAgICAgICAgICAgICAgID8gX2Zvcm1TdGF0ZS5pc1N1Ym1pdHRlZFxuICAgICAgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICBkaXJ0eUZpZWxkczogaXNFbXB0eVJlc2V0VmFsdWVzXG4gICAgICAgICAgICAgICAgPyB7fVxuICAgICAgICAgICAgICAgIDoga2VlcFN0YXRlT3B0aW9ucy5rZWVwRGlydHlWYWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgPyBrZWVwU3RhdGVPcHRpb25zLmtlZXBEZWZhdWx0VmFsdWVzICYmIF9mb3JtVmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGdldERpcnR5RmllbGRzKF9kZWZhdWx0VmFsdWVzLCBfZm9ybVZhbHVlcylcbiAgICAgICAgICAgICAgICAgICAgICAgIDogX2Zvcm1TdGF0ZS5kaXJ0eUZpZWxkc1xuICAgICAgICAgICAgICAgICAgICA6IGtlZXBTdGF0ZU9wdGlvbnMua2VlcERlZmF1bHRWYWx1ZXMgJiYgZm9ybVZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBnZXREaXJ0eUZpZWxkcyhfZGVmYXVsdFZhbHVlcywgZm9ybVZhbHVlcylcbiAgICAgICAgICAgICAgICAgICAgICAgIDoga2VlcFN0YXRlT3B0aW9ucy5rZWVwRGlydHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IF9mb3JtU3RhdGUuZGlydHlGaWVsZHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHt9LFxuICAgICAgICAgICAgdG91Y2hlZEZpZWxkczoga2VlcFN0YXRlT3B0aW9ucy5rZWVwVG91Y2hlZFxuICAgICAgICAgICAgICAgID8gX2Zvcm1TdGF0ZS50b3VjaGVkRmllbGRzXG4gICAgICAgICAgICAgICAgOiB7fSxcbiAgICAgICAgICAgIGVycm9yczoga2VlcFN0YXRlT3B0aW9ucy5rZWVwRXJyb3JzID8gX2Zvcm1TdGF0ZS5lcnJvcnMgOiB7fSxcbiAgICAgICAgICAgIGlzU3VibWl0U3VjY2Vzc2Z1bDoga2VlcFN0YXRlT3B0aW9ucy5rZWVwSXNTdWJtaXRTdWNjZXNzZnVsXG4gICAgICAgICAgICAgICAgPyBfZm9ybVN0YXRlLmlzU3VibWl0U3VjY2Vzc2Z1bFxuICAgICAgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICBpc1N1Ym1pdHRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlczogX2RlZmF1bHRWYWx1ZXMsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgcmVzZXQgPSAoZm9ybVZhbHVlcywga2VlcFN0YXRlT3B0aW9ucykgPT4gX3Jlc2V0KGlzRnVuY3Rpb24oZm9ybVZhbHVlcylcbiAgICAgICAgPyBmb3JtVmFsdWVzKF9mb3JtVmFsdWVzKVxuICAgICAgICA6IGZvcm1WYWx1ZXMsIGtlZXBTdGF0ZU9wdGlvbnMpO1xuICAgIGNvbnN0IHNldEZvY3VzID0gKG5hbWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICBjb25zdCBmaWVsZCA9IGdldChfZmllbGRzLCBuYW1lKTtcbiAgICAgICAgY29uc3QgZmllbGRSZWZlcmVuY2UgPSBmaWVsZCAmJiBmaWVsZC5fZjtcbiAgICAgICAgaWYgKGZpZWxkUmVmZXJlbmNlKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZFJlZiA9IGZpZWxkUmVmZXJlbmNlLnJlZnNcbiAgICAgICAgICAgICAgICA/IGZpZWxkUmVmZXJlbmNlLnJlZnNbMF1cbiAgICAgICAgICAgICAgICA6IGZpZWxkUmVmZXJlbmNlLnJlZjtcbiAgICAgICAgICAgIGlmIChmaWVsZFJlZi5mb2N1cykge1xuICAgICAgICAgICAgICAgIGZpZWxkUmVmLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zaG91bGRTZWxlY3QgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNGdW5jdGlvbihmaWVsZFJlZi5zZWxlY3QpICYmXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkUmVmLnNlbGVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBfc2V0Rm9ybVN0YXRlID0gKHVwZGF0ZWRGb3JtU3RhdGUpID0+IHtcbiAgICAgICAgX2Zvcm1TdGF0ZSA9IHtcbiAgICAgICAgICAgIC4uLl9mb3JtU3RhdGUsXG4gICAgICAgICAgICAuLi51cGRhdGVkRm9ybVN0YXRlLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgX3Jlc2V0RGVmYXVsdFZhbHVlcyA9ICgpID0+IGlzRnVuY3Rpb24oX29wdGlvbnMuZGVmYXVsdFZhbHVlcykgJiZcbiAgICAgICAgX29wdGlvbnMuZGVmYXVsdFZhbHVlcygpLnRoZW4oKHZhbHVlcykgPT4ge1xuICAgICAgICAgICAgcmVzZXQodmFsdWVzLCBfb3B0aW9ucy5yZXNldE9wdGlvbnMpO1xuICAgICAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgY29uc3QgbWV0aG9kcyA9IHtcbiAgICAgICAgY29udHJvbDoge1xuICAgICAgICAgICAgcmVnaXN0ZXIsXG4gICAgICAgICAgICB1bnJlZ2lzdGVyLFxuICAgICAgICAgICAgZ2V0RmllbGRTdGF0ZSxcbiAgICAgICAgICAgIGhhbmRsZVN1Ym1pdCxcbiAgICAgICAgICAgIHNldEVycm9yLFxuICAgICAgICAgICAgX3N1YnNjcmliZSxcbiAgICAgICAgICAgIF9ydW5TY2hlbWEsXG4gICAgICAgICAgICBfZm9jdXNFcnJvcixcbiAgICAgICAgICAgIF9nZXRXYXRjaCxcbiAgICAgICAgICAgIF9nZXREaXJ0eSxcbiAgICAgICAgICAgIF9zZXRWYWxpZCxcbiAgICAgICAgICAgIF9zZXRGaWVsZEFycmF5LFxuICAgICAgICAgICAgX3NldERpc2FibGVkRmllbGQsXG4gICAgICAgICAgICBfc2V0RXJyb3JzLFxuICAgICAgICAgICAgX2dldEZpZWxkQXJyYXksXG4gICAgICAgICAgICBfcmVzZXQsXG4gICAgICAgICAgICBfcmVzZXREZWZhdWx0VmFsdWVzLFxuICAgICAgICAgICAgX3JlbW92ZVVubW91bnRlZCxcbiAgICAgICAgICAgIF9kaXNhYmxlRm9ybSxcbiAgICAgICAgICAgIF9zdWJqZWN0cyxcbiAgICAgICAgICAgIF9wcm94eUZvcm1TdGF0ZSxcbiAgICAgICAgICAgIGdldCBfZmllbGRzKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZmllbGRzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBfZm9ybVZhbHVlcygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2Zvcm1WYWx1ZXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IF9zdGF0ZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N0YXRlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldCBfc3RhdGUodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBfc3RhdGUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgX2RlZmF1bHRWYWx1ZXMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9kZWZhdWx0VmFsdWVzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBfbmFtZXMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9uYW1lcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQgX25hbWVzKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgX25hbWVzID0gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IF9mb3JtU3RhdGUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mb3JtU3RhdGU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IF9vcHRpb25zKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfb3B0aW9ucztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQgX29wdGlvbnModmFsdWUpIHtcbiAgICAgICAgICAgICAgICBfb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uX29wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIC4uLnZhbHVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgIHRyaWdnZXIsXG4gICAgICAgIHJlZ2lzdGVyLFxuICAgICAgICBoYW5kbGVTdWJtaXQsXG4gICAgICAgIHdhdGNoLFxuICAgICAgICBzZXRWYWx1ZSxcbiAgICAgICAgZ2V0VmFsdWVzLFxuICAgICAgICByZXNldCxcbiAgICAgICAgcmVzZXRGaWVsZCxcbiAgICAgICAgY2xlYXJFcnJvcnMsXG4gICAgICAgIHVucmVnaXN0ZXIsXG4gICAgICAgIHNldEVycm9yLFxuICAgICAgICBzZXRGb2N1cyxcbiAgICAgICAgZ2V0RmllbGRTdGF0ZSxcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1ldGhvZHMsXG4gICAgICAgIGZvcm1Db250cm9sOiBtZXRob2RzLFxuICAgIH07XG59XG5cbnZhciBnZW5lcmF0ZUlkID0gKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgY3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiBjcnlwdG8ucmFuZG9tVVVJRCkge1xuICAgICAgICByZXR1cm4gY3J5cHRvLnJhbmRvbVVVSUQoKTtcbiAgICB9XG4gICAgY29uc3QgZCA9IHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ3VuZGVmaW5lZCcgPyBEYXRlLm5vdygpIDogcGVyZm9ybWFuY2Uubm93KCkgKiAxMDAwO1xuICAgIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIChjKSA9PiB7XG4gICAgICAgIGNvbnN0IHIgPSAoTWF0aC5yYW5kb20oKSAqIDE2ICsgZCkgJSAxNiB8IDA7XG4gICAgICAgIHJldHVybiAoYyA9PSAneCcgPyByIDogKHIgJiAweDMpIHwgMHg4KS50b1N0cmluZygxNik7XG4gICAgfSk7XG59O1xuXG52YXIgZ2V0Rm9jdXNGaWVsZE5hbWUgPSAobmFtZSwgaW5kZXgsIG9wdGlvbnMgPSB7fSkgPT4gb3B0aW9ucy5zaG91bGRGb2N1cyB8fCBpc1VuZGVmaW5lZChvcHRpb25zLnNob3VsZEZvY3VzKVxuICAgID8gb3B0aW9ucy5mb2N1c05hbWUgfHxcbiAgICAgICAgYCR7bmFtZX0uJHtpc1VuZGVmaW5lZChvcHRpb25zLmZvY3VzSW5kZXgpID8gaW5kZXggOiBvcHRpb25zLmZvY3VzSW5kZXh9LmBcbiAgICA6ICcnO1xuXG52YXIgYXBwZW5kQXQgPSAoZGF0YSwgdmFsdWUpID0+IFtcbiAgICAuLi5kYXRhLFxuICAgIC4uLmNvbnZlcnRUb0FycmF5UGF5bG9hZCh2YWx1ZSksXG5dO1xuXG52YXIgZmlsbEVtcHR5QXJyYXkgPSAodmFsdWUpID0+IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUubWFwKCgpID0+IHVuZGVmaW5lZCkgOiB1bmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGluc2VydChkYXRhLCBpbmRleCwgdmFsdWUpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICAuLi5kYXRhLnNsaWNlKDAsIGluZGV4KSxcbiAgICAgICAgLi4uY29udmVydFRvQXJyYXlQYXlsb2FkKHZhbHVlKSxcbiAgICAgICAgLi4uZGF0YS5zbGljZShpbmRleCksXG4gICAgXTtcbn1cblxudmFyIG1vdmVBcnJheUF0ID0gKGRhdGEsIGZyb20sIHRvKSA9PiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKGlzVW5kZWZpbmVkKGRhdGFbdG9dKSkge1xuICAgICAgICBkYXRhW3RvXSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZGF0YS5zcGxpY2UodG8sIDAsIGRhdGEuc3BsaWNlKGZyb20sIDEpWzBdKTtcbiAgICByZXR1cm4gZGF0YTtcbn07XG5cbnZhciBwcmVwZW5kQXQgPSAoZGF0YSwgdmFsdWUpID0+IFtcbiAgICAuLi5jb252ZXJ0VG9BcnJheVBheWxvYWQodmFsdWUpLFxuICAgIC4uLmNvbnZlcnRUb0FycmF5UGF5bG9hZChkYXRhKSxcbl07XG5cbmZ1bmN0aW9uIHJlbW92ZUF0SW5kZXhlcyhkYXRhLCBpbmRleGVzKSB7XG4gICAgbGV0IGkgPSAwO1xuICAgIGNvbnN0IHRlbXAgPSBbLi4uZGF0YV07XG4gICAgZm9yIChjb25zdCBpbmRleCBvZiBpbmRleGVzKSB7XG4gICAgICAgIHRlbXAuc3BsaWNlKGluZGV4IC0gaSwgMSk7XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBhY3QodGVtcCkubGVuZ3RoID8gdGVtcCA6IFtdO1xufVxudmFyIHJlbW92ZUFycmF5QXQgPSAoZGF0YSwgaW5kZXgpID0+IGlzVW5kZWZpbmVkKGluZGV4KVxuICAgID8gW11cbiAgICA6IHJlbW92ZUF0SW5kZXhlcyhkYXRhLCBjb252ZXJ0VG9BcnJheVBheWxvYWQoaW5kZXgpLnNvcnQoKGEsIGIpID0+IGEgLSBiKSk7XG5cbnZhciBzd2FwQXJyYXlBdCA9IChkYXRhLCBpbmRleEEsIGluZGV4QikgPT4ge1xuICAgIFtkYXRhW2luZGV4QV0sIGRhdGFbaW5kZXhCXV0gPSBbZGF0YVtpbmRleEJdLCBkYXRhW2luZGV4QV1dO1xufTtcblxudmFyIHVwZGF0ZUF0ID0gKGZpZWxkVmFsdWVzLCBpbmRleCwgdmFsdWUpID0+IHtcbiAgICBmaWVsZFZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICByZXR1cm4gZmllbGRWYWx1ZXM7XG59O1xuXG4vKipcbiAqIEEgY3VzdG9tIGhvb2sgdGhhdCBleHBvc2VzIGNvbnZlbmllbnQgbWV0aG9kcyB0byBwZXJmb3JtIG9wZXJhdGlvbnMgd2l0aCBhIGxpc3Qgb2YgZHluYW1pYyBpbnB1dHMgdGhhdCBuZWVkIHRvIGJlIGFwcGVuZGVkLCB1cGRhdGVkLCByZW1vdmVkIGV0Yy4g4oCiIFtEZW1vXShodHRwczovL2NvZGVzYW5kYm94LmlvL3MvcmVhY3QtaG9vay1mb3JtLXVzZWZpZWxkYXJyYXktc3N1Z24pIOKAoiBbVmlkZW9dKGh0dHBzOi8veW91dHUuYmUvNE1yYmZHU0ZZMkEpXG4gKlxuICogQHJlbWFya3NcbiAqIFtBUEldKGh0dHBzOi8vcmVhY3QtaG9vay1mb3JtLmNvbS9kb2NzL3VzZWZpZWxkYXJyYXkpIOKAoiBbRGVtb10oaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL3JlYWN0LWhvb2stZm9ybS11c2VmaWVsZGFycmF5LXNzdWduKVxuICpcbiAqIEBwYXJhbSBwcm9wcyAtIHVzZUZpZWxkQXJyYXkgcHJvcHNcbiAqXG4gKiBAcmV0dXJucyBtZXRob2RzIC0gZnVuY3Rpb25zIHRvIG1hbmlwdWxhdGUgd2l0aCB0aGUgRmllbGQgQXJyYXlzIChkeW5hbWljIGlucHV0cykge0BsaW5rIFVzZUZpZWxkQXJyYXlSZXR1cm59XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogZnVuY3Rpb24gQXBwKCkge1xuICogICBjb25zdCB7IHJlZ2lzdGVyLCBjb250cm9sLCBoYW5kbGVTdWJtaXQsIHJlc2V0LCB0cmlnZ2VyLCBzZXRFcnJvciB9ID0gdXNlRm9ybSh7XG4gKiAgICAgZGVmYXVsdFZhbHVlczoge1xuICogICAgICAgdGVzdDogW11cbiAqICAgICB9XG4gKiAgIH0pO1xuICogICBjb25zdCB7IGZpZWxkcywgYXBwZW5kIH0gPSB1c2VGaWVsZEFycmF5KHtcbiAqICAgICBjb250cm9sLFxuICogICAgIG5hbWU6IFwidGVzdFwiXG4gKiAgIH0pO1xuICpcbiAqICAgcmV0dXJuIChcbiAqICAgICA8Zm9ybSBvblN1Ym1pdD17aGFuZGxlU3VibWl0KGRhdGEgPT4gY29uc29sZS5sb2coZGF0YSkpfT5cbiAqICAgICAgIHtmaWVsZHMubWFwKChpdGVtLCBpbmRleCkgPT4gKFxuICogICAgICAgICAgPGlucHV0IGtleT17aXRlbS5pZH0gey4uLnJlZ2lzdGVyKGB0ZXN0LiR7aW5kZXh9LmZpcnN0TmFtZWApfSAgLz5cbiAqICAgICAgICkpfVxuICogICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgb25DbGljaz17KCkgPT4gYXBwZW5kKHsgZmlyc3ROYW1lOiBcImJpbGxcIiB9KX0+XG4gKiAgICAgICAgIGFwcGVuZFxuICogICAgICAgPC9idXR0b24+XG4gKiAgICAgICA8aW5wdXQgdHlwZT1cInN1Ym1pdFwiIC8+XG4gKiAgICAgPC9mb3JtPlxuICogICApO1xuICogfVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIHVzZUZpZWxkQXJyYXkocHJvcHMpIHtcbiAgICBjb25zdCBtZXRob2RzID0gdXNlRm9ybUNvbnRleHQoKTtcbiAgICBjb25zdCB7IGNvbnRyb2wgPSBtZXRob2RzLmNvbnRyb2wsIG5hbWUsIGtleU5hbWUgPSAnaWQnLCBzaG91bGRVbnJlZ2lzdGVyLCBydWxlcywgfSA9IHByb3BzO1xuICAgIGNvbnN0IFtmaWVsZHMsIHNldEZpZWxkc10gPSBSZWFjdC51c2VTdGF0ZShjb250cm9sLl9nZXRGaWVsZEFycmF5KG5hbWUpKTtcbiAgICBjb25zdCBpZHMgPSBSZWFjdC51c2VSZWYoY29udHJvbC5fZ2V0RmllbGRBcnJheShuYW1lKS5tYXAoZ2VuZXJhdGVJZCkpO1xuICAgIGNvbnN0IF9maWVsZElkcyA9IFJlYWN0LnVzZVJlZihmaWVsZHMpO1xuICAgIGNvbnN0IF9hY3Rpb25lZCA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gICAgX2ZpZWxkSWRzLmN1cnJlbnQgPSBmaWVsZHM7XG4gICAgY29udHJvbC5fbmFtZXMuYXJyYXkuYWRkKG5hbWUpO1xuICAgIFJlYWN0LnVzZU1lbW8oKCkgPT4gcnVsZXMgJiZcbiAgICAgICAgY29udHJvbC5yZWdpc3RlcihuYW1lLCBydWxlcyksIFtjb250cm9sLCBydWxlcywgbmFtZV0pO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4gY29udHJvbC5fc3ViamVjdHMuYXJyYXkuc3Vic2NyaWJlKHtcbiAgICAgICAgbmV4dDogKHsgdmFsdWVzLCBuYW1lOiBmaWVsZEFycmF5TmFtZSwgfSkgPT4ge1xuICAgICAgICAgICAgaWYgKGZpZWxkQXJyYXlOYW1lID09PSBuYW1lIHx8ICFmaWVsZEFycmF5TmFtZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkVmFsdWVzID0gZ2V0KHZhbHVlcywgbmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZmllbGRWYWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEZpZWxkcyhmaWVsZFZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgIGlkcy5jdXJyZW50ID0gZmllbGRWYWx1ZXMubWFwKGdlbmVyYXRlSWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KS51bnN1YnNjcmliZSwgW2NvbnRyb2wsIG5hbWVdKTtcbiAgICBjb25zdCB1cGRhdGVWYWx1ZXMgPSBSZWFjdC51c2VDYWxsYmFjaygodXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMpID0+IHtcbiAgICAgICAgX2FjdGlvbmVkLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICBjb250cm9sLl9zZXRGaWVsZEFycmF5KG5hbWUsIHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICB9LCBbY29udHJvbCwgbmFtZV0pO1xuICAgIGNvbnN0IGFwcGVuZCA9ICh2YWx1ZSwgb3B0aW9ucykgPT4ge1xuICAgICAgICBjb25zdCBhcHBlbmRWYWx1ZSA9IGNvbnZlcnRUb0FycmF5UGF5bG9hZChjbG9uZU9iamVjdCh2YWx1ZSkpO1xuICAgICAgICBjb25zdCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcyA9IGFwcGVuZEF0KGNvbnRyb2wuX2dldEZpZWxkQXJyYXkobmFtZSksIGFwcGVuZFZhbHVlKTtcbiAgICAgICAgY29udHJvbC5fbmFtZXMuZm9jdXMgPSBnZXRGb2N1c0ZpZWxkTmFtZShuYW1lLCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcy5sZW5ndGggLSAxLCBvcHRpb25zKTtcbiAgICAgICAgaWRzLmN1cnJlbnQgPSBhcHBlbmRBdChpZHMuY3VycmVudCwgYXBwZW5kVmFsdWUubWFwKGdlbmVyYXRlSWQpKTtcbiAgICAgICAgdXBkYXRlVmFsdWVzKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICAgICAgc2V0RmllbGRzKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICAgICAgY29udHJvbC5fc2V0RmllbGRBcnJheShuYW1lLCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcywgYXBwZW5kQXQsIHtcbiAgICAgICAgICAgIGFyZ0E6IGZpbGxFbXB0eUFycmF5KHZhbHVlKSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBwcmVwZW5kID0gKHZhbHVlLCBvcHRpb25zKSA9PiB7XG4gICAgICAgIGNvbnN0IHByZXBlbmRWYWx1ZSA9IGNvbnZlcnRUb0FycmF5UGF5bG9hZChjbG9uZU9iamVjdCh2YWx1ZSkpO1xuICAgICAgICBjb25zdCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcyA9IHByZXBlbmRBdChjb250cm9sLl9nZXRGaWVsZEFycmF5KG5hbWUpLCBwcmVwZW5kVmFsdWUpO1xuICAgICAgICBjb250cm9sLl9uYW1lcy5mb2N1cyA9IGdldEZvY3VzRmllbGROYW1lKG5hbWUsIDAsIG9wdGlvbnMpO1xuICAgICAgICBpZHMuY3VycmVudCA9IHByZXBlbmRBdChpZHMuY3VycmVudCwgcHJlcGVuZFZhbHVlLm1hcChnZW5lcmF0ZUlkKSk7XG4gICAgICAgIHVwZGF0ZVZhbHVlcyh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgICAgIHNldEZpZWxkcyh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgICAgIGNvbnRyb2wuX3NldEZpZWxkQXJyYXkobmFtZSwgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMsIHByZXBlbmRBdCwge1xuICAgICAgICAgICAgYXJnQTogZmlsbEVtcHR5QXJyYXkodmFsdWUpLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHJlbW92ZSA9IChpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcyA9IHJlbW92ZUFycmF5QXQoY29udHJvbC5fZ2V0RmllbGRBcnJheShuYW1lKSwgaW5kZXgpO1xuICAgICAgICBpZHMuY3VycmVudCA9IHJlbW92ZUFycmF5QXQoaWRzLmN1cnJlbnQsIGluZGV4KTtcbiAgICAgICAgdXBkYXRlVmFsdWVzKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICAgICAgc2V0RmllbGRzKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICAgICAgIUFycmF5LmlzQXJyYXkoZ2V0KGNvbnRyb2wuX2ZpZWxkcywgbmFtZSkpICYmXG4gICAgICAgICAgICBzZXQoY29udHJvbC5fZmllbGRzLCBuYW1lLCB1bmRlZmluZWQpO1xuICAgICAgICBjb250cm9sLl9zZXRGaWVsZEFycmF5KG5hbWUsIHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzLCByZW1vdmVBcnJheUF0LCB7XG4gICAgICAgICAgICBhcmdBOiBpbmRleCxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBpbnNlcnQkMSA9IChpbmRleCwgdmFsdWUsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgY29uc3QgaW5zZXJ0VmFsdWUgPSBjb252ZXJ0VG9BcnJheVBheWxvYWQoY2xvbmVPYmplY3QodmFsdWUpKTtcbiAgICAgICAgY29uc3QgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMgPSBpbnNlcnQoY29udHJvbC5fZ2V0RmllbGRBcnJheShuYW1lKSwgaW5kZXgsIGluc2VydFZhbHVlKTtcbiAgICAgICAgY29udHJvbC5fbmFtZXMuZm9jdXMgPSBnZXRGb2N1c0ZpZWxkTmFtZShuYW1lLCBpbmRleCwgb3B0aW9ucyk7XG4gICAgICAgIGlkcy5jdXJyZW50ID0gaW5zZXJ0KGlkcy5jdXJyZW50LCBpbmRleCwgaW5zZXJ0VmFsdWUubWFwKGdlbmVyYXRlSWQpKTtcbiAgICAgICAgdXBkYXRlVmFsdWVzKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICAgICAgc2V0RmllbGRzKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICAgICAgY29udHJvbC5fc2V0RmllbGRBcnJheShuYW1lLCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcywgaW5zZXJ0LCB7XG4gICAgICAgICAgICBhcmdBOiBpbmRleCxcbiAgICAgICAgICAgIGFyZ0I6IGZpbGxFbXB0eUFycmF5KHZhbHVlKSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBzd2FwID0gKGluZGV4QSwgaW5kZXhCKSA9PiB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzID0gY29udHJvbC5fZ2V0RmllbGRBcnJheShuYW1lKTtcbiAgICAgICAgc3dhcEFycmF5QXQodXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMsIGluZGV4QSwgaW5kZXhCKTtcbiAgICAgICAgc3dhcEFycmF5QXQoaWRzLmN1cnJlbnQsIGluZGV4QSwgaW5kZXhCKTtcbiAgICAgICAgdXBkYXRlVmFsdWVzKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICAgICAgc2V0RmllbGRzKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICAgICAgY29udHJvbC5fc2V0RmllbGRBcnJheShuYW1lLCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcywgc3dhcEFycmF5QXQsIHtcbiAgICAgICAgICAgIGFyZ0E6IGluZGV4QSxcbiAgICAgICAgICAgIGFyZ0I6IGluZGV4QixcbiAgICAgICAgfSwgZmFsc2UpO1xuICAgIH07XG4gICAgY29uc3QgbW92ZSA9IChmcm9tLCB0bykgPT4ge1xuICAgICAgICBjb25zdCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcyA9IGNvbnRyb2wuX2dldEZpZWxkQXJyYXkobmFtZSk7XG4gICAgICAgIG1vdmVBcnJheUF0KHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzLCBmcm9tLCB0byk7XG4gICAgICAgIG1vdmVBcnJheUF0KGlkcy5jdXJyZW50LCBmcm9tLCB0byk7XG4gICAgICAgIHVwZGF0ZVZhbHVlcyh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgICAgIHNldEZpZWxkcyh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgICAgIGNvbnRyb2wuX3NldEZpZWxkQXJyYXkobmFtZSwgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMsIG1vdmVBcnJheUF0LCB7XG4gICAgICAgICAgICBhcmdBOiBmcm9tLFxuICAgICAgICAgICAgYXJnQjogdG8sXG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICB9O1xuICAgIGNvbnN0IHVwZGF0ZSA9IChpbmRleCwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgdXBkYXRlVmFsdWUgPSBjbG9uZU9iamVjdCh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzID0gdXBkYXRlQXQoY29udHJvbC5fZ2V0RmllbGRBcnJheShuYW1lKSwgaW5kZXgsIHVwZGF0ZVZhbHVlKTtcbiAgICAgICAgaWRzLmN1cnJlbnQgPSBbLi4udXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXNdLm1hcCgoaXRlbSwgaSkgPT4gIWl0ZW0gfHwgaSA9PT0gaW5kZXggPyBnZW5lcmF0ZUlkKCkgOiBpZHMuY3VycmVudFtpXSk7XG4gICAgICAgIHVwZGF0ZVZhbHVlcyh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgICAgIHNldEZpZWxkcyhbLi4udXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXNdKTtcbiAgICAgICAgY29udHJvbC5fc2V0RmllbGRBcnJheShuYW1lLCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcywgdXBkYXRlQXQsIHtcbiAgICAgICAgICAgIGFyZ0E6IGluZGV4LFxuICAgICAgICAgICAgYXJnQjogdXBkYXRlVmFsdWUsXG4gICAgICAgIH0sIHRydWUsIGZhbHNlKTtcbiAgICB9O1xuICAgIGNvbnN0IHJlcGxhY2UgPSAodmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMgPSBjb252ZXJ0VG9BcnJheVBheWxvYWQoY2xvbmVPYmplY3QodmFsdWUpKTtcbiAgICAgICAgaWRzLmN1cnJlbnQgPSB1cGRhdGVkRmllbGRBcnJheVZhbHVlcy5tYXAoZ2VuZXJhdGVJZCk7XG4gICAgICAgIHVwZGF0ZVZhbHVlcyhbLi4udXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXNdKTtcbiAgICAgICAgc2V0RmllbGRzKFsuLi51cGRhdGVkRmllbGRBcnJheVZhbHVlc10pO1xuICAgICAgICBjb250cm9sLl9zZXRGaWVsZEFycmF5KG5hbWUsIFsuLi51cGRhdGVkRmllbGRBcnJheVZhbHVlc10sIChkYXRhKSA9PiBkYXRhLCB7fSwgdHJ1ZSwgZmFsc2UpO1xuICAgIH07XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29udHJvbC5fc3RhdGUuYWN0aW9uID0gZmFsc2U7XG4gICAgICAgIGlzV2F0Y2hlZChuYW1lLCBjb250cm9sLl9uYW1lcykgJiZcbiAgICAgICAgICAgIGNvbnRyb2wuX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgICAgIC4uLmNvbnRyb2wuX2Zvcm1TdGF0ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBpZiAoX2FjdGlvbmVkLmN1cnJlbnQgJiZcbiAgICAgICAgICAgICghZ2V0VmFsaWRhdGlvbk1vZGVzKGNvbnRyb2wuX29wdGlvbnMubW9kZSkuaXNPblN1Ym1pdCB8fFxuICAgICAgICAgICAgICAgIGNvbnRyb2wuX2Zvcm1TdGF0ZS5pc1N1Ym1pdHRlZCkgJiZcbiAgICAgICAgICAgICFnZXRWYWxpZGF0aW9uTW9kZXMoY29udHJvbC5fb3B0aW9ucy5yZVZhbGlkYXRlTW9kZSkuaXNPblN1Ym1pdCkge1xuICAgICAgICAgICAgaWYgKGNvbnRyb2wuX29wdGlvbnMucmVzb2x2ZXIpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sLl9ydW5TY2hlbWEoW25hbWVdKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBnZXQocmVzdWx0LmVycm9ycywgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nRXJyb3IgPSBnZXQoY29udHJvbC5fZm9ybVN0YXRlLmVycm9ycywgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ0Vycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICghZXJyb3IgJiYgZXhpc3RpbmdFcnJvci50eXBlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChlcnJvciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZXhpc3RpbmdFcnJvci50eXBlICE9PSBlcnJvci50eXBlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ0Vycm9yLm1lc3NhZ2UgIT09IGVycm9yLm1lc3NhZ2UpKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBlcnJvciAmJiBlcnJvci50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gc2V0KGNvbnRyb2wuX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUsIGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5zZXQoY29udHJvbC5fZm9ybVN0YXRlLmVycm9ycywgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sLl9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnM6IGNvbnRyb2wuX2Zvcm1TdGF0ZS5lcnJvcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoY29udHJvbC5fZmllbGRzLCBuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQgJiZcbiAgICAgICAgICAgICAgICAgICAgZmllbGQuX2YgJiZcbiAgICAgICAgICAgICAgICAgICAgIShnZXRWYWxpZGF0aW9uTW9kZXMoY29udHJvbC5fb3B0aW9ucy5yZVZhbGlkYXRlTW9kZSkuaXNPblN1Ym1pdCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VmFsaWRhdGlvbk1vZGVzKGNvbnRyb2wuX29wdGlvbnMubW9kZSkuaXNPblN1Ym1pdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVGaWVsZChmaWVsZCwgY29udHJvbC5fbmFtZXMuZGlzYWJsZWQsIGNvbnRyb2wuX2Zvcm1WYWx1ZXMsIGNvbnRyb2wuX29wdGlvbnMuY3JpdGVyaWFNb2RlID09PSBWQUxJREFUSU9OX01PREUuYWxsLCBjb250cm9sLl9vcHRpb25zLnNob3VsZFVzZU5hdGl2ZVZhbGlkYXRpb24sIHRydWUpLnRoZW4oKGVycm9yKSA9PiAhaXNFbXB0eU9iamVjdChlcnJvcikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2wuX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yczogdXBkYXRlRmllbGRBcnJheVJvb3RFcnJvcihjb250cm9sLl9mb3JtU3RhdGUuZXJyb3JzLCBlcnJvciwgbmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnRyb2wuX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHZhbHVlczogY2xvbmVPYmplY3QoY29udHJvbC5fZm9ybVZhbHVlcyksXG4gICAgICAgIH0pO1xuICAgICAgICBjb250cm9sLl9uYW1lcy5mb2N1cyAmJlxuICAgICAgICAgICAgaXRlcmF0ZUZpZWxkc0J5QWN0aW9uKGNvbnRyb2wuX2ZpZWxkcywgKHJlZiwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRyb2wuX25hbWVzLmZvY3VzICYmXG4gICAgICAgICAgICAgICAgICAgIGtleS5zdGFydHNXaXRoKGNvbnRyb2wuX25hbWVzLmZvY3VzKSAmJlxuICAgICAgICAgICAgICAgICAgICByZWYuZm9jdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY29udHJvbC5fbmFtZXMuZm9jdXMgPSAnJztcbiAgICAgICAgY29udHJvbC5fc2V0VmFsaWQoKTtcbiAgICAgICAgX2FjdGlvbmVkLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9LCBbZmllbGRzLCBuYW1lLCBjb250cm9sXSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgIWdldChjb250cm9sLl9mb3JtVmFsdWVzLCBuYW1lKSAmJiBjb250cm9sLl9zZXRGaWVsZEFycmF5KG5hbWUpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlTW91bnRlZCA9IChuYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KGNvbnRyb2wuX2ZpZWxkcywgbmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkICYmIGZpZWxkLl9mKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkLl9mLm1vdW50ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnRyb2wuX29wdGlvbnMuc2hvdWxkVW5yZWdpc3RlciB8fCBzaG91bGRVbnJlZ2lzdGVyXG4gICAgICAgICAgICAgICAgPyBjb250cm9sLnVucmVnaXN0ZXIobmFtZSlcbiAgICAgICAgICAgICAgICA6IHVwZGF0ZU1vdW50ZWQobmFtZSwgZmFsc2UpO1xuICAgICAgICB9O1xuICAgIH0sIFtuYW1lLCBjb250cm9sLCBrZXlOYW1lLCBzaG91bGRVbnJlZ2lzdGVyXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3dhcDogUmVhY3QudXNlQ2FsbGJhY2soc3dhcCwgW3VwZGF0ZVZhbHVlcywgbmFtZSwgY29udHJvbF0pLFxuICAgICAgICBtb3ZlOiBSZWFjdC51c2VDYWxsYmFjayhtb3ZlLCBbdXBkYXRlVmFsdWVzLCBuYW1lLCBjb250cm9sXSksXG4gICAgICAgIHByZXBlbmQ6IFJlYWN0LnVzZUNhbGxiYWNrKHByZXBlbmQsIFt1cGRhdGVWYWx1ZXMsIG5hbWUsIGNvbnRyb2xdKSxcbiAgICAgICAgYXBwZW5kOiBSZWFjdC51c2VDYWxsYmFjayhhcHBlbmQsIFt1cGRhdGVWYWx1ZXMsIG5hbWUsIGNvbnRyb2xdKSxcbiAgICAgICAgcmVtb3ZlOiBSZWFjdC51c2VDYWxsYmFjayhyZW1vdmUsIFt1cGRhdGVWYWx1ZXMsIG5hbWUsIGNvbnRyb2xdKSxcbiAgICAgICAgaW5zZXJ0OiBSZWFjdC51c2VDYWxsYmFjayhpbnNlcnQkMSwgW3VwZGF0ZVZhbHVlcywgbmFtZSwgY29udHJvbF0pLFxuICAgICAgICB1cGRhdGU6IFJlYWN0LnVzZUNhbGxiYWNrKHVwZGF0ZSwgW3VwZGF0ZVZhbHVlcywgbmFtZSwgY29udHJvbF0pLFxuICAgICAgICByZXBsYWNlOiBSZWFjdC51c2VDYWxsYmFjayhyZXBsYWNlLCBbdXBkYXRlVmFsdWVzLCBuYW1lLCBjb250cm9sXSksXG4gICAgICAgIGZpZWxkczogUmVhY3QudXNlTWVtbygoKSA9PiBmaWVsZHMubWFwKChmaWVsZCwgaW5kZXgpID0+ICh7XG4gICAgICAgICAgICAuLi5maWVsZCxcbiAgICAgICAgICAgIFtrZXlOYW1lXTogaWRzLmN1cnJlbnRbaW5kZXhdIHx8IGdlbmVyYXRlSWQoKSxcbiAgICAgICAgfSkpLCBbZmllbGRzLCBrZXlOYW1lXSksXG4gICAgfTtcbn1cblxuLyoqXG4gKiBDdXN0b20gaG9vayB0byBtYW5hZ2UgdGhlIGVudGlyZSBmb3JtLlxuICpcbiAqIEByZW1hcmtzXG4gKiBbQVBJXShodHRwczovL3JlYWN0LWhvb2stZm9ybS5jb20vZG9jcy91c2Vmb3JtKSDigKIgW0RlbW9dKGh0dHBzOi8vY29kZXNhbmRib3guaW8vcy9yZWFjdC1ob29rLWZvcm0tZ2V0LXN0YXJ0ZWQtdHMtNWtzbW0pIOKAoiBbVmlkZW9dKGh0dHBzOi8vd3d3LnlvdXR1YmUuY29tL3dhdGNoP3Y9UmtYdjRBWFhDXzQpXG4gKlxuICogQHBhcmFtIHByb3BzIC0gZm9ybSBjb25maWd1cmF0aW9uIGFuZCB2YWxpZGF0aW9uIHBhcmFtZXRlcnMuXG4gKlxuICogQHJldHVybnMgbWV0aG9kcyAtIGluZGl2aWR1YWwgZnVuY3Rpb25zIHRvIG1hbmFnZSB0aGUgZm9ybSBzdGF0ZS4ge0BsaW5rIFVzZUZvcm1SZXR1cm59XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogZnVuY3Rpb24gQXBwKCkge1xuICogICBjb25zdCB7IHJlZ2lzdGVyLCBoYW5kbGVTdWJtaXQsIHdhdGNoLCBmb3JtU3RhdGU6IHsgZXJyb3JzIH0gfSA9IHVzZUZvcm0oKTtcbiAqICAgY29uc3Qgb25TdWJtaXQgPSBkYXRhID0+IGNvbnNvbGUubG9nKGRhdGEpO1xuICpcbiAqICAgY29uc29sZS5sb2cod2F0Y2goXCJleGFtcGxlXCIpKTtcbiAqXG4gKiAgIHJldHVybiAoXG4gKiAgICAgPGZvcm0gb25TdWJtaXQ9e2hhbmRsZVN1Ym1pdChvblN1Ym1pdCl9PlxuICogICAgICAgPGlucHV0IGRlZmF1bHRWYWx1ZT1cInRlc3RcIiB7Li4ucmVnaXN0ZXIoXCJleGFtcGxlXCIpfSAvPlxuICogICAgICAgPGlucHV0IHsuLi5yZWdpc3RlcihcImV4YW1wbGVSZXF1aXJlZFwiLCB7IHJlcXVpcmVkOiB0cnVlIH0pfSAvPlxuICogICAgICAge2Vycm9ycy5leGFtcGxlUmVxdWlyZWQgJiYgPHNwYW4+VGhpcyBmaWVsZCBpcyByZXF1aXJlZDwvc3Bhbj59XG4gKiAgICAgICA8YnV0dG9uPlN1Ym1pdDwvYnV0dG9uPlxuICogICAgIDwvZm9ybT5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiB1c2VGb3JtKHByb3BzID0ge30pIHtcbiAgICBjb25zdCBfZm9ybUNvbnRyb2wgPSBSZWFjdC51c2VSZWYodW5kZWZpbmVkKTtcbiAgICBjb25zdCBfdmFsdWVzID0gUmVhY3QudXNlUmVmKHVuZGVmaW5lZCk7XG4gICAgY29uc3QgW2Zvcm1TdGF0ZSwgdXBkYXRlRm9ybVN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKHtcbiAgICAgICAgaXNEaXJ0eTogZmFsc2UsXG4gICAgICAgIGlzVmFsaWRhdGluZzogZmFsc2UsXG4gICAgICAgIGlzTG9hZGluZzogaXNGdW5jdGlvbihwcm9wcy5kZWZhdWx0VmFsdWVzKSxcbiAgICAgICAgaXNTdWJtaXR0ZWQ6IGZhbHNlLFxuICAgICAgICBpc1N1Ym1pdHRpbmc6IGZhbHNlLFxuICAgICAgICBpc1N1Ym1pdFN1Y2Nlc3NmdWw6IGZhbHNlLFxuICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgc3VibWl0Q291bnQ6IDAsXG4gICAgICAgIGRpcnR5RmllbGRzOiB7fSxcbiAgICAgICAgdG91Y2hlZEZpZWxkczoge30sXG4gICAgICAgIHZhbGlkYXRpbmdGaWVsZHM6IHt9LFxuICAgICAgICBlcnJvcnM6IHByb3BzLmVycm9ycyB8fCB7fSxcbiAgICAgICAgZGlzYWJsZWQ6IHByb3BzLmRpc2FibGVkIHx8IGZhbHNlLFxuICAgICAgICBpc1JlYWR5OiBmYWxzZSxcbiAgICAgICAgZGVmYXVsdFZhbHVlczogaXNGdW5jdGlvbihwcm9wcy5kZWZhdWx0VmFsdWVzKVxuICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgIDogcHJvcHMuZGVmYXVsdFZhbHVlcyxcbiAgICB9KTtcbiAgICBpZiAoIV9mb3JtQ29udHJvbC5jdXJyZW50KSB7XG4gICAgICAgIGlmIChwcm9wcy5mb3JtQ29udHJvbCkge1xuICAgICAgICAgICAgX2Zvcm1Db250cm9sLmN1cnJlbnQgPSB7XG4gICAgICAgICAgICAgICAgLi4ucHJvcHMuZm9ybUNvbnRyb2wsXG4gICAgICAgICAgICAgICAgZm9ybVN0YXRlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChwcm9wcy5kZWZhdWx0VmFsdWVzICYmICFpc0Z1bmN0aW9uKHByb3BzLmRlZmF1bHRWYWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgcHJvcHMuZm9ybUNvbnRyb2wucmVzZXQocHJvcHMuZGVmYXVsdFZhbHVlcywgcHJvcHMucmVzZXRPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZm9ybUNvbnRyb2wsIC4uLnJlc3QgfSA9IGNyZWF0ZUZvcm1Db250cm9sKHByb3BzKTtcbiAgICAgICAgICAgIF9mb3JtQ29udHJvbC5jdXJyZW50ID0ge1xuICAgICAgICAgICAgICAgIC4uLnJlc3QsXG4gICAgICAgICAgICAgICAgZm9ybVN0YXRlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjb250cm9sID0gX2Zvcm1Db250cm9sLmN1cnJlbnQuY29udHJvbDtcbiAgICBjb250cm9sLl9vcHRpb25zID0gcHJvcHM7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN1YiA9IGNvbnRyb2wuX3N1YnNjcmliZSh7XG4gICAgICAgICAgICBmb3JtU3RhdGU6IGNvbnRyb2wuX3Byb3h5Rm9ybVN0YXRlLFxuICAgICAgICAgICAgY2FsbGJhY2s6ICgpID0+IHVwZGF0ZUZvcm1TdGF0ZSh7IC4uLmNvbnRyb2wuX2Zvcm1TdGF0ZSB9KSxcbiAgICAgICAgICAgIHJlUmVuZGVyUm9vdDogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHVwZGF0ZUZvcm1TdGF0ZSgoZGF0YSkgPT4gKHtcbiAgICAgICAgICAgIC4uLmRhdGEsXG4gICAgICAgICAgICBpc1JlYWR5OiB0cnVlLFxuICAgICAgICB9KSk7XG4gICAgICAgIGNvbnRyb2wuX2Zvcm1TdGF0ZS5pc1JlYWR5ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHN1YjtcbiAgICB9LCBbY29udHJvbF0pO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiBjb250cm9sLl9kaXNhYmxlRm9ybShwcm9wcy5kaXNhYmxlZCksIFtjb250cm9sLCBwcm9wcy5kaXNhYmxlZF0pO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChwcm9wcy5tb2RlKSB7XG4gICAgICAgICAgICBjb250cm9sLl9vcHRpb25zLm1vZGUgPSBwcm9wcy5tb2RlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wcy5yZVZhbGlkYXRlTW9kZSkge1xuICAgICAgICAgICAgY29udHJvbC5fb3B0aW9ucy5yZVZhbGlkYXRlTW9kZSA9IHByb3BzLnJlVmFsaWRhdGVNb2RlO1xuICAgICAgICB9XG4gICAgfSwgW2NvbnRyb2wsIHByb3BzLm1vZGUsIHByb3BzLnJlVmFsaWRhdGVNb2RlXSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHByb3BzLmVycm9ycykge1xuICAgICAgICAgICAgY29udHJvbC5fc2V0RXJyb3JzKHByb3BzLmVycm9ycyk7XG4gICAgICAgICAgICBjb250cm9sLl9mb2N1c0Vycm9yKCk7XG4gICAgICAgIH1cbiAgICB9LCBbY29udHJvbCwgcHJvcHMuZXJyb3JzXSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgcHJvcHMuc2hvdWxkVW5yZWdpc3RlciAmJlxuICAgICAgICAgICAgY29udHJvbC5fc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICAgICAgdmFsdWVzOiBjb250cm9sLl9nZXRXYXRjaCgpLFxuICAgICAgICAgICAgfSk7XG4gICAgfSwgW2NvbnRyb2wsIHByb3BzLnNob3VsZFVucmVnaXN0ZXJdKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoY29udHJvbC5fcHJveHlGb3JtU3RhdGUuaXNEaXJ0eSkge1xuICAgICAgICAgICAgY29uc3QgaXNEaXJ0eSA9IGNvbnRyb2wuX2dldERpcnR5KCk7XG4gICAgICAgICAgICBpZiAoaXNEaXJ0eSAhPT0gZm9ybVN0YXRlLmlzRGlydHkpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sLl9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgaXNEaXJ0eSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtjb250cm9sLCBmb3JtU3RhdGUuaXNEaXJ0eV0pO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChwcm9wcy52YWx1ZXMgJiYgIWRlZXBFcXVhbChwcm9wcy52YWx1ZXMsIF92YWx1ZXMuY3VycmVudCkpIHtcbiAgICAgICAgICAgIGNvbnRyb2wuX3Jlc2V0KHByb3BzLnZhbHVlcywge1xuICAgICAgICAgICAgICAgIGtlZXBGaWVsZHNSZWY6IHRydWUsXG4gICAgICAgICAgICAgICAgLi4uY29udHJvbC5fb3B0aW9ucy5yZXNldE9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF92YWx1ZXMuY3VycmVudCA9IHByb3BzLnZhbHVlcztcbiAgICAgICAgICAgIHVwZGF0ZUZvcm1TdGF0ZSgoc3RhdGUpID0+ICh7IC4uLnN0YXRlIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRyb2wuX3Jlc2V0RGVmYXVsdFZhbHVlcygpO1xuICAgICAgICB9XG4gICAgfSwgW2NvbnRyb2wsIHByb3BzLnZhbHVlc10pO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghY29udHJvbC5fc3RhdGUubW91bnQpIHtcbiAgICAgICAgICAgIGNvbnRyb2wuX3NldFZhbGlkKCk7XG4gICAgICAgICAgICBjb250cm9sLl9zdGF0ZS5tb3VudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRyb2wuX3N0YXRlLndhdGNoKSB7XG4gICAgICAgICAgICBjb250cm9sLl9zdGF0ZS53YXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgY29udHJvbC5fc3ViamVjdHMuc3RhdGUubmV4dCh7IC4uLmNvbnRyb2wuX2Zvcm1TdGF0ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb250cm9sLl9yZW1vdmVVbm1vdW50ZWQoKTtcbiAgICB9KTtcbiAgICBfZm9ybUNvbnRyb2wuY3VycmVudC5mb3JtU3RhdGUgPSBnZXRQcm94eUZvcm1TdGF0ZShmb3JtU3RhdGUsIGNvbnRyb2wpO1xuICAgIHJldHVybiBfZm9ybUNvbnRyb2wuY3VycmVudDtcbn1cblxuZXhwb3J0IHsgQ29udHJvbGxlciwgRm9ybSwgRm9ybVByb3ZpZGVyLCBhcHBlbmRFcnJvcnMsIGNyZWF0ZUZvcm1Db250cm9sLCBnZXQsIHNldCwgdXNlQ29udHJvbGxlciwgdXNlRmllbGRBcnJheSwgdXNlRm9ybSwgdXNlRm9ybUNvbnRleHQsIHVzZUZvcm1TdGF0ZSwgdXNlV2F0Y2ggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbS5tanMubWFwXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJpc0NoZWNrQm94SW5wdXQiLCJlbGVtZW50IiwidHlwZSIsImlzRGF0ZU9iamVjdCIsInZhbHVlIiwiRGF0ZSIsImlzTnVsbE9yVW5kZWZpbmVkIiwiaXNPYmplY3RUeXBlIiwiaXNPYmplY3QiLCJBcnJheSIsImlzQXJyYXkiLCJnZXRFdmVudFZhbHVlIiwiZXZlbnQiLCJ0YXJnZXQiLCJjaGVja2VkIiwiZ2V0Tm9kZVBhcmVudE5hbWUiLCJuYW1lIiwic3Vic3RyaW5nIiwic2VhcmNoIiwiaXNOYW1lSW5GaWVsZEFycmF5IiwibmFtZXMiLCJoYXMiLCJpc1BsYWluT2JqZWN0IiwidGVtcE9iamVjdCIsInByb3RvdHlwZUNvcHkiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiaXNXZWIiLCJ3aW5kb3ciLCJIVE1MRWxlbWVudCIsImRvY3VtZW50IiwiY2xvbmVPYmplY3QiLCJkYXRhIiwiY29weSIsImlzRmlsZUxpc3RJbnN0YW5jZSIsIkZpbGVMaXN0IiwiQmxvYiIsIk9iamVjdCIsImNyZWF0ZSIsImdldFByb3RvdHlwZU9mIiwia2V5IiwiaXNLZXkiLCJ0ZXN0IiwiaXNVbmRlZmluZWQiLCJ2YWwiLCJ1bmRlZmluZWQiLCJjb21wYWN0IiwiZmlsdGVyIiwiQm9vbGVhbiIsInN0cmluZ1RvUGF0aCIsImlucHV0IiwicmVwbGFjZSIsInNwbGl0IiwiZ2V0Iiwib2JqZWN0IiwicGF0aCIsImRlZmF1bHRWYWx1ZSIsInJlc3VsdCIsInJlZHVjZSIsImlzQm9vbGVhbiIsInNldCIsImluZGV4IiwidGVtcFBhdGgiLCJsZW5ndGgiLCJsYXN0SW5kZXgiLCJuZXdWYWx1ZSIsIm9ialZhbHVlIiwiaXNOYU4iLCJFVkVOVFMiLCJCTFVSIiwiRk9DVVNfT1VUIiwiQ0hBTkdFIiwiVkFMSURBVElPTl9NT0RFIiwib25CbHVyIiwib25DaGFuZ2UiLCJvblN1Ym1pdCIsIm9uVG91Y2hlZCIsImFsbCIsIklOUFVUX1ZBTElEQVRJT05fUlVMRVMiLCJtYXgiLCJtaW4iLCJtYXhMZW5ndGgiLCJtaW5MZW5ndGgiLCJwYXR0ZXJuIiwicmVxdWlyZWQiLCJ2YWxpZGF0ZSIsIkhvb2tGb3JtQ29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJkaXNwbGF5TmFtZSIsInVzZUZvcm1Db250ZXh0IiwidXNlQ29udGV4dCIsIkZvcm1Qcm92aWRlciIsInByb3BzIiwiY2hpbGRyZW4iLCJjcmVhdGVFbGVtZW50IiwiUHJvdmlkZXIiLCJnZXRQcm94eUZvcm1TdGF0ZSIsImZvcm1TdGF0ZSIsImNvbnRyb2wiLCJsb2NhbFByb3h5Rm9ybVN0YXRlIiwiaXNSb290IiwiZGVmYXVsdFZhbHVlcyIsIl9kZWZhdWx0VmFsdWVzIiwiZGVmaW5lUHJvcGVydHkiLCJfa2V5IiwiX3Byb3h5Rm9ybVN0YXRlIiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCIsInVzZUxheW91dEVmZmVjdCIsInVzZUVmZmVjdCIsInVzZUZvcm1TdGF0ZSIsIm1ldGhvZHMiLCJkaXNhYmxlZCIsImV4YWN0IiwidXBkYXRlRm9ybVN0YXRlIiwidXNlU3RhdGUiLCJfZm9ybVN0YXRlIiwiX2xvY2FsUHJveHlGb3JtU3RhdGUiLCJ1c2VSZWYiLCJpc0RpcnR5IiwiaXNMb2FkaW5nIiwiZGlydHlGaWVsZHMiLCJ0b3VjaGVkRmllbGRzIiwidmFsaWRhdGluZ0ZpZWxkcyIsImlzVmFsaWRhdGluZyIsImlzVmFsaWQiLCJlcnJvcnMiLCJfc3Vic2NyaWJlIiwiY3VycmVudCIsImNhbGxiYWNrIiwiX3NldFZhbGlkIiwidXNlTWVtbyIsImlzU3RyaW5nIiwiZ2VuZXJhdGVXYXRjaE91dHB1dCIsIl9uYW1lcyIsImZvcm1WYWx1ZXMiLCJpc0dsb2JhbCIsIndhdGNoIiwiYWRkIiwibWFwIiwiZmllbGROYW1lIiwid2F0Y2hBbGwiLCJpc1ByaW1pdGl2ZSIsImRlZXBFcXVhbCIsIm9iamVjdDEiLCJvYmplY3QyIiwiX2ludGVybmFsX3Zpc2l0ZWQiLCJXZWFrU2V0IiwiZ2V0VGltZSIsImtleXMxIiwia2V5cyIsImtleXMyIiwidmFsMSIsImluY2x1ZGVzIiwidmFsMiIsInVzZVdhdGNoIiwiY29tcHV0ZSIsIl9kZWZhdWx0VmFsdWUiLCJfY29tcHV0ZSIsIl9jb21wdXRlRm9ybVZhbHVlcyIsImRlZmF1bHRWYWx1ZU1lbW8iLCJfZ2V0V2F0Y2giLCJ1cGRhdGVWYWx1ZSIsInZhbHVlcyIsIl9mb3JtVmFsdWVzIiwiY29tcHV0ZWRGb3JtVmFsdWVzIiwiX3JlbW92ZVVubW91bnRlZCIsInVzZUNvbnRyb2xsZXIiLCJzaG91bGRVbnJlZ2lzdGVyIiwiaXNBcnJheUZpZWxkIiwiYXJyYXkiLCJfcHJvcHMiLCJfcHJldmlvdXNOYW1lUmVmIiwiX3JlZ2lzdGVyUHJvcHMiLCJyZWdpc3RlciIsInJ1bGVzIiwiZmllbGRTdGF0ZSIsImRlZmluZVByb3BlcnRpZXMiLCJpbnZhbGlkIiwiZW51bWVyYWJsZSIsImlzVG91Y2hlZCIsImVycm9yIiwidXNlQ2FsbGJhY2siLCJyZWYiLCJlbG0iLCJmaWVsZCIsIl9maWVsZHMiLCJfZiIsImZvY3VzIiwic2VsZWN0Iiwic2V0Q3VzdG9tVmFsaWRpdHkiLCJtZXNzYWdlIiwicmVwb3J0VmFsaWRpdHkiLCJfc2hvdWxkVW5yZWdpc3RlckZpZWxkIiwiX29wdGlvbnMiLCJwcmV2aW91c05hbWUiLCJ1bnJlZ2lzdGVyIiwidXBkYXRlTW91bnRlZCIsIm1vdW50IiwiX3N0YXRlIiwiYWN0aW9uIiwiX3NldERpc2FibGVkRmllbGQiLCJDb250cm9sbGVyIiwicmVuZGVyIiwiZmxhdHRlbiIsIm9iaiIsIm91dHB1dCIsIm5lc3RlZCIsIm5lc3RlZEtleSIsIlBPU1RfUkVRVUVTVCIsIkZvcm0iLCJtb3VudGVkIiwic2V0TW91bnRlZCIsIm1ldGhvZCIsImhlYWRlcnMiLCJlbmNUeXBlIiwib25FcnJvciIsIm9uU3VjY2VzcyIsInZhbGlkYXRlU3RhdHVzIiwicmVzdCIsInN1Ym1pdCIsImhhc0Vycm9yIiwiaGFuZGxlU3VibWl0IiwiZm9ybURhdGEiLCJGb3JtRGF0YSIsImZvcm1EYXRhSnNvbiIsIkpTT04iLCJzdHJpbmdpZnkiLCJfYSIsImZsYXR0ZW5Gb3JtVmFsdWVzIiwiYXBwZW5kIiwic2hvdWxkU3RyaW5naWZ5U3VibWlzc2lvbkRhdGEiLCJzb21lIiwicmVzcG9uc2UiLCJmZXRjaCIsIlN0cmluZyIsImJvZHkiLCJzdGF0dXMiLCJfc3ViamVjdHMiLCJzdGF0ZSIsIm5leHQiLCJpc1N1Ym1pdFN1Y2Nlc3NmdWwiLCJzZXRFcnJvciIsIkZyYWdtZW50Iiwibm9WYWxpZGF0ZSIsImFwcGVuZEVycm9ycyIsInZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSIsInR5cGVzIiwiY29udmVydFRvQXJyYXlQYXlsb2FkIiwiY3JlYXRlU3ViamVjdCIsIl9vYnNlcnZlcnMiLCJvYnNlcnZlciIsInN1YnNjcmliZSIsInB1c2giLCJ1bnN1YnNjcmliZSIsIm8iLCJvYnNlcnZlcnMiLCJleHRyYWN0Rm9ybVZhbHVlcyIsImZpZWxkc1N0YXRlIiwiZmllbGRWYWx1ZSIsIm5lc3RlZEZpZWxkc1N0YXRlIiwiaXNFbXB0eU9iamVjdCIsImlzRmlsZUlucHV0IiwiaXNGdW5jdGlvbiIsImlzSFRNTEVsZW1lbnQiLCJvd25lciIsIm93bmVyRG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsImlzTXVsdGlwbGVTZWxlY3QiLCJpc1JhZGlvSW5wdXQiLCJpc1JhZGlvT3JDaGVja2JveCIsImxpdmUiLCJpc0Nvbm5lY3RlZCIsImJhc2VHZXQiLCJ1cGRhdGVQYXRoIiwic2xpY2UiLCJpc0VtcHR5QXJyYXkiLCJ1bnNldCIsInBhdGhzIiwiY2hpbGRPYmplY3QiLCJvYmplY3RIYXNGdW5jdGlvbiIsImlzVHJhdmVyc2FibGUiLCJtYXJrRmllbGRzRGlydHkiLCJmaWVsZHMiLCJnZXREaXJ0eUZpZWxkcyIsImRpcnR5RmllbGRzRnJvbVZhbHVlcyIsImRlZmF1bHRSZXN1bHQiLCJ2YWxpZFJlc3VsdCIsImdldENoZWNrYm94VmFsdWUiLCJvcHRpb25zIiwib3B0aW9uIiwiYXR0cmlidXRlcyIsImdldEZpZWxkVmFsdWVBcyIsInZhbHVlQXNOdW1iZXIiLCJ2YWx1ZUFzRGF0ZSIsInNldFZhbHVlQXMiLCJOYU4iLCJkZWZhdWx0UmV0dXJuIiwiZ2V0UmFkaW9WYWx1ZSIsInByZXZpb3VzIiwiZ2V0RmllbGRWYWx1ZSIsImZpbGVzIiwicmVmcyIsInNlbGVjdGVkT3B0aW9ucyIsImdldFJlc29sdmVyT3B0aW9ucyIsImZpZWxkc05hbWVzIiwiY3JpdGVyaWFNb2RlIiwic2hvdWxkVXNlTmF0aXZlVmFsaWRhdGlvbiIsImlzUmVnZXgiLCJSZWdFeHAiLCJnZXRSdWxlVmFsdWUiLCJydWxlIiwic291cmNlIiwiZ2V0VmFsaWRhdGlvbk1vZGVzIiwibW9kZSIsImlzT25TdWJtaXQiLCJpc09uQmx1ciIsImlzT25DaGFuZ2UiLCJpc09uQWxsIiwiaXNPblRvdWNoIiwiQVNZTkNfRlVOQ1RJT04iLCJoYXNQcm9taXNlVmFsaWRhdGlvbiIsImZpZWxkUmVmZXJlbmNlIiwiZmluZCIsInZhbGlkYXRlRnVuY3Rpb24iLCJoYXNWYWxpZGF0aW9uIiwiaXNXYXRjaGVkIiwiaXNCbHVyRXZlbnQiLCJ3YXRjaE5hbWUiLCJzdGFydHNXaXRoIiwiaXRlcmF0ZUZpZWxkc0J5QWN0aW9uIiwiYWJvcnRFYXJseSIsImN1cnJlbnRGaWVsZCIsInNjaGVtYUVycm9yTG9va3VwIiwiam9pbiIsImZvdW5kRXJyb3IiLCJyb290IiwicG9wIiwic2hvdWxkUmVuZGVyRm9ybVN0YXRlIiwiZm9ybVN0YXRlRGF0YSIsInNob3VsZFN1YnNjcmliZUJ5TmFtZSIsInNpZ25hbE5hbWUiLCJjdXJyZW50TmFtZSIsInNraXBWYWxpZGF0aW9uIiwiaXNTdWJtaXR0ZWQiLCJyZVZhbGlkYXRlTW9kZSIsInVuc2V0RW1wdHlBcnJheSIsInVwZGF0ZUZpZWxkQXJyYXlSb290RXJyb3IiLCJmaWVsZEFycmF5RXJyb3JzIiwiZ2V0VmFsaWRhdGVFcnJvciIsImV2ZXJ5IiwiZ2V0VmFsdWVBbmRNZXNzYWdlIiwidmFsaWRhdGlvbkRhdGEiLCJ2YWxpZGF0ZUZpZWxkIiwiZGlzYWJsZWRGaWVsZE5hbWVzIiwiaXNGaWVsZEFycmF5IiwiaW5wdXRWYWx1ZSIsImlucHV0UmVmIiwiaXNSYWRpbyIsImlzQ2hlY2tCb3giLCJpc0VtcHR5IiwiYXBwZW5kRXJyb3JzQ3VycnkiLCJiaW5kIiwiZ2V0TWluTWF4TWVzc2FnZSIsImV4Y2VlZE1heCIsIm1heExlbmd0aE1lc3NhZ2UiLCJtaW5MZW5ndGhNZXNzYWdlIiwibWF4VHlwZSIsIm1pblR5cGUiLCJleGNlZWRNaW4iLCJtYXhPdXRwdXQiLCJtaW5PdXRwdXQiLCJ2YWx1ZU51bWJlciIsInZhbHVlRGF0ZSIsImNvbnZlcnRUaW1lVG9EYXRlIiwidGltZSIsInRvRGF0ZVN0cmluZyIsImlzVGltZSIsImlzV2VlayIsIm1heExlbmd0aE91dHB1dCIsIm1pbkxlbmd0aE91dHB1dCIsInBhdHRlcm5WYWx1ZSIsIm1hdGNoIiwidmFsaWRhdGVFcnJvciIsInZhbGlkYXRpb25SZXN1bHQiLCJkZWZhdWx0T3B0aW9ucyIsInNob3VsZEZvY3VzRXJyb3IiLCJjcmVhdGVGb3JtQ29udHJvbCIsInN1Ym1pdENvdW50IiwiaXNSZWFkeSIsImlzU3VibWl0dGluZyIsIlNldCIsInVuTW91bnQiLCJkZWxheUVycm9yQ2FsbGJhY2siLCJ0aW1lciIsIl9wcm94eVN1YnNjcmliZUZvcm1TdGF0ZSIsInNob3VsZERpc3BsYXlBbGxBc3NvY2lhdGVkRXJyb3JzIiwiZGVib3VuY2UiLCJ3YWl0IiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsInNob3VsZFVwZGF0ZVZhbGlkIiwicmVzb2x2ZXIiLCJfcnVuU2NoZW1hIiwiZXhlY3V0ZUJ1aWx0SW5WYWxpZGF0aW9uIiwiX3VwZGF0ZUlzVmFsaWRhdGluZyIsImZyb20iLCJmb3JFYWNoIiwiX3NldEZpZWxkQXJyYXkiLCJhcmdzIiwic2hvdWxkU2V0VmFsdWVzIiwic2hvdWxkVXBkYXRlRmllbGRzQW5kU3RhdGUiLCJmaWVsZFZhbHVlcyIsImFyZ0EiLCJhcmdCIiwiX2dldERpcnR5IiwidXBkYXRlRXJyb3JzIiwiX3NldEVycm9ycyIsInVwZGF0ZVZhbGlkQW5kVmFsdWUiLCJzaG91bGRTa2lwU2V0VmFsdWVBcyIsImRlZmF1bHRDaGVja2VkIiwic2V0RmllbGRWYWx1ZSIsInVwZGF0ZVRvdWNoQW5kRGlydHkiLCJzaG91bGREaXJ0eSIsInNob3VsZFJlbmRlciIsInNob3VsZFVwZGF0ZUZpZWxkIiwiaXNQcmV2aW91c0RpcnR5IiwiaXNDdXJyZW50RmllbGRQcmlzdGluZSIsImlzUHJldmlvdXNGaWVsZFRvdWNoZWQiLCJzaG91bGRSZW5kZXJCeUVycm9yIiwicHJldmlvdXNGaWVsZEVycm9yIiwiZGVsYXlFcnJvciIsInVwZGF0ZWRGb3JtU3RhdGUiLCJjb250ZXh0IiwiZXhlY3V0ZVNjaGVtYUFuZFVwZGF0ZVN0YXRlIiwic2hvdWxkT25seUNoZWNrVmFsaWQiLCJ2YWxpZCIsImlzRmllbGRBcnJheVJvb3QiLCJpc1Byb21pc2VGdW5jdGlvbiIsImZpZWxkRXJyb3IiLCJnZXRWYWx1ZXMiLCJfZ2V0RmllbGRBcnJheSIsIm9wdGlvblJlZiIsInNlbGVjdGVkIiwiY2hlY2tib3hSZWYiLCJyYWRpb1JlZiIsInNob3VsZFRvdWNoIiwic2hvdWxkVmFsaWRhdGUiLCJ0cmlnZ2VyIiwic2V0VmFsdWVzIiwiZmllbGRLZXkiLCJzZXRWYWx1ZSIsImNsb25lVmFsdWUiLCJpc0ZpZWxkVmFsdWVVcGRhdGVkIiwiX3VwZGF0ZUlzRmllbGRWYWx1ZVVwZGF0ZWQiLCJOdW1iZXIiLCJ2YWxpZGF0aW9uTW9kZUJlZm9yZVN1Ym1pdCIsInZhbGlkYXRpb25Nb2RlQWZ0ZXJTdWJtaXQiLCJzaG91bGRTa2lwVmFsaWRhdGlvbiIsImRlcHMiLCJ3YXRjaGVkIiwicmVhZE9ubHkiLCJwcmV2aW91c0Vycm9yTG9va3VwUmVzdWx0IiwiZXJyb3JMb29rdXBSZXN1bHQiLCJfZm9jdXNJbnB1dCIsImZpZWxkTmFtZXMiLCJQcm9taXNlIiwic2hvdWxkRm9jdXMiLCJjb25maWciLCJnZXRGaWVsZFN0YXRlIiwiY2xlYXJFcnJvcnMiLCJpbnB1dE5hbWUiLCJjdXJyZW50RXJyb3IiLCJjdXJyZW50UmVmIiwicmVzdE9mRXJyb3JUcmVlIiwicGF5bG9hZCIsIl9zZXRGb3JtU3RhdGUiLCJyZVJlbmRlclJvb3QiLCJkZWxldGUiLCJrZWVwVmFsdWUiLCJrZWVwRXJyb3IiLCJrZWVwRGlydHkiLCJrZWVwVG91Y2hlZCIsImtlZXBJc1ZhbGlkYXRpbmciLCJrZWVwRGVmYXVsdFZhbHVlIiwia2VlcElzVmFsaWQiLCJkaXNhYmxlZElzRGVmaW5lZCIsInByb2dyZXNzaXZlIiwiZmllbGRSZWYiLCJxdWVyeVNlbGVjdG9yQWxsIiwicmFkaW9PckNoZWNrYm94IiwiX2ZvY3VzRXJyb3IiLCJfZGlzYWJsZUZvcm0iLCJvblZhbGlkIiwib25JbnZhbGlkIiwiZSIsIm9uVmFsaWRFcnJvciIsInByZXZlbnREZWZhdWx0IiwicGVyc2lzdCIsInNpemUiLCJyZXNldEZpZWxkIiwiX3Jlc2V0Iiwia2VlcFN0YXRlT3B0aW9ucyIsInVwZGF0ZWRWYWx1ZXMiLCJjbG9uZVVwZGF0ZWRWYWx1ZXMiLCJpc0VtcHR5UmVzZXRWYWx1ZXMiLCJrZWVwRGVmYXVsdFZhbHVlcyIsImtlZXBWYWx1ZXMiLCJrZWVwRGlydHlWYWx1ZXMiLCJmaWVsZHNUb0NoZWNrIiwiZm9ybSIsImNsb3Nlc3QiLCJyZXNldCIsImtlZXBGaWVsZHNSZWYiLCJrZWVwU3VibWl0Q291bnQiLCJrZWVwSXNTdWJtaXR0ZWQiLCJrZWVwRXJyb3JzIiwia2VlcElzU3VibWl0U3VjY2Vzc2Z1bCIsInNldEZvY3VzIiwic2hvdWxkU2VsZWN0IiwiX3Jlc2V0RGVmYXVsdFZhbHVlcyIsInRoZW4iLCJyZXNldE9wdGlvbnMiLCJmb3JtQ29udHJvbCIsImdlbmVyYXRlSWQiLCJjcnlwdG8iLCJyYW5kb21VVUlEIiwiZCIsInBlcmZvcm1hbmNlIiwibm93IiwiYyIsInIiLCJNYXRoIiwicmFuZG9tIiwidG9TdHJpbmciLCJnZXRGb2N1c0ZpZWxkTmFtZSIsImZvY3VzTmFtZSIsImZvY3VzSW5kZXgiLCJhcHBlbmRBdCIsImZpbGxFbXB0eUFycmF5IiwiaW5zZXJ0IiwibW92ZUFycmF5QXQiLCJ0byIsInNwbGljZSIsInByZXBlbmRBdCIsInJlbW92ZUF0SW5kZXhlcyIsImluZGV4ZXMiLCJpIiwidGVtcCIsInJlbW92ZUFycmF5QXQiLCJzb3J0IiwiYSIsImIiLCJzd2FwQXJyYXlBdCIsImluZGV4QSIsImluZGV4QiIsInVwZGF0ZUF0IiwidXNlRmllbGRBcnJheSIsImtleU5hbWUiLCJzZXRGaWVsZHMiLCJpZHMiLCJfZmllbGRJZHMiLCJfYWN0aW9uZWQiLCJmaWVsZEFycmF5TmFtZSIsInVwZGF0ZVZhbHVlcyIsInVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzIiwiYXBwZW5kVmFsdWUiLCJwcmVwZW5kIiwicHJlcGVuZFZhbHVlIiwicmVtb3ZlIiwiaW5zZXJ0JDEiLCJpbnNlcnRWYWx1ZSIsInN3YXAiLCJtb3ZlIiwidXBkYXRlIiwiaXRlbSIsImV4aXN0aW5nRXJyb3IiLCJ1c2VGb3JtIiwiX2Zvcm1Db250cm9sIiwiX3ZhbHVlcyIsInN1YiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-hook-form/dist/index.esm.mjs\n");

/***/ })

};
;